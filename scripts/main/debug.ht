// import 'game/data.ht'
// import 'entity/character/character.ht'
// import 'entity/item/item.ht'
// import 'game/dialog.ht'
// import 'world/tile/hexagonal_tile.ht'
// import 'random.ht'

const _kCraftMaterials = [
  'craftmaterial_addAffix',
  'craftmaterial_replaceAffix',
  'craftmaterial_rerollAffix',
  'craftmaterial_upgradeRank1',
  'craftmaterial_upgradeRank2',
  'craftmaterial_upgradeRank3',
  'craftmaterial_upgradeRank4',
  'craftmaterial_upgradeRank5',
]

namespace Debug {

  external function reloadGameData()

  external function reloadModules()

  async function generateHero({rank = 0, level = 0}) {
    final hero = Character(
      id: 'hero',
      level: level,
      rank: rank,
      skillPoints: level,
    )

    setHero('hero')

    final randomEquipmentKind = Constants.equipmentCategoryKinds['weapon'].random
    final item = Equipment(kind: randomEquipmentKind, rank: hero.rank)
    await Player.acquire(item)

    final pack = Cardpack(
      kind: randomEquipmentKind,
      rank: hero.rank,
      isBasic: true,
    )
    await Player.acquire(pack)
    
    final pack2 = Cardpack(
      rank: hero.rank,
      isBasic: true,
    )
    await Player.acquire(pack2)
  }

  function testItem([character]) {
    engine.warn('Debug.testItem ${character?.name}')
    character ??= hero

    for (final affixId in game.battleCards.keys) {
      final card = BattleCard(
        affixId: affixId,
        rank: character.rank,
      )
      characterAcquireBattleCard(character, card)
    }
    
    final items = []
    for (var kind in Constants.equipmentKinds) {
      final item = Equipment(kind: kind, rank: hero.rank)
      items.add(item)
      entityAcquire(character, item)
    }

    for (var genre in [null, ...Constants.cultivationGenres]) {
      final pack = Cardpack(
        genre: genre,
        rank: hero.rank,
      )
      items.add(pack)
      entityAcquire(character, pack)
    }

    for (var i in range(5)) {
      final item = Potion(rank: hero.rank)
      items.add(item)
      entityAcquire(character, item)
    }

    final shardPack = Materialpack(kind: 'shard', amount: 50)
    entityAcquire(character, shardPack)
    items.add(shardPack)

    final moneyPack = Materialpack(kind: 'money', amount: 5000)
    entityAcquire(character, moneyPack)
    items.add(moneyPack)

    for (var i in range(3)) {
      final scroll = createItemById('identify_scroll')
      entityAcquire(character, scroll)
      items.add(scroll)
    }

    for (var i in range(1, kCultivationRankMax + 1)) {
      final paper = createItemById('scroll_paper_rank${i}')
      paper.stackSize = 5
      entityAcquire(character, paper)
      items.add(paper)
    }

    for (var i in range(3)) {
      final spirit = StatusSpirit(rank: hero.rank + 1)
      entityAcquire(character, spirit)
      items.add(spirit)
    }

    for (var materialId in _kCraftMaterials) {
      final material = createItemById(materialId)
      material.stackSize = 10
      entityAcquire(character, material)
      items.add(material)
    }

    for (var i in range(1, kCultivationRankMax + 1)) {
      for (var j in range(3)) {
        final ticket = createItemById('dungeon_ticket_rank${i}')
        entityAcquire(character, ticket)
        items.add(ticket)
      }
    }

    if (character == hero) {
      Game.promptItems(items)
    }
  }

  function testJournal() {
    final journal = hero.journals.organizationInitiation
    if (!journal) {
      journal = Player.createJournalById('organizationInitiation')
    }
    Game.promptJournal(journal)
  }

  function updateAllCaptions() {
    for (const tile in world.terrains) {
      if (tile.locationId) {
        assert(game.locations.containsKey(tile.locationId))
        const location = game.locations[tile.locationId]
        World.setTerrainCaption(tile.left, tile.top, location.name)
      } else if (tile.objectId) {
        World.setTerrainCaption(tile.left, tile.top, tile.objectId)
      }
    }
  }
}