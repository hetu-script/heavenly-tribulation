
const _kCraftMaterials = [
  'craftmaterial_addAffix',
  'craftmaterial_replaceAffix',
  'craftmaterial_rerollAffix',
  'craftmaterial_upgrade',
]

namespace debug {

  external function reloadGameData()

  async function generateHero({rank = 0, level = 0}) {
    final hero = Character(
      id: 'hero',
      level: level,
      rank: rank,
      skillPoints: level,
    )

    setHero('hero')
    final pack = Cardpack(
      rank: hero.rank,
      genre: hero.rank == 0 ? null : hero.cultivationFavor,
      isBasic: hero.rank == 0,
    )
    await Player.acquire(pack)
    final pack2 = Cardpack(
      rank: hero.rank,
      genre: hero.rank == 0 ? null : hero.cultivationFavor,
      isBasic: hero.rank == 0,
    )
    await Player.acquire(pack2)
  }

  function cheat() {
    hero.materials = {
      money: 5000000,
      shard: 5000,
      worker: 5000,
      water: 5000,
      grain: 5000,
      meat: 5000,
      leather: 5000,
      herb: 5000,
      timber: 5000,
      stone: 5000,
      ore: 5000,
    }
  }

  function cheatContribution({ locationId }) {
    final contributionData = {
      sectId: hero.sectId,
      locationId: locationId,
      amount: 5000,
    }
    .makeContribution(contributionData)
  }

  function testItem([character]) {
    engine.warn('debug.testItem ${character?.name}')
    character ??= hero

    for (final affixId in game.battleCards.keys) {
      final card = BattleCard(
        affixId: affixId,
        rank: character.rank,
      )
      characterAcquireBattleCard(character, card)
    }
    
    final items = []
    for (var kind in Constants.equipmentKinds) {
      final item = Equipment(kind: kind, rank: hero.rank)
      items.add(item)
      entityAcquire(character, item)
    }

    for (var genre in [null, ...Constants.cultivationGenres]) {
      final pack = Cardpack(
        genre: genre,
        rank: hero.rank,
      )
      items.add(pack)
      entityAcquire(character, pack)
    }

    for (var i in range(5)) {
      final item = Potion(rank: hero.rank)
      items.add(item)
      entityAcquire(character, item)
    }

    final shardPack = Materialpack(kind: 'shard', amount: 50)
    entityAcquire(character, shardPack)
    items.add(shardPack)

    final moneyPack = Materialpack(kind: 'money', amount: 5000)
    entityAcquire(character, moneyPack)
    items.add(moneyPack)

    for (var i in range(3)) {
      final scroll = createItemById('identify_scroll')
      entityAcquire(character, scroll)
      items.add(scroll)
    }

    for (var i in range(1, kCultivationRankMax + 1)) {
      final paper = createItemById('scroll_paper', rank: i)
      paper.stackSize = 5
      entityAcquire(character, paper)
      items.add(paper)
    }

    for (var i in range(1, kCultivationRankMax + 1)) {
      for (var materialId in _kCraftMaterials) {
        final material = createItemById(materialId, rank: i)
        material.stackSize = 5
        entityAcquire(character, material)
        items.add(material)
      }
    }

    for (var i in range(1, kCultivationRankMax + 1)) {
      for (var j in range(3)) {
        final ticket = createItemById('dungeon_ticket', rank: i)
        entityAcquire(character, ticket)
        items.add(ticket)
      }
    }

    if (character == hero) {
      Game.promptItems(items)
    }
  }

  // function updateAllCaptions() {
  //   for (const tile in world.terrains) {
  //     if (tile.locationId) {
  //       assert(game.locations.containsKey(tile.locationId))
  //       const location = game.locations[tile.locationId]
  //       World.setTerrainCaption(tile.left, tile.top, location.name)
  //     } else if (tile.objectId) {
  //       World.setTerrainCaption(tile.left, tile.top, tile.objectId)
  //     }
  //   }
  // }
}