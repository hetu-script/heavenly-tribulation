
const kMaxTileMapWidth = 150
const kMaxTileMapHeight = 100

const kWaterTerrainKinds = [
  'sea',
  'shelf',
  'lake',
  'river',
]

struct TileMap {
  constructor ({
    id,
    name,
    isMain,
    width,
    height,
    terrainSpriteSheet,
    tileShape = 'hexagonalVertical',
    gridWidth = 32.0,
    gridHeight = 28.0,
    tileSpriteSrcWidth = 32.0,
    tileSpriteSrcHeight = 64.0,
    tileOffsetX = 0.0,
    tileOffsetY = 16.0,
    tileFogOffsetX = 0.0,
    tileFogOffsetY = 0.0,
  }) {
    assert(id != null)
    assert(width > 0 && width <= kMaxTileMapWidth, 'illegal map width: ${width}')
    assert(height > 0 && height <= kMaxTileMapHeight, 'illegal map height: ${height}')

    this.id = id
    this.isMain = isMain ?? false
    this.name = name ?? generateZoneName(category: 'world')

    this.width = width
    this.height = height

    this.terrainSpriteSheet = terrainSpriteSheet
    this.tileShape = tileShape
    this.gridWidth = gridWidth
    this.gridHeight = gridHeight
    this.tileSpriteSrcWidth = tileSpriteSrcWidth
    this.tileSpriteSrcHeight = tileSpriteSrcHeight
    this.tileOffsetX = tileOffsetX
    this.tileOffsetY = tileOffsetY

    this.terrains = []

    // 地区上的区域，例如大陆、海洋、国家等
    this.zones = {}
    // 地图上的可互动对象，例如传送阵等
    this.objects = {}
    // 地图上的非地块类显示组件，例如跨越多个地块的大型贴图或动画等
    this.components = []
  }
}

// 从 hexagonal 坐标得到索引
function tilePos2Index(left, top, mapWidth) {
  return left - 1 + (top - 1) * mapWidth
}

/// 坐标是否在地图范围内
function isPositionWithinMap(left, top, width, height) {
  return (left > 0 && top > 0 && left <= width && top <= height)
}

// 从索引得到 hexagonal 坐标
function index2TilePosition(index: integer, mapWidth) {
  const left = index % mapWidth + 1
  const top = index ~/ mapWidth + 1
  return Tile(left, top, index: index, mapWidth: mapWidth)
}
