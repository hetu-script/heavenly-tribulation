import 'tile/common.ht'
import 'generation_algorithm.ht'
import 'zone.ht'

const _kForestThreshold = 0.6
const _kIslandThreshold = 0.2
const _kMountainThreshold = 0.4

const _kFarmFieldThreshold = 0.08
const _kFisheryThreshold = 0.08
const _kTimberLandThreshold = 0.04
const _kMineThreshold = 0.04
const _kHuntingGroundThreshold = 0.02

const _kDungeonOnTerritoryProbability = 0.5

const _kAdultAge = 15
const _kPregnancyAgeMax = 50
const _kChildrenMax = 3

const _kLocationInitialDevelopmentMax = 4

const _kOrganizationRecruitProbability = 0.6

const _kSandboxInitialRankMax = 3

const _kTerrainResourceBase = 5;
const _kTerrainResourceVariation = 5;
const _kTerrainKindsWithNoResources = ['void', 'city', 'road']

/// 生成世界地图的算法
/// 生成的世界 ID 固定为 `sandboxWorld`
///
/// spritesheet上不同地形对应的编号：
/// 0：虚空
/// 1：浅海
/// 2：深海
/// 3：陆地（草原）
///
/// 算法思路：
///
/// 用噪声算法生成陆地和海洋
///
/// 为陆地所属的整个大地块命名，然后找到尚未命名的地块，将所有相连的地块作为一个整体命名，直到所有的地块都有名字，根据地块大小有不同命名方式
///
/// 根据城市密度，生成城市，并根据城市位于陆地、海边还是海中，对其进行特殊命名
///
/// 对于每个城市，链接最近的另外两个城市，使用 A* 寻路算法，标记经过的地块
///
/// 对于没有道路经过的地块，随机填充山脉和树林

function createSandboxWorld({
    name,
    seed,
    style = 'coast',
    terrainSpriteSheet = 'tilemap/fantasyhextiles_v3_borderless.png',
    width,
    height,
    nationNumber,
    locationNumber,
    characterNumber,
  }) {
  
  assert(seed is int)
  assert(width != null && height != null)
  assert(nationNumber != null)
  assert(locationNumber != null)
  assert(characterNumber != null)
  assert(locationNumber > nationNumber)

  engine.debug('开始生成世界，随机种子：${seed}, 地图大小：[${width}, ${height}]，地图风格：${style}，国家数量：${nationNumber}，据点数量：${locationNumber}，角色数量：${characterNumber}, 门派数量：${nationNumber}')


  // 生成过程中，引入了一些别的文件中的函数
  // 他们可能会通过game.world访问, 因此这里直接使用全局变量
  const newWorld = TileMap(
    id: 'sandboxWorld',
    terrainSpriteSheet: terrainSpriteSheet,
    width: width,
    height: height,
  )

  newWorld.isMain = true
  newWorld.name = name ?? generateZoneName(category: 'world')
  
  addWorld(newWorld)

  engine.debug('生成地块')
  for (const y in range(height)) {
    for (const x in range(width)) {
      let spriteIndex
      if (y > 0 && y < height - 1 && x > 0 && x < width - 1) {
        // 边界地块为 void
        spriteIndex = kSpriteWater
      }
      world.terrains.add(
        TileMapTerrain(
          left: x + 1,
          top: y + 1,
          mapWidth: width,
          spriteIndex: spriteIndex,
        )
      )
    }
  }

  // 没有区域，也是一个区域
  // const voidZone = Zone(category: kZoneEmpty)

  // 生成地域
  engine.debug('生成大陆')
  generateContinent2(newWorld, seed: game.seed, style: style)
  engine.debug('生成地域')
  generateZone(newWorld)
  
  const plainIndexes = Set()
  const forestIndexes = Set()
  
  // 地形装饰贴图
  // 将大陆和海洋接触的地方填充为大陆架，将大陆上没有道路的方格，随机填充为森林
  // 这些修改不影响该地块的 kind
  const lands = world.landIndexes.map((index) => world.terrains[index])
  engine.debug('填充地形装饰贴图：大陆架、森林')
  for (const tile in lands) {
    let isShore = false
    const neighbors = getTileNeighbors(tile.left, tile.top)
    for (const neighbor in neighbors.values) {
      if (neighbor.spriteIndex == kSpriteWater) {
        isShore = true
        break
      }
    }
    if (isShore) {
      tile.kind = 'shore'
      tile.sprite = 'object/shore.png'
    } else {
      // 不是海岸线的陆地，随机生成森林
      const r = random.nextDouble()
      if (r < _kForestThreshold) {
        tile.kind = 'forest'
        tile.sprite = 'object/forest.png'
        forestIndexes.add(tile.index)
      } else {
        tile.kind = 'plain'
        plainIndexes.add(tile.index)
      }
    }
  }

  // zone 的名字和其大小有关
  // 命名区域后，才会得到海洋地块，因为某些水体会被命名为湖泊和河流
  nameZones(newWorld)

  // 生成大陆架，在这一步会将大陆架从 seaIndexes 中剔除
  const waters = world.waterIndexes.map((index) => world.terrains[index])
  for (const tile in waters) {
    let isShelf = false
    const neighbors = getTileNeighbors(tile.left, tile.top)
    for (const neighbor in neighbors.values) {
      if (neighbor.spriteIndex == kSpriteLand) {
        isShelf = true
        break
      }
    }
    if (isShelf) {
      tile.sprite = 'object/shelf.png'
      tile.kind = 'shelf'
      world.fisheryIndexes.add(tile.index)
      world.seaIndexes.remove(tile.index)
    }
  }

  // 生成据点
  // 有四种：城市、港口、山地（洞天）和岛屿（福地），后两者为隐藏据点
  engine.debug('生成大陆上的据点')
  final locations = []
  final locationNeighbors = {}
  const fisheryKinds = ['lake', 'shelf', 'sea']
  const seas = world.seaIndexes.map((index) => world.terrains[index])
  const mountains = world.mountainIndexes.map((index) => world.terrains[index])
  while (locations.length < locationNumber) {
    final typeroll = random.nextDouble()
    let terrain
    let location
    let generated = false
    if (typeroll < _kIslandThreshold) {
      let availableWater = seas.where((tile) => tile.locationId == null)
      if (availableWater.isNotEmpty) {
        generated = true
        terrain = random.nextIterable(availableWater)
        location = Location(
          category: 'city',
          kind: 'island',
          atTerrain: terrain,
          updateWorldMap: false,
          isHidden: true,
          // 随机生成的据点，初始发展度是0-3之间随机。
          development: random.nextInt(_kLocationInitialDevelopmentMax),
        )
      }
    } else if (typeroll < _kMountainThreshold) {
      let availableMountain = mountains.where((tile) => tile.locationId == null)
      if (availableMountain.isNotEmpty) {
        generated = true
        terrain = random.nextIterable(availableMountain)
        location = Location(
          category: 'city',
          kind: 'mountain',
          atTerrain: terrain,
          updateWorldMap: false,
          isHidden: true,
          // 随机生成的据点，初始发展度是0-3之间随机。
          development: random.nextInt(_kLocationInitialDevelopmentMax),
        )
      }
    }

    if (!generated) {
      let availableLands = lands.where((tile) => tile.locationId == null)
      if (availableLands.isEmpty) {
        // 没有可用的地块了，跳出循环
        break
      }
      terrain = random.nextIterable(availableLands)
      location = Location(
        category: 'city',
        kind: terrain.kind == 'shore' ? 'harbor' : 'inland',
        atTerrain: terrain,
        updateWorldMap: false,
        isHidden: false,
        // 随机生成的据点，初始发展度是0-3之间随机。
        development: random.nextInt(_kLocationInitialDevelopmentMax),
      )
    }

    locations.add(location)

    // 添加据点周围的水体到可捕鱼范围
    final neighbors = getTileNeighbors(location.worldPosition.left, location.worldPosition.top)
    for (final neighbor in neighbors.values) {
      if (neighbor.kind in fisheryKinds) {
        world.fisheryIndexes.add(neighbor.index)
      }
    }
    locationNeighbors[location.terrainIndex] = neighbors.values
  }

  // 渔猎区域之前可能会重复添加，在这里去重
  world.fisheryIndexes = world.fisheryIndexes.toSet().toList()

  engine.debug('生成城市领地范围')
  generateCityTerritory(world)
  
  engine.debug('生成自然资源')
  for (final terrain in world.terrains) {
    if (terrain.kind in _kTerrainKindsWithNoResources) continue
    final resourceMultiplierData = Constants.terrainKindToNaturalResources[terrain.kind]
    assert(resourceMultiplierData != null, 'missing resourceMultiplierData for terrain kind: ${terrain.kind}')
    final resources = {}
    for (final resourceType in Constants.naturalResourceKinds) {
      assert(resourceMultiplierData.containsKey(resourceType), 'missing resourceMultiplier for resource type: ${resourceType} in terrain: ${terrain.index}')
      final resourceMultiplier = resourceMultiplierData[resourceType]
      resources[resourceType] = (random.nextInt(_kTerrainResourceVariation) + _kTerrainResourceBase) * resourceMultiplier
    }
    terrain.resources = resources
  }

  engine.debug('生成生产类建筑')
  // 生成农田
  final discoveredCities = game.locations.values.where((location) =>
    location.category == 'city' && location.isHidden == false
  ).toList()

  for (final city in discoveredCities) {
    final neighbors = locationNeighbors[city.terrainIndex]
    assert(neighbors != null)
    for (final terrain in neighbors) {
      if (terrain.locationId != null) continue
      if (terrain.kind != 'plain') continue
      final r = random.nextDouble()
      if (r < _kFarmFieldThreshold) {
        terrain.overlaySprite = {
          sprite: 'object/farmfield.png',
        }
        
        const location = Location(
          category: 'site',
          kind: 'farmland',
          atTerrain: terrain,
          updateWorldMap: false,
          npcId: 'servant',
          // 随机生成的场所，初始发展度是0-3之间随机。
          development: random.nextInt(_kLocationInitialDevelopmentMax),
        )
        terrain.locationId = location.id
      }
    }
  }

  // 生成渔场
  for (final index in world.fisheryIndexes) {
    const terrain = world.terrains[index]
    if (terrain.locationId != null) continue
    final r = random.nextDouble()
    if (r < _kFisheryThreshold) {
      terrain.overlaySprite = {
        sprite: 'object/fishery.png',
      }
      
      const location = Location(
        category: 'site',
        kind: 'fishery',
        atTerrain: terrain,
        updateWorldMap: false,
        npcId: 'servant',
        // 随机生成的场所，初始发展度是0-3之间随机。
        development: random.nextInt(_kLocationInitialDevelopmentMax),
      )
      terrain.locationId = location.id
    }
  }

  // 生成猎场和矿场
  for (final index in world.mountainIndexes) {
    const terrain = world.terrains[index]
    if (terrain.locationId != null) continue
    final r = random.nextDouble()
    if (r < _kHuntingGroundThreshold) {
      terrain.overlaySprite = {
        sprite: 'object/huntingground.png',
      }
      
      const location = Location(
        category: 'site',
        kind: 'huntingground',
        atTerrain: terrain,
        updateWorldMap: false,
        npcId: 'servant',
        // 随机生成的场所，初始发展度是0-3之间随机。
        development: random.nextInt(_kLocationInitialDevelopmentMax),
      )
      terrain.locationId = location.id
    } else if (r < _kMineThreshold) {
      terrain.overlaySprite = {
        sprite: 'object/mine.png',
      }
      
      const location = Location(
        category: 'site',
        kind: 'mine',
        atTerrain: terrain,
        updateWorldMap: false,
        npcId: 'servant',
        // 随机生成的场所，初始发展度是0-3之间随机。
        development: random.nextInt(_kLocationInitialDevelopmentMax),
      )
      terrain.locationId = location.id
    }
  }

  // 生成猎场和伐木场
  for (final index in forestIndexes) {
    const terrain = world.terrains[index]
    if (terrain.locationId != null) continue
    final r = random.nextDouble()
    if (r < _kHuntingGroundThreshold) {
      terrain.overlaySprite = {
        sprite: 'object/huntingground.png',
      }
      
      const location = Location(
        category: 'site',
        kind: 'huntingground',
        atTerrain: terrain,
        updateWorldMap: false,
        npcId: 'servant',
        // 随机生成的场所，初始发展度是0-3之间随机。
        development: random.nextInt(_kLocationInitialDevelopmentMax),
      )
      terrain.locationId = location.id
    } else if (r < _kTimberLandThreshold) {
      terrain.overlaySprite = {
        sprite: 'object/timberland.png',
      }
      
      const location = Location(
        category: 'site',
        kind: 'timberland',
        atTerrain: terrain,
        updateWorldMap: false,
        npcId: 'servant',
        // 随机生成的场所，初始发展度是0-3之间随机。
        development: random.nextInt(_kLocationInitialDevelopmentMax),
      )
      terrain.locationId = location.id
    }
  }

  // function find2NearestLocation(origin, {restricted2Zone: bool = true}) {
  //   assert(game.locations.length > 0)
  //   let nearest
  //   let nearestDistance
  //   let secondNearest
  //   let secondNearestDistance
  //   for (const location of game.locations) {
  //     if (location.category != 'city') continue
  //     if (location.terrainIndex == origin.terrainIndex) continue
  //     const start = world.terrains[origin.terrainIndex]
  //     const end = world.terrains[location.terrainIndex]
  //     const distance = getTileDistance(start, end)
  //     if (!restricted2Zone || location.zoneId == origin.zoneId) {
  //       if (nearestDistance == null || distance < nearestDistance) {
  //         nearestDistance = distance
  //         nearest = location
  //       } else if (secondNearestDistance == null || distance < secondNearestDistance) {
  //         secondNearestDistance = distance
  //         secondNearest = location
  //       } else {
  //         continue
  //       }
  //     }
  //   }
  //   return { nearest, secondNearest }
  // }

  // function resetRouteTerrainSprite(route) {
  //   final sub = route.sublist(1, route.length - 1)
  //   if (sub.isEmpty) return
  //   for (const index in sub) {
  //     const terrain = world.terrains[index]
  //     terrain.isRoute = true
  //     if (terrain.kind == 'mountain') {
  //       terrain.kind = 'plain'
  //       terrain.spriteIndex = kSpriteLand
  //       delete terrain.sprite
  //     }
  //   }
  // }

  // engine.debug('确保陆地上的每个城市至少可以链接到另外两个城市')
  // for (const location of game.locations) {
  //   if (location.category != 'city') continue
  //   const start = world.terrains[location.terrainIndex]
  //   // 确保陆地上的每个城市至少可以链接到另外两个城市
  //   const searchResult = find2NearestLocation(location, restricted2Zone: true)
  //   if (searchResult.nearest) {
  //     const end = world.terrains[searchResult.nearest.terrainIndex]
  //     const route = calculateRoute(start, end, world, terrainKinds: Constants.terrainKindsLand)
  //     if (route) {
  //       resetRouteTerrainSprite(route)
  //     }
  //   }
  //   if (searchResult.secondNearest) {
  //     const end = world.terrains[searchResult.secondNearest.terrainIndex]
  //     const route = calculateRoute(start, end, world, terrainKinds: Constants.terrainKindsLand)
  //     if (route) {
  //       resetRouteTerrainSprite(route)
  //     }
  //   }
  // }

  const nations = []
  // 随机挑选几个城市，作为各个国家的都城，生成地图上的不同国家
  engine.debug('随机挑选几个城市，作为各个国家的都城，生成地图上的不同国家')
  while (nations.length < nationNumber) {
    let availableLocations = game.locations.values.where((loc) => loc.category == 'city' && loc.organizationId == null).toList()
    assert(availableLocations.isNotEmpty)
    const location = random.nextIterable(availableLocations)
    const head = Character(
      birthTimestamp: createBirthTimestamp(min: 30, max: 60),
      rank: _kSandboxInitialRankMax,
    )
    head.locationId = location.id
    assert(location.worldPosition != null)
    head.worldPosition = Object.create(location.worldPosition)
    const organization = Organization(
      headquartersLocation: location,
      headId: head.id,
    )
    nations.add(organization)
    location.development += 1

    final siteKinds = Constants.siteKindsBuildable.toList()
    final organizationCategoryKind = Constants.organizationCategoryToSiteKind[organization.category]
    siteKinds.remove(organizationCategoryKind)
    Location(
      id: organization.id + '_${organizationCategoryKind}',
      name: engine.locale(organizationCategoryKind),
      category: 'site',
      kind: organizationCategoryKind,
      atLocation: location,
      organizationId: organization.id,
      development: random.nextInt(location.development + 1),
      npcId: 'servant',
    )
    
    final organizationGenreKinds = Constants.organizationGenreToSiteKinds[organization.genre]
    final secondaryClassSiteKind = random.nextIterable(organizationGenreKinds)
    siteKinds.remove(secondaryClassSiteKind)
    Location(
      id: organization.id + '_${secondaryClassSiteKind}',
      name: engine.locale(secondaryClassSiteKind),
      category: 'site',
      kind: secondaryClassSiteKind,
      atLocation: location,
      organizationId: organization.id,
      development: random.nextInt(location.development + 1),
      npcId: 'servant',
    )

    if (location.development >= 2) {
      for (var i in range(2, location.development + 1)) {
        final kind = random.nextIterable(siteKinds)
        siteKinds.remove(kind)
        Location(
          id: organization.id + '_${kind}',
          name: engine.locale(kind),
          category: 'site',
          kind: kind,
          atLocation: location,
          organizationId: organization.id,
          development: random.nextInt(location.development + 1),
          npcId: 'servant',
        )
      }
    }
  }

  final cities = game.locations.values.where((location) =>
    location.category == 'city' && location.isHidden == false
  ).toList()
  while (game.characters.length < characterNumber) {
    // 产生新的在野角色
    // 因为struct不能按照固定顺序排序，因此这里按照keys来随机。
    const location = random.nextIterable(cities)
    Character(
      locationId: location.id,
      birthTimestamp: createBirthTimestamp(min: 12, max: 60),
    )
  }

  // 模拟世界演化，按照时间推进并生成人物、组织，并且为期分配人物关系
  // 在此种演化算法中，人物不会死亡，组织不会被消灭，因此只判断人数是否达到要求
  // 因为是模拟运行，每个tick接跳过一个月
  engine.debug('快速模拟一段时间的演化，生成人物、组织、国家等信息')
  for (var i in range(5)) {
    // 国家和组织扩张
    for (const organization of game.organizations) {
      final expansionRate = Constants.organizationCategoryExpansionRate[organization.category]
      let roll = random.nextDouble()
      if (roll > expansionRate) continue
      final availableCities = game.locations.values.where((location) =>
        location.category == 'city' &&
        location.organizationId == null
      ).toList()
      if (availableCities.isEmpty) {
        // engine.warn('组织 ${organization.id} 没有可用的据点可以扩张了。')
        continue
      }
      engine.debug('组织 ${organization.name} 尝试扩张新领土')
      if (availableCities.length > 1) {
        // 按照距离组织据点的远近排序
        final headquarters = game.locations[organization.headquartersLocationId]
        final headquartersTile = world.terrains[headquarters.terrainIndex]

        availableCities.sort((a, b) {
          final distanceA = getTileDistance(headquartersTile, world.terrains[a.terrainIndex])
          final distanceB = getTileDistance(headquartersTile, world.terrains[b.terrainIndex])
          return distanceA.compareTo(distanceB)
        })
      }
      final newCity = availableCities.first
      addLocationToOrganization(newCity, organization)

      roll = random.nextDouble()
      if (roll > _kOrganizationRecruitProbability) continue
      final availableCharacters = game.characters.values.where((char) =>
        char.organizationId == null
      )
      if (availableCharacters.isEmpty) {
        // engine.warn('组织 ${organization.id} 没有可用的角色可以招募了。')
        continue
      }
      engine.debug('组织 ${organization.id} 尝试招募新成员')
      final character = random.shuffle(availableCharacters).first
      addCharacterToOrganization(character, organization)
    }
  }
  
  for (var i in range(characterNumber ~/ 4)) {
    engine.debug('通过婚姻和生育产生新的角色以及其人物关系')
    for (const char of game.characters) {
      if (!char.isFemale) continue
      const age = getCharacterAge(char)
      if (age < _kAdultAge || age > _kPregnancyAgeMax) continue
      if (char.isPregnant) continue
      if (char.motivations.contains('dink')) continue

      let spouseId = getSpouses(char).first?.characterId
      if (spouseId != null) {
        const spouse = game.characters[spouseId]
        if (spouse.motivations.contains('dink')) continue
        final childrenCount = hasChild(char)
        if (childrenCount >= _kChildrenMax) continue
        Baby(father: spouse, mother: char)
      } else {
        if (char.motivations.contains('celibate')) continue
        
        for (const otherChar of game.characters) {
          if (char.id == otherChar.id) continue
          if (otherChar.isFemale) continue
          if (getCharacterAge(otherChar) < _kAdultAge) continue
          if (hasSpouse(otherChar)) continue

          characterMet(char, otherChar)
          createSpouse(otherChar, char)
          break
        }
      }
    }
  }


  // 生成地牢
  engine.debug('在各个据点的领地上添加秘境')
  for (final city in cities) {
    final r = random.nextDouble()
    if (r > _kDungeonOnTerritoryProbability) continue

    let availableTiles = city.territoryIndexes.map((index) => world.terrains[index]).where((tile) => !tile.isWater && tile.locationId == null)
    if (availableTiles.isEmpty) continue

    final dungeionTile = random.nextIterable(availableTiles)
    dungeionTile.overlaySprite = {
      sprite: 'object/dungeon.png',
    }

    const location = Location(
      category: 'site',
      kind: 'dungeon',
      atTerrain: dungeionTile,
      updateWorldMap: false,
      organizationId: city.organizationId,
    )
    location.dungeonId = 'dungeon_1'
    dungeionTile.locationId = location.id
  }

  engine.debug('为角色添加次要动机')
  for (const char of game.characters) {
    const age = getCharacterAge(char)
    if (char.motivations.isNotEmpty) continue
    
    if (char.relationships.sect.isEmpty) {
      if (!char.motivations.contains('shifu')) {
        char.motivations.add('shifu')
        continue
      }
    }
    
    if (char.relationships.friendship.isEmpty) {
      if (!char.motivations.contains('friendship')) {
        char.motivations.add('friendship')
        continue
      }
    }
    
    if (char.relationships.romance.isEmpty) {
      if (!char.motivations.contains('romance')) {
        char.motivations.add('romance')
        continue
      }
    }
    
    if (!hasSpouse(char)) {
      if (age >= _kAdultAge && !char.motivations.contains('spouse')) {
        char.motivations.add('spouse')
        continue
      }
    }
    
    if (!hasChild(char)) {
      if (age >= _kAdultAge && !char.motivations.contains('child')) {
        char.motivations.add('child')
      }
    }
  }

  // 此时时间应为7日上午，这是为了避免重复触发月初事件
  Game.updateGame(tick: 0, force: true, updateEntity: true, updateUI: false, updateWorldMap: false)
  Game.updateGame(tick: Constants.ticksPerDay * 6, updateEntity: false, updateUI: false, updateWorldMap: false)

  // engine.debug('世界生成完毕。重置随机数生成器。')
  // setRandomSeed()

  for (final tile in world.terrains) {
    updateTerritoryBorders(tile)
  }

  delete world.landIndexes
  delete world.waterIndexes
  delete world.mountainIndexes
  delete world.seaIndexes
  delete world.fisheryIndexes

  return world
}
