import 'generation_algorithm.ht'
import 'zone.ht'

const _kForestThreshold = 0.6

const _kMirageThreshold = 0.15
const _kArcanaThreshold = 0.3

const _kFarmLandThreshold = 0.15
const _kFisheryThreshold = 0.075
const _kTimberLandThreshold = 0.1
const _kHuntingGroundThreshold = 0.075
const _kMineThreshold = 0.035

const _kDungeonOnTerritoryProbability = 0.265

const _kAdultAge = 15
const _kPregnancyAgeMax = 50
const _kChildrenMax = 3

const _kLocationInitialDevelopmentMax = 4

const _kSectRecruitProbability = 0.4

const _kSandboxInitialRankMax = 3

const _kTerrainResourceBase = 5;
const _kTerrainResourceVariation = 5;
const _kTerrainKindsWithNoResources = ['void', 'city', 'road']

const _kCityHasExtraBuildingProbability = 0.4

/// 生成世界地图的算法
/// 生成的世界 ID 固定为 `sandboxWorld`
///
/// spritesheet上不同地形对应的编号：
/// 0：虚空
/// 1：浅海
/// 2：深海
/// 3：陆地（草原）
///
/// 算法思路：
///
/// 用噪声算法生成陆地和海洋
///
/// 为陆地所属的整个大地块命名，然后找到尚未命名的地块，将所有相连的地块作为一个整体命名，直到所有的地块都有名字，根据地块大小有不同命名方式
///
/// 根据城市密度，生成城市，并根据城市位于陆地、海边还是海中，对其进行特殊命名
///
/// 对于每个城市，链接最近的另外两个城市，使用 A* 寻路算法，标记经过的地块
///
/// 对于没有道路经过的地块，随机填充山脉和树林

function createSandboxWorld({
    name,
    seed,
    style = 'coast',
    terrainSpriteSheet = 'tilemap/fantasyhextiles_v3_borderless.png',
    width,
    height,
    nationNumber,
    locationNumber,
    characterNumber,
  }) {
  
  assert(seed is int)
  assert(width != null && height != null)
  assert(nationNumber != null)
  assert(locationNumber != null)
  assert(characterNumber != null)
  assert(locationNumber > nationNumber)
  
  engine.info('--------开始生成世界--------')
  engine.info('随机种子：${seed}, 地图大小：[${width},${height}]，地图风格：${style}，国家数量：${nationNumber}，城市数量：${locationNumber}，角色数量：${characterNumber}, 门派数量：${nationNumber}')

  // 生成过程中，引入了一些别的文件中的函数
  // 他们可能会通过game.world访问, 因此这里直接使用全局变量
  const newWorld = TileMap(
    id: 'sandboxWorld',
    terrainSpriteSheet: terrainSpriteSheet,
    width: width,
    height: height,
  )

  newWorld.isMain = true
  newWorld.name = name ?? generateZoneName(category: 'world')
  
  addWorld(newWorld)

  engine.info('生成地块')
  for (const y in range(height)) {
    for (const x in range(width)) {
      let spriteIndex
      if (y > 0 && y < height - 1 && x > 0 && x < width - 1) {
        // 边界地块为 void
        spriteIndex = kSpriteWater
      }
      world.terrains.add(
        TileMapTerrain(
          left: x + 1,
          top: y + 1,
          mapWidth: width,
          spriteIndex: spriteIndex,
        )
      )
    }
  }
  generateContinent2(newWorld, seed: game.seed, style: style)

  engine.info('划分大陆和海洋')
  generateZone(newWorld)
  
  const plainIndexes = Set()
  const forestIndexes = Set()
  
  // 地形装饰贴图
  // 将大陆和海洋接触的地方填充为大陆架，将大陆上没有道路的方格，随机填充为森林
  // 这些修改不影响该地块的 kind
  engine.info('填充装饰地形：大陆架、森林')
  const lands = world.landIndexes.map((index) => world.terrains[index])
  for (const tile in lands) {
    let isShore = false
    const neighbors = getTileNeighbors(tile.left, tile.top)
    for (const neighbor in neighbors.values) {
      if (neighbor.spriteIndex == kSpriteWater) {
        isShore = true
        break
      }
    }
    if (isShore) {
      tile.kind = 'shore'
      tile.sprite = 'object/shore.png'
    } else {
      // 不是海岸线的陆地，随机生成森林
      const r = random.nextDouble()
      if (r < _kForestThreshold) {
        tile.kind = 'forest'
        tile.sprite = 'object/forest.png'
        forestIndexes.add(tile.index)
      } else {
        tile.kind = 'plain'
        plainIndexes.add(tile.index)
      }
    }
  }

  // zone 的名字和其大小有关
  // 命名区域后，才会得到海洋地块，因为某些水体会被命名为湖泊和河流
  engine.info('命名海洋和大陆')
  nameZones(newWorld)

  // 生成大陆架，在这一步会将大陆架从 seaIndexes 中剔除
  engine.info('生成大陆架')
  const waters = world.waterIndexes.map((index) => world.terrains[index])
  for (const tile in waters) {
    let isShelf = false
    const neighbors = getTileNeighbors(tile.left, tile.top)
    for (const neighbor in neighbors.values) {
      if (neighbor.spriteIndex == kSpriteLand) {
        isShelf = true
        break
      }
    }
    if (isShelf) {
      tile.sprite = 'object/shelf.png'
      tile.kind = 'shelf'
      world.fisheryIndexes.add(tile.index)
      world.seaIndexes.remove(tile.index)
    }
  }

  // 生成城市
  // 有四种：城市、港口、山地（洞天）和岛屿（福地），后两者为隐藏城市
  engine.info('生成城市')
  final locations = []
  final locationNeighbors = {}
  const fisheryKinds = ['lake', 'shelf', 'sea']
  const seas = world.seaIndexes.map((index) => world.terrains[index])
  const mountains = world.mountainIndexes.map((index) => world.terrains[index])
  while (locations.length < locationNumber) {
    final typeroll = random.nextDouble()
    let terrain
    let location
    let generated = false
    if (typeroll < _kMirageThreshold) {
      let availableWater = seas.where((tile) => tile.locationId == null)
      if (availableWater.isNotEmpty) {
        generated = true
        terrain = random.nextIterable(availableWater)
        location = Location(
          category: 'city',
          kind: 'island',
          atTerrain: terrain,
          updateWorldMap: false,
          isHidden: true,
          // 随机生成的城市，初始规模是0-3之间随机。
          development: random.nextInt(_kLocationInitialDevelopmentMax),
          tradinghouseDevelopment: random.nextInt(_kLocationInitialDevelopmentMax),
        )
      }
    } else if (typeroll < _kArcanaThreshold) {
      let availableMountain = mountains.where((tile) => tile.locationId == null)
      if (availableMountain.isNotEmpty) {
        generated = true
        terrain = random.nextIterable(availableMountain)
        location = Location(
          category: 'city',
          kind: 'mountain',
          atTerrain: terrain,
          updateWorldMap: false,
          isHidden: true,
          // 随机生成的城市，初始规模是0-3之间随机。
          development: random.nextInt(_kLocationInitialDevelopmentMax),
          tradinghouseDevelopment: random.nextInt(_kLocationInitialDevelopmentMax),
        )
      }
    }

    if (!generated) {
      let availableLands = lands.where((tile) => tile.locationId == null)
      if (availableLands.isEmpty) {
        // 没有可用的地块了，跳出循环
        break
      }
      terrain = random.nextIterable(availableLands)
      location = Location(
        category: 'city',
        kind: terrain.kind == 'shore' ? 'harbor' : 'inland',
        atTerrain: terrain,
        updateWorldMap: false,
        isHidden: false,
        // 随机生成的城市，初始规模是0-3之间随机。
        development: random.nextInt(_kLocationInitialDevelopmentMax),
        tradinghouseDevelopment: random.nextInt(_kLocationInitialDevelopmentMax),
      )
    }

    locations.add(location)

    // 添加城市周围的水体到可捕鱼范围
    final neighbors = getTileNeighbors(location.worldPosition.left, location.worldPosition.top)
    for (final neighbor in neighbors.values) {
      if (neighbor.kind in fisheryKinds) {
        world.fisheryIndexes.add(neighbor.index)
      }
    }
    locationNeighbors[location.terrainIndex] = neighbors.values
  }
  // 渔猎区域之前可能会重复添加，在这里去重
  world.fisheryIndexes = world.fisheryIndexes.toSet().toList()

  engine.info('计算城市领地范围')
  generateCityTerritory(world)
  
  engine.info('生成自然资源')
  for (final terrain in world.terrains) {
    if (terrain.kind in _kTerrainKindsWithNoResources) continue
    final resourceMultiplierData = Constants.terrainKindToNaturalResources[terrain.kind]
    assert(resourceMultiplierData != null, 'missing resourceMultiplierData for terrain kind: ${terrain.kind}')
    final resources = {}
    for (final resourceType in Constants.naturalResourceKinds) {
      assert(resourceMultiplierData.containsKey(resourceType), 'missing resourceMultiplier for resource type: ${resourceType} in terrain: ${terrain.index}')
      final resourceMultiplier = resourceMultiplierData[resourceType]
      resources[resourceType] = (random.nextInt(_kTerrainResourceVariation) + _kTerrainResourceBase) * resourceMultiplier
    }
    terrain.resources = resources
  }

  engine.info('生成生产类建筑：农场、林场、渔场、猎场、矿场')
  final discoveredCities = game.locations.values.where((loc) =>
    loc.category == 'city' && loc.isHidden == false
  ).toList()

  function addProductionSite(kind, terrain, city) {
    assert(Constants.productionSiteKinds.contains(kind))
    terrain.overlaySprite = {
      sprite: 'object/${kind}.png',
    }
    const location = Location(
      category: 'site',
      kind: kind,
      atTerrain: terrain,
      atCity: city,
      updateWorldMap: false,
      // 随机生成的场所，初始规模是0-3之间随机。
      development: random.nextInt(_kLocationInitialDevelopmentMax),
      npcId: Constants.siteKindToNpcId[kind],
    )
    terrain.locationId = location.id
  }

  // 生成农田
  for (final city in discoveredCities) {
    final neighbors = locationNeighbors[city.terrainIndex]
    assert(neighbors != null)
    let hasFishery = false
    let hasMine = false
    let hasHuntingGround = false
    let hasTimberLand = false
    let hasFarmLand = false
    for (final terrain in neighbors) {
      if (terrain.locationId != null) continue
      if (terrain.kind != 'plain' && terrain.kind != 'forest') continue
      final r = random.nextDouble()
      if (r < _kFarmLandThreshold) {
        addProductionSite('farmland', terrain, city)
        hasFarmLand = true
        break; // 每个城市周围只生成一个农田
      }
    }

    for (final terrainIndex in city.territoryIndexes) {
      const terrain = world.terrains[terrainIndex]
      if (terrain.locationId != null) continue
      if (!hasFishery && world.fisheryIndexes.contains(terrain.index)) {
        // 生成渔场
        final r = random.nextDouble()
        if (r < _kFisheryThreshold) {
          addProductionSite('fishery', terrain, city)
          hasFishery = true
        }
      } else if ((!hasMine || !hasHuntingGround) && world.mountainIndexes.contains(terrain.index)) {
        // 生成矿场和猎场
        final r = random.nextDouble()
        if (!hasMine && r < _kMineThreshold) {
          addProductionSite('mine', terrain, city)
          hasMine = true
        } else if (!hasHuntingGround && r < _kHuntingGroundThreshold) {
          addProductionSite('huntingground', terrain, city)
          hasHuntingGround = true
        }
      } else if ((!hasMine || !hasHuntingGround || !hasTimberLand) && forestIndexes.contains(terrain.index)) {
        // 生成林场、矿场、猎场
        final r = random.nextDouble()
        if (!hasMine && r < _kMineThreshold) {
          addProductionSite('mine', terrain, city)
          hasMine = true
        } else if (!hasHuntingGround && r < _kHuntingGroundThreshold) {
          addProductionSite('huntingground', terrain, city)
          hasHuntingGround = true
        } else if (!hasTimberLand && r < _kTimberLandThreshold) {
          engine.warn('adding timberland')
          addProductionSite('timberland', terrain, city)
          hasTimberLand = true
        }
      }

      if (hasFishery && hasMine && hasHuntingGround && hasTimberLand && hasFarmLand) {
        break
      }
    }
  }

  // function find2NearestLocation(origin, {restricted2Zone: bool = true}) {
  //   assert(game.locations.length > 0)
  //   let nearest
  //   let nearestDistance
  //   let secondNearest
  //   let secondNearestDistance
  //   for (const location of game.locations) {
  //     if (location.category != 'city') continue
  //     if (location.terrainIndex == origin.terrainIndex) continue
  //     const start = world.terrains[origin.terrainIndex]
  //     const end = world.terrains[location.terrainIndex]
  //     const distance = getTileDistance(start, end)
  //     if (!restricted2Zone || location.zoneId == origin.zoneId) {
  //       if (nearestDistance == null || distance < nearestDistance) {
  //         nearestDistance = distance
  //         nearest = location
  //       } else if (secondNearestDistance == null || distance < secondNearestDistance) {
  //         secondNearestDistance = distance
  //         secondNearest = location
  //       } else {
  //         continue
  //       }
  //     }
  //   }
  //   return { nearest, secondNearest }
  // }

  // function resetRouteTerrainSprite(route) {
  //   final sub = route.sublist(1, route.length - 1)
  //   if (sub.isEmpty) return
  //   for (const index in sub) {
  //     const terrain = world.terrains[index]
  //     terrain.isRoute = true
  //     if (terrain.kind == 'mountain') {
  //       terrain.kind = 'plain'
  //       terrain.spriteIndex = kSpriteLand
  //       delete terrain.sprite
  //     }
  //   }
  // }

  // engine.debug('确保陆地上的每个城市至少可以链接到另外两个城市')
  // for (const location of game.locations) {
  //   if (location.category != 'city') continue
  //   const start = world.terrains[location.terrainIndex]
  //   // 确保陆地上的每个城市至少可以链接到另外两个城市
  //   const searchResult = find2NearestLocation(location, restricted2Zone: true)
  //   if (searchResult.nearest) {
  //     const end = world.terrains[searchResult.nearest.terrainIndex]
  //     const route = calculateRoute(start, end, world, terrainKinds: Constants.terrainKindsLand)
  //     if (route) {
  //       resetRouteTerrainSprite(route)
  //     }
  //   }
  //   if (searchResult.secondNearest) {
  //     const end = world.terrains[searchResult.secondNearest.terrainIndex]
  //     const route = calculateRoute(start, end, world, terrainKinds: Constants.terrainKindsLand)
  //     if (route) {
  //       resetRouteTerrainSprite(route)
  //     }
  //   }
  // }

  const nations = []
  // 随机挑选几个城市，作为各个国家的都城，生成地图上的不同国家
  engine.info('随机挑选几个城市作为都城，并生成国家')
  let capitals = Set()
  while (nations.length < nationNumber) {
    let availableCities = game.locations.values
      .where((loc) => loc.category == 'city' && loc.sectId == null)
      .toList()
    availableCities.sort((a, b) => b.development.compareTo(a.development))
    assert(availableCities.isNotEmpty)
    const city = availableCities.first
    const head = Character(
      birthTimestamp: createBirthTimestamp(min: 30, max: 60),
      rank: _kSandboxInitialRankMax,
    )
    head.locationId = city.id
    assert(city.worldPosition != null)
    head.worldPosition = Object.create(city.worldPosition)
    const sect = Sect(
      headquarters: city,
      headId: head.id,
    )
    nations.add(sect)

    capitals.add(city)

    final siteKinds = Constants.siteKindsBuildable.toList()

    final sectCategoryKind = Constants.sectCategoryToSiteKind[sect.category]
    siteKinds.remove(sectCategoryKind)
    Location(
      category: 'site',
      kind: sectCategoryKind,
      atCity: city,
      sectId: sect.id,
      development: random.nextInt(city.development + 1),
      npcId: Constants.siteKindToNpcId[sectCategoryKind],
    )
    
    final sectGenreKinds = Constants.sectGenreToSiteKinds[sect.genre]
    final secondaryClassSiteKind = random.nextIterable(sectGenreKinds)
    siteKinds.remove(secondaryClassSiteKind)
    Location(
      category: 'site',
      kind: secondaryClassSiteKind,
      atCity: city,
      sectId: sect.id,
      development: random.nextInt(city.development + 1),
      npcId: Constants.siteKindToNpcId[secondaryClassSiteKind],
    )

    if (city.siteIds.length < city.maxSiteCount) {
      for (var i in range(city.siteIds.length, city.maxSiteCount)) {
        final roll = random.nextDouble()
        if (roll > _kCityHasExtraBuildingProbability) continue

        final kind = random.nextIterable(siteKinds)
        Location(
          category: 'site',
          kind: kind,
          atCity: city,
          sectId: sect.id,
          development: random.nextInt(city.development + 1),
          npcId: Constants.siteKindToNpcId[kind],
        )
        siteKinds.remove(kind)
        if (siteKinds.isEmpty) break
      }
    }
  }

  let nonCapitalCities = game.locations.values
    .where((loc) => 
      loc.category == 'city'
      && !capitals.contains(loc)
    )
    .toList()
  for (final city in nonCapitalCities) {
    final siteKinds = Constants.siteKindsBuildable.toList()
    // 这里 + 2 是因为非首都城市默认会拥有会堂和交易所两个建筑
    if (city.siteIds.length < city.maxSiteCount) {
      for (var i in range(city.siteIds.length, city.maxSiteCount)) {
        final roll = random.nextDouble()
        if (roll > _kCityHasExtraBuildingProbability) continue
        
        final kind = random.nextIterable(siteKinds)
        Location(
          category: 'site',
          kind: kind,
          atCity: city,
          sectId: city.sectId,
          development: random.nextInt(city.development + 1),
          npcId: Constants.siteKindToNpcId[kind],
        )
        siteKinds.remove(kind)
        if (siteKinds.isEmpty) break
      }
    }
  }

  engine.info('生成初始角色')
  final cities = game.locations.values.where((loc) =>
    loc.category == 'city' && loc.isHidden == false
  ).toList()
  while (game.characters.length < characterNumber) {
    // 因为struct不能按照固定顺序排序，因此这里按照keys来随机。
    const city = random.nextIterable(cities)
    Character(
      homeLocationId: city.id,
      rank: random.distantInt(_kSandboxInitialRankMax + 1),
      birthTimestamp: createBirthTimestamp(min: 12, max: 60),
    )
  }

  // 模拟世界演化，按照时间推进并生成人物、组织，并且为期分配人物关系
  // 在此种演化算法中，人物不会死亡，组织不会被消灭，因此只判断人数是否达到要求
  // 因为是模拟运行，每个tick接跳过一个月
  engine.info('扩张门派的成员和领地')
  for (var i in range(5)) {
    // 国家和组织扩张
    for (const sect of game.sects) {
      final occupiedCities = sect.locationIds.map((id) => game.locations[id])
        .where((loc) => loc.category == 'city')
        .toList()
      if (occupiedCities.length >= sect.maxCityCount) continue

      final expansionRate = Constants.sectCategoryExpansionRate[sect.category]
      let roll = random.nextDouble()
      if (roll > expansionRate) continue
      final availableCities = game.locations.values.where((location) =>
        location.category == 'city' &&
        location.sectId == null
      ).toList()
      if (availableCities.isEmpty) {
        // engine.warn('组织 ${sect.id} 没有可用的城市可以扩张了。')
        continue
      }
      // engine.debug('组织 ${sect.name} 尝试扩张新领土')
      if (availableCities.length > 1) {
        // 按照距离组织城市的远近排序
        final headquarters = game.locations[sect.headquartersLocationId]
        final headquartersTile = world.terrains[headquarters.terrainIndex]

        availableCities.sort((a, b) {
          final distanceA = getTileDistance(headquartersTile, world.terrains[a.terrainIndex])
          final distanceB = getTileDistance(headquartersTile, world.terrains[b.terrainIndex])
          return distanceA.compareTo(distanceB)
        })
      }
      final newCity = availableCities.first
      addLocationToSect(newCity, sect)
    }
  }
  for (var i in range(10)) {
    for (const sect of game.sects) {
      let roll = random.nextDouble()
      if (roll > _kSectRecruitProbability) continue
      final availableCharacters = game.characters.values.where((char) =>
        char.sectId == null
      )
      if (availableCharacters.isEmpty) {
        // engine.warn('组织 ${sect.id} 没有可用的角色可以招募了。')
        continue
      }
      // engine.debug('组织 ${sect.id} 尝试招募新成员')
      final character = random.shuffle(availableCharacters).first
      addCharacterToSect(character, sect)
    }
  }
  
  engine.info('处理婚姻和生育')
  for (var i in range(characterNumber ~/ 4)) {
    for (const char of game.characters) {
      if (!char.isFemale) continue
      const age = getCharacterAge(char)
      if (age < _kAdultAge || age > _kPregnancyAgeMax) continue
      if (char.isPregnant) continue
      if (char.motivations.contains('dink')) continue

      let spouseId = char.familyRelationships.spouseIds.last
      if (spouseId != null) {
        const spouse = game.characters[spouseId]
        if (spouse.motivations.contains('dink')) continue
        final childrenCount = char.familyRelationships.childIds.length
        if (childrenCount >= _kChildrenMax) continue
        Baby(father: spouse, mother: char)
      } else {
        if (char.motivations.contains('celibate')) continue
        
        for (const otherChar of game.characters) {
          if (char.id == otherChar.id) continue
          if (otherChar.titleId == 'head') continue
          if (otherChar.isFemale) continue
          if (getCharacterAge(otherChar) < _kAdultAge) continue
          if (otherChar.familyRelationships.spouseIds.isNotEmpty) continue

          createSpouseRelationships(char, otherChar)
          break
        }
      }
    }
  }

  // 生成地牢
  engine.info('添加秘境')
  for (final city in cities) {
    final r = random.nextDouble()
    if (r > _kDungeonOnTerritoryProbability) continue

    let availableTiles = city.territoryIndexes
      .map((index) => world.terrains[index])
      .where((tile) => !tile.isWater && tile.locationId == null)
    if (availableTiles.isEmpty) continue

    final dungeionTile = random.nextIterable(availableTiles)
    dungeionTile.overlaySprite = {
      sprite: 'object/dungeon.png',
    }

    const location = Location(
      category: 'site',
      kind: 'dungeon',
      atTerrain: dungeionTile,
      atCity: city, 
      updateWorldMap: false,
      sectId: city.sectId,
      npcId: Constants.siteKindToNpcId['dungeon'],
      development: random.nextInt(_kLocationInitialDevelopmentMax),
    )
    location.dungeonId = 'dungeon_1'
    dungeionTile.locationId = location.id
  }

  // engine.info('为角色添加次要动机')
  // for (const char of game.characters) {
  //   const age = getCharacterAge(char)
  //   if (char.motivations.isNotEmpty) continue
    
  //   if (char.shituRelationships.shifuIds.isEmpty) {
  //     if (!char.motivations.contains('shifu')) {
  //       char.motivations.add('shifu')
  //       continue
  //     }
  //   }
  //   if (char.familyRelationships.spouseIds.isEmpty) {
  //     if (age >= _kAdultAge && !char.motivations.contains('spouse')) {
  //       char.motivations.add('spouse')
  //       continue
  //     }
  //   }
  //   if (char.romanceIds.isEmpty) {
  //     if (!char.motivations.contains('romance')) {
  //       char.motivations.add('romance')
  //       continue
  //     }
  //   }
  //   if (char.friendIds.isEmpty) {
  //     if (!char.motivations.contains('friendship')) {
  //       char.motivations.add('friendship')
  //       continue
  //     }
  //   }
  // }

  engine.info('--------世界生成完毕，清理临时数据--------')

  Game.updateGame(tick: 0, force: true, updateUI: false, updateWorldMap: false)
  
  // setRandomSeed()

  for (final tile in world.terrains) {
    updateTerritoryBorders(tile)
  }

  // clean up
  delete world.landIndexes
  delete world.waterIndexes
  delete world.mountainIndexes
  delete world.seaIndexes
  delete world.fisheryIndexes

  return world
}
