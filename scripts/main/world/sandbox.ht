import 'tile/common.ht'
import 'generation_algorithm.ht'
import 'zone.ht'

const _kForestThreshold = 0.6

const _kMirageThreshold = 0.15
const _kArcanaThreshold = 0.3

const _kFarmLandThreshold = 0.1
const _kFisheryThreshold = 0.03

const _kTimberLandThreshold = 0.075
const _kHuntingGroundThreshold = 0.04
const _kMineThreshold = 0.02

const _kDungeonOnTerritoryProbability = 0.265

const _kAdultAge = 15
const _kPregnancyAgeMax = 50
const _kChildrenMax = 3

const _kLocationInitialDevelopmentMax = 4

const _kOrganizationRecruitProbability = 0.4

const _kSandboxInitialRankMax = 3

const _kTerrainResourceBase = 5;
const _kTerrainResourceVariation = 5;
const _kTerrainKindsWithNoResources = ['void', 'city', 'road']

const _kCityHasExtraBuildingProbability = 0.4

/// 生成世界地图的算法
/// 生成的世界 ID 固定为 `sandboxWorld`
///
/// spritesheet上不同地形对应的编号：
/// 0：虚空
/// 1：浅海
/// 2：深海
/// 3：陆地（草原）
///
/// 算法思路：
///
/// 用噪声算法生成陆地和海洋
///
/// 为陆地所属的整个大地块命名，然后找到尚未命名的地块，将所有相连的地块作为一个整体命名，直到所有的地块都有名字，根据地块大小有不同命名方式
///
/// 根据城市密度，生成城市，并根据城市位于陆地、海边还是海中，对其进行特殊命名
///
/// 对于每个城市，链接最近的另外两个城市，使用 A* 寻路算法，标记经过的地块
///
/// 对于没有道路经过的地块，随机填充山脉和树林

function createSandboxWorld({
    name,
    seed,
    style = 'coast',
    terrainSpriteSheet = 'tilemap/fantasyhextiles_v3_borderless.png',
    width,
    height,
    nationNumber,
    locationNumber,
    characterNumber,
  }) {
  
  assert(seed is int)
  assert(width != null && height != null)
  assert(nationNumber != null)
  assert(locationNumber != null)
  assert(characterNumber != null)
  assert(locationNumber > nationNumber)
  
  engine.info('--------开始生成世界--------')
  engine.info('随机种子：${seed}, 地图大小：[${width}, ${height}]，地图风格：${style}，国家数量：${nationNumber}，据点数量：${locationNumber}，角色数量：${characterNumber}, 门派数量：${nationNumber}')

  // 生成过程中，引入了一些别的文件中的函数
  // 他们可能会通过game.world访问, 因此这里直接使用全局变量
  const newWorld = TileMap(
    id: 'sandboxWorld',
    terrainSpriteSheet: terrainSpriteSheet,
    width: width,
    height: height,
  )

  newWorld.isMain = true
  newWorld.name = name ?? generateZoneName(category: 'world')
  
  addWorld(newWorld)

  engine.info('生成地块')
  for (const y in range(height)) {
    for (const x in range(width)) {
      let spriteIndex
      if (y > 0 && y < height - 1 && x > 0 && x < width - 1) {
        // 边界地块为 void
        spriteIndex = kSpriteWater
      }
      world.terrains.add(
        TileMapTerrain(
          left: x + 1,
          top: y + 1,
          mapWidth: width,
          spriteIndex: spriteIndex,
        )
      )
    }
  }
  generateContinent2(newWorld, seed: game.seed, style: style)

  engine.info('划分大陆和海洋')
  generateZone(newWorld)
  
  const plainIndexes = Set()
  const forestIndexes = Set()
  
  // 地形装饰贴图
  // 将大陆和海洋接触的地方填充为大陆架，将大陆上没有道路的方格，随机填充为森林
  // 这些修改不影响该地块的 kind
  engine.info('填充装饰地形：大陆架、森林')
  const lands = world.landIndexes.map((index) => world.terrains[index])
  for (const tile in lands) {
    let isShore = false
    const neighbors = getTileNeighbors(tile.left, tile.top)
    for (const neighbor in neighbors.values) {
      if (neighbor.spriteIndex == kSpriteWater) {
        isShore = true
        break
      }
    }
    if (isShore) {
      tile.kind = 'shore'
      tile.sprite = 'object/shore.png'
    } else {
      // 不是海岸线的陆地，随机生成森林
      const r = random.nextDouble()
      if (r < _kForestThreshold) {
        tile.kind = 'forest'
        tile.sprite = 'object/forest.png'
        forestIndexes.add(tile.index)
      } else {
        tile.kind = 'plain'
        plainIndexes.add(tile.index)
      }
    }
  }

  // zone 的名字和其大小有关
  // 命名区域后，才会得到海洋地块，因为某些水体会被命名为湖泊和河流
  engine.info('命名海洋和大陆')
  nameZones(newWorld)

  // 生成大陆架，在这一步会将大陆架从 seaIndexes 中剔除
  engine.info('生成大陆架')
  const waters = world.waterIndexes.map((index) => world.terrains[index])
  for (const tile in waters) {
    let isShelf = false
    const neighbors = getTileNeighbors(tile.left, tile.top)
    for (const neighbor in neighbors.values) {
      if (neighbor.spriteIndex == kSpriteLand) {
        isShelf = true
        break
      }
    }
    if (isShelf) {
      tile.sprite = 'object/shelf.png'
      tile.kind = 'shelf'
      world.fisheryIndexes.add(tile.index)
      world.seaIndexes.remove(tile.index)
    }
  }

  // 生成据点
  // 有四种：城市、港口、山地（洞天）和岛屿（福地），后两者为隐藏据点
  engine.info('生成城市')
  final locations = []
  final locationNeighbors = {}
  const fisheryKinds = ['lake', 'shelf', 'sea']
  const seas = world.seaIndexes.map((index) => world.terrains[index])
  const mountains = world.mountainIndexes.map((index) => world.terrains[index])
  while (locations.length < locationNumber) {
    final typeroll = random.nextDouble()
    let terrain
    let location
    let generated = false
    if (typeroll < _kMirageThreshold) {
      let availableWater = seas.where((tile) => tile.locationId == null)
      if (availableWater.isNotEmpty) {
        generated = true
        terrain = random.nextIterable(availableWater)
        location = Location(
          category: 'city',
          kind: 'island',
          atTerrain: terrain,
          updateWorldMap: false,
          isHidden: true,
          // 随机生成的据点，初始发展度是0-3之间随机。
          development: random.nextInt(_kLocationInitialDevelopmentMax),
        )
      }
    } else if (typeroll < _kArcanaThreshold) {
      let availableMountain = mountains.where((tile) => tile.locationId == null)
      if (availableMountain.isNotEmpty) {
        generated = true
        terrain = random.nextIterable(availableMountain)
        location = Location(
          category: 'city',
          kind: 'mountain',
          atTerrain: terrain,
          updateWorldMap: false,
          isHidden: true,
          // 随机生成的据点，初始发展度是0-3之间随机。
          development: random.nextInt(_kLocationInitialDevelopmentMax),
        )
      }
    }

    if (!generated) {
      let availableLands = lands.where((tile) => tile.locationId == null)
      if (availableLands.isEmpty) {
        // 没有可用的地块了，跳出循环
        break
      }
      terrain = random.nextIterable(availableLands)
      location = Location(
        category: 'city',
        kind: terrain.kind == 'shore' ? 'harbor' : 'inland',
        atTerrain: terrain,
        updateWorldMap: false,
        isHidden: false,
        // 随机生成的据点，初始发展度是0-3之间随机。
        development: random.nextInt(_kLocationInitialDevelopmentMax),
      )
    }

    locations.add(location)

    // 添加据点周围的水体到可捕鱼范围
    final neighbors = getTileNeighbors(location.worldPosition.left, location.worldPosition.top)
    for (final neighbor in neighbors.values) {
      if (neighbor.kind in fisheryKinds) {
        world.fisheryIndexes.add(neighbor.index)
      }
    }
    locationNeighbors[location.terrainIndex] = neighbors.values
  }
  // 渔猎区域之前可能会重复添加，在这里去重
  world.fisheryIndexes = world.fisheryIndexes.toSet().toList()

  engine.info('计算城市领地范围')
  generateCityTerritory(world)
  
  engine.info('生成自然资源')
  for (final terrain in world.terrains) {
    if (terrain.kind in _kTerrainKindsWithNoResources) continue
    final resourceMultiplierData = Constants.terrainKindToNaturalResources[terrain.kind]
    assert(resourceMultiplierData != null, 'missing resourceMultiplierData for terrain kind: ${terrain.kind}')
    final resources = {}
    for (final resourceType in Constants.naturalResourceKinds) {
      assert(resourceMultiplierData.containsKey(resourceType), 'missing resourceMultiplier for resource type: ${resourceType} in terrain: ${terrain.index}')
      final resourceMultiplier = resourceMultiplierData[resourceType]
      resources[resourceType] = (random.nextInt(_kTerrainResourceVariation) + _kTerrainResourceBase) * resourceMultiplier
    }
    terrain.resources = resources
  }

  engine.info('生成生产类建筑：农场、林场、渔场、猎场、矿场')
  final discoveredCities = game.locations.values.where((loc) =>
    loc.category == 'city' && loc.isHidden == false
  ).toList()

  function addProductionSite(kind, terrain) {
    assert(Constants.productionSiteKinds.contains(kind))
    terrain.overlaySprite = {
      sprite: 'object/${kind}.png',
    }
    const location = Location(
      category: 'site',
      kind: kind,
      atTerrain: terrain,
      updateWorldMap: false,
      // 随机生成的场所，初始发展度是0-3之间随机。
      development: random.nextInt(_kLocationInitialDevelopmentMax),
      npcId: Constants.siteKindToNpcId[kind],
    )
    terrain.locationId = location.id
  }

  // 生成农田
  for (final city in discoveredCities) {
    final neighbors = locationNeighbors[city.terrainIndex]
    assert(neighbors != null)
    for (final terrain in neighbors) {
      if (terrain.locationId != null) continue
      if (terrain.kind != 'plain' && terrain.kind != 'forest') continue
      final r = random.nextDouble()
      if (r < _kFarmLandThreshold) {
        addProductionSite('farmland', terrain)
      }
    }
  }

  // 生成渔场
  for (final index in world.fisheryIndexes) {
    const terrain = world.terrains[index]
    if (terrain.locationId != null) continue
    final r = random.nextDouble()
    if (r < _kFisheryThreshold) {
      addProductionSite('fishery', terrain)
    }
  }

  // 生成猎场和矿场
  for (final index in world.mountainIndexes) {
    const terrain = world.terrains[index]
    if (terrain.locationId != null) continue
    final r = random.nextDouble()
    if (r < _kMineThreshold) {
      addProductionSite('mine', terrain)
    } else if (r < _kHuntingGroundThreshold) {
      addProductionSite('huntingground', terrain)
    }
  }

  // 生成林场、矿场、猎场
  for (final index in forestIndexes) {
    const terrain = world.terrains[index]
    if (terrain.locationId != null) continue
    final r = random.nextDouble()
    if (r < _kMineThreshold) {
      addProductionSite('mine', terrain)
    } else if (r < _kHuntingGroundThreshold) {
      addProductionSite('huntingground', terrain)
    } else if (r < _kTimberLandThreshold) {
      addProductionSite('timberland', terrain)
    }
  }

  // function find2NearestLocation(origin, {restricted2Zone: bool = true}) {
  //   assert(game.locations.length > 0)
  //   let nearest
  //   let nearestDistance
  //   let secondNearest
  //   let secondNearestDistance
  //   for (const location of game.locations) {
  //     if (location.category != 'city') continue
  //     if (location.terrainIndex == origin.terrainIndex) continue
  //     const start = world.terrains[origin.terrainIndex]
  //     const end = world.terrains[location.terrainIndex]
  //     const distance = getTileDistance(start, end)
  //     if (!restricted2Zone || location.zoneId == origin.zoneId) {
  //       if (nearestDistance == null || distance < nearestDistance) {
  //         nearestDistance = distance
  //         nearest = location
  //       } else if (secondNearestDistance == null || distance < secondNearestDistance) {
  //         secondNearestDistance = distance
  //         secondNearest = location
  //       } else {
  //         continue
  //       }
  //     }
  //   }
  //   return { nearest, secondNearest }
  // }

  // function resetRouteTerrainSprite(route) {
  //   final sub = route.sublist(1, route.length - 1)
  //   if (sub.isEmpty) return
  //   for (const index in sub) {
  //     const terrain = world.terrains[index]
  //     terrain.isRoute = true
  //     if (terrain.kind == 'mountain') {
  //       terrain.kind = 'plain'
  //       terrain.spriteIndex = kSpriteLand
  //       delete terrain.sprite
  //     }
  //   }
  // }

  // engine.debug('确保陆地上的每个城市至少可以链接到另外两个城市')
  // for (const location of game.locations) {
  //   if (location.category != 'city') continue
  //   const start = world.terrains[location.terrainIndex]
  //   // 确保陆地上的每个城市至少可以链接到另外两个城市
  //   const searchResult = find2NearestLocation(location, restricted2Zone: true)
  //   if (searchResult.nearest) {
  //     const end = world.terrains[searchResult.nearest.terrainIndex]
  //     const route = calculateRoute(start, end, world, terrainKinds: Constants.terrainKindsLand)
  //     if (route) {
  //       resetRouteTerrainSprite(route)
  //     }
  //   }
  //   if (searchResult.secondNearest) {
  //     const end = world.terrains[searchResult.secondNearest.terrainIndex]
  //     const route = calculateRoute(start, end, world, terrainKinds: Constants.terrainKindsLand)
  //     if (route) {
  //       resetRouteTerrainSprite(route)
  //     }
  //   }
  // }

  const nations = []
  // 随机挑选几个城市，作为各个国家的都城，生成地图上的不同国家
  engine.info('随机挑选几个城市作为都城，并生成国家')
  let capitals = Set()
  while (nations.length < nationNumber) {
    let availableCities = game.locations.values
      .where((loc) => loc.category == 'city' && loc.organizationId == null)
      .toList()
    assert(availableCities.isNotEmpty)
    const city = random.nextIterable(availableCities)
    const head = Character(
      birthTimestamp: createBirthTimestamp(min: 30, max: 60),
      rank: _kSandboxInitialRankMax,
    )
    head.locationId = city.id
    assert(city.worldPosition != null)
    head.worldPosition = Object.create(city.worldPosition)
    const organization = Organization(
      headquartersLocation: city,
      headId: head.id,
    )
    nations.add(organization)

    capitals.add(city)
    city.development += 1

    final siteKinds = Constants.siteKindsBuildable.toList()

    final organizationCategoryKind = Constants.organizationCategoryToSiteKind[organization.category]
    siteKinds.remove(organizationCategoryKind)
    Location(
      id: city.name + '_${engine.locale(organizationCategoryKind)}',
      name: engine.locale(organizationCategoryKind),
      category: 'site',
      kind: organizationCategoryKind,
      atLocation: city,
      organizationId: organization.id,
      development: random.nextInt(city.development + 1),
      npcId: Constants.siteKindToNpcId[organizationCategoryKind],
    )
    
    final organizationGenreKinds = Constants.organizationGenreToSiteKinds[organization.genre]
    final secondaryClassSiteKind = random.nextIterable(organizationGenreKinds)
    siteKinds.remove(secondaryClassSiteKind)
    Location(
      id: city.name + '_${engine.locale(secondaryClassSiteKind)}',
      name: engine.locale(secondaryClassSiteKind),
      category: 'site',
      kind: secondaryClassSiteKind,
      atLocation: city,
      organizationId: organization.id,
      development: random.nextInt(city.development + 1),
      npcId: Constants.siteKindToNpcId[secondaryClassSiteKind],
    )

    final buildingCount = buildingCountForDevelopment(city.development)
    if (city.sites.length < buildingCount) {
      final remainingBuildingSlots = buildingCount - city.sites.length
      for (var i in range(remainingBuildingSlots)) {
        final roll = random.nextDouble()
        if (roll > _kCityHasExtraBuildingProbability) continue

        final kind = random.nextIterable(siteKinds)
        siteKinds.remove(kind)
        Location(
          id: city.name + '_${engine.locale(kind)}',
          name: engine.locale(kind),
          category: 'site',
          kind: kind,
          atLocation: city,
          organizationId: organization.id,
          development: random.nextInt(city.development + 1),
          npcId: Constants.siteKindToNpcId[kind],
        )
      }
    }
  }

  let nonCapitalCities = game.locations.values
    .where((loc) => 
      loc.category == 'city'
      && !capitals.contains(loc)
    )
    .toList()
  for (final city in nonCapitalCities) {
    final siteKinds = Constants.siteKindsBuildable.toList()
    final buildingCount = buildingCountForDevelopment(city.development)
    if (city.sites.length < buildingCount) {
      final remainingBuildingSlots = buildingCount - city.sites.length
      for (var i in range(remainingBuildingSlots)) {
        final roll = random.nextDouble()
        if (roll > _kCityHasExtraBuildingProbability) continue
        
        final kind = random.nextIterable(siteKinds)
        siteKinds.remove(kind)
        Location(
          id: city.name + '_${engine.locale(kind)}',
          name: engine.locale(kind),
          category: 'site',
          kind: kind,
          atLocation: city,
          organizationId: city.organizationId,
          development: random.nextInt(city.development + 1),
          npcId: Constants.siteKindToNpcId[kind],
        )
      }
    }
  }

  engine.info('生成初始角色')
  final cities = game.locations.values.where((loc) =>
    loc.category == 'city' && loc.isHidden == false
  ).toList()
  while (game.characters.length < characterNumber) {
    // 因为struct不能按照固定顺序排序，因此这里按照keys来随机。
    const city = random.nextIterable(cities)
    Character(
      locationId: city.id,
      rank: random.distantInt(_kSandboxInitialRankMax + 1),
      birthTimestamp: createBirthTimestamp(min: 12, max: 60),
    )
  }

  // 模拟世界演化，按照时间推进并生成人物、组织，并且为期分配人物关系
  // 在此种演化算法中，人物不会死亡，组织不会被消灭，因此只判断人数是否达到要求
  // 因为是模拟运行，每个tick接跳过一个月
  engine.info('扩张门派的成员和领地')
  for (var i in range(5)) {
    // 国家和组织扩张
    for (const organization of game.organizations) {
      final expansionRate = Constants.organizationCategoryExpansionRate[organization.category]
      let roll = random.nextDouble()
      if (roll > expansionRate) continue
      final availableCities = game.locations.values.where((location) =>
        location.category == 'city' &&
        location.organizationId == null
      ).toList()
      if (availableCities.isEmpty) {
        // engine.warn('组织 ${organization.id} 没有可用的据点可以扩张了。')
        continue
      }
      // engine.debug('组织 ${organization.name} 尝试扩张新领土')
      if (availableCities.length > 1) {
        // 按照距离组织据点的远近排序
        final headquarters = game.locations[organization.headquartersLocationId]
        final headquartersTile = world.terrains[headquarters.terrainIndex]

        availableCities.sort((a, b) {
          final distanceA = getTileDistance(headquartersTile, world.terrains[a.terrainIndex])
          final distanceB = getTileDistance(headquartersTile, world.terrains[b.terrainIndex])
          return distanceA.compareTo(distanceB)
        })
      }
      final newCity = availableCities.first
      addLocationToOrganization(newCity, organization)
    }
  }
  for (var i in range(10)) {
    for (const organization of game.organizations) {
      let roll = random.nextDouble()
      if (roll > _kOrganizationRecruitProbability) continue
      final availableCharacters = game.characters.values.where((char) =>
        char.organizationId == null
      )
      if (availableCharacters.isEmpty) {
        // engine.warn('组织 ${organization.id} 没有可用的角色可以招募了。')
        continue
      }
      // engine.debug('组织 ${organization.id} 尝试招募新成员')
      final character = random.shuffle(availableCharacters).first
      addCharacterToOrganization(character, organization)
    }
  }
  
  engine.info('处理婚姻和生育')
  for (var i in range(characterNumber ~/ 4)) {
    for (const char of game.characters) {
      if (!char.isFemale) continue
      const age = getCharacterAge(char)
      if (age < _kAdultAge || age > _kPregnancyAgeMax) continue
      if (char.isPregnant) continue
      if (char.motivations.contains('dink')) continue

      let spouseId = getSpouses(char).first?.characterId
      if (spouseId != null) {
        const spouse = game.characters[spouseId]
        if (spouse.motivations.contains('dink')) continue
        final childrenCount = hasChild(char)
        if (childrenCount >= _kChildrenMax) continue
        Baby(father: spouse, mother: char)
      } else {
        if (char.motivations.contains('celibate')) continue
        
        for (const otherChar of game.characters) {
          if (char.id == otherChar.id) continue
          if (otherChar.isFemale) continue
          if (getCharacterAge(otherChar) < _kAdultAge) continue
          if (hasSpouse(otherChar)) continue

          createSpouse(otherChar, char)
          characterMet(char, otherChar)
          break
        }
      }
    }
  }

  // 生成地牢
  engine.info('添加秘境')
  for (final city in cities) {
    final r = random.nextDouble()
    if (r > _kDungeonOnTerritoryProbability) continue

    let availableTiles = city.territoryIndexes
      .map((index) => world.terrains[index])
      .where((tile) => !tile.isWater && tile.locationId == null)
    if (availableTiles.isEmpty) continue

    final dungeionTile = random.nextIterable(availableTiles)
    dungeionTile.overlaySprite = {
      sprite: 'object/dungeon.png',
    }

    const location = Location(
      category: 'site',
      kind: 'dungeon',
      atTerrain: dungeionTile,
      updateWorldMap: false,
      organizationId: city.organizationId,
      npcId: Constants.siteKindToNpcId['dungeon'],
    )
    location.dungeonId = 'dungeon_1'
    dungeionTile.locationId = location.id
  }

  engine.info('为角色添加次要动机')
  for (const char of game.characters) {
    const age = getCharacterAge(char)
    if (char.motivations.isNotEmpty) continue
    
    if (char.relationships.sect.isEmpty) {
      if (!char.motivations.contains('shifu')) {
        char.motivations.add('shifu')
        continue
      }
    }
    
    if (char.relationships.friendship.isEmpty) {
      if (!char.motivations.contains('friendship')) {
        char.motivations.add('friendship')
        continue
      }
    }
    
    if (char.relationships.romance.isEmpty) {
      if (!char.motivations.contains('romance')) {
        char.motivations.add('romance')
        continue
      }
    }
    
    if (!hasSpouse(char)) {
      if (age >= _kAdultAge && !char.motivations.contains('spouse')) {
        char.motivations.add('spouse')
        continue
      }
    }
    
    if (!hasChild(char)) {
      if (age >= _kAdultAge && !char.motivations.contains('child')) {
        char.motivations.add('child')
      }
    }
  }

  engine.info('--------世界生成完毕，清理临时数据--------')

  Game.updateGame(tick: 0, force: true, updateEntity: true, updateUI: false, updateWorldMap: false)
  
  // setRandomSeed()

  for (final tile in world.terrains) {
    updateTerritoryBorders(tile)
  }

  // clean up
  delete world.landIndexes
  delete world.waterIndexes
  delete world.mountainIndexes
  delete world.seaIndexes
  delete world.fisheryIndexes

  return world
}
