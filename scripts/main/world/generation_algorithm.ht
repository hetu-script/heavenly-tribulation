import 'tile/common.ht'
import 'zone.ht'

const _kMinZoneSizeOfSea = 8
const _kMinZoneSizeOfIsland = 8

const kMapStyles = ['islands', 'coast', 'inland']

/// 利用 noise 函数生成大陆和海洋的算法
function generateContinent2(world, {seed, style}) {
  let noiseData
  let threshold
  let threshold2
  assert(style in kMapStyles)
  final dimension = (world.width + world.height) / 2
  switch (style) {
    'islands' : {
      threshold = 0.45
      threshold2 = 0.3
      noiseData = Math.noise2d(
        world.width,
        world.height,
        seed: seed,
        noiseType: 'perlinFractal',
        frequency: 6 / dimension,
        octaves: 3,
      )
    }
    'coast' : {
      threshold = 0.55
      threshold2 = 0.33
      noiseData = Math.noise2d(
        world.width,
        world.height,
        seed: seed,
        noiseType: 'valueFractal',
        frequency: 3.5 / dimension,
        octaves: 10,
      )
    }
    'inland' : {
      threshold = 0.65
      threshold2 = 0.42
      noiseData = Math.noise2d(
        world.width,
        world.height,
        seed: seed,
        noiseType: 'cubicFractal',
        frequency: 10 / dimension,
        octaves: 3,
      )
    }
  }
  for (const y in range(world.height)) {
    for (const x in range(world.width)) {
      // 地图边缘留空
      if (y == 0 || y == world.height - 1 || x == 0 || x == world.width - 1) continue
      const noise = noiseData[x][y]
      const normalize = (noise + 1) / 2;
      const index = tilePos2Index(x + 1, y + 1, world.width)
      const tile = world.terrains[index]
      if (normalize > threshold) {
        // 海洋
        world.waterIndexes.add(index)
      } else if (normalize > threshold2) {
        // 陆地
        tile.spriteIndex = kSpriteLand
        world.landIndexes.add(index)
      } else {
        // 山地
        tile.spriteIndex = kSpriteLand
        tile.kind = 'mountain'
        tile.sprite = 'object/mountain.png'
        world.landIndexes.add(index)
      }
    }
  }
}

function nameZones(world) {
  engine.debug('为地域命名')
  if (world.zones.isEmpty) return

  for (const zone of world.zones) {
    // kZoneWater & kZoneLand 只是临时类型，现在替换为具体的类型
    if (zone.category == kZoneWater) {
      // 将临时类型 water 根据情况替换为 sea 和 lake
      if (zone.terrainIndexes.length < _kMinZoneSizeOfSea) {
        zone.category = kZoneCategoryLake
        // 将可捕鱼区域保存在一个总表中
        world.fisheryIndexes.addAll(zone.terrainIndexes)
      } else {
        zone.category = kZoneCategorySea
        // 将海域保存在一个总表中
        world.seaIndexes.addAll(zone.terrainIndexes)
      }
      // 为该地域中所有地块赋值 kind
      for (const terrainIndex in zone.terrainIndexes) {
        const terrain = world.terrains[terrainIndex]
        terrain.isWater = true
        if (zone.category == kZoneCategoryLake) {
          terrain.kind = 'lake'
          // TODO: lake类型单独的贴图
          terrain.sprite = 'object/river.png'
        }
      }
    } else if (zone.category == kZoneLand) {
      // 将临时类型 land 根据情况替换为 continent 和 island
      if (zone.terrainIndexes.length < _kMinZoneSizeOfIsland) {
        zone.category = kZoneCategoryIsland
      } else {
        zone.category = kZoneCategoryContinent
      }
      // 这里并不会为地块赋值 kind
      // 因为陆地上会生成多种地形类型，在其他的函数中处理
      // for (const terrainIndex in zone.terrainIndexes) {
      //   const terrain = world.terrains[terrainIndex]
      //   // TODO: 道路类型单独的贴图
      // }
    }
    // else if (zone.category == kZoneRiver) {
    //   zone.category = kZoneCategoryRiver
    //   for (const terrainIndex in zone.terrainIndexes) {
    //     const terrain = world.terrains[terrainIndex]
    //     terrain.isWater = true
    //     // TODO: river类型单独的贴图
    //     terrain.sprite = 'object/river.png'
    //   }
    // }

    zone.name = generateZoneName(category: zone.category)
  }
}