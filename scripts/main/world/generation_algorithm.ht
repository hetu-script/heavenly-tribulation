import 'tile/common.ht'
import 'zone.ht'

const _kMinZoneSizeOfSea = 16
const _kMinZoneSizeOfIsland = 8

const kMapStyles = ['islands', 'coast', 'inland']

/// 利用 noise 函数生成大陆和海洋的算法
function generateContinent2(map, {seed, style}) {
  let noiseData
  let threshold
  let threshold2
  assert(style in kMapStyles)
  final dimension = (map.width + map.height) / 2
  switch (style) {
    'islands' : {
      threshold = 0.45
      threshold2 = 0.3
      noiseData = Math.noise2d(
        map.width,
        map.height,
        seed: seed,
        noiseType: 'perlinFractal',
        frequency: 6 / dimension,
        octaves: 3,
      )
    }
    'coast' : {
      threshold = 0.55
      threshold2 = 0.33
      noiseData = Math.noise2d(
        map.width,
        map.height,
        seed: seed,
        noiseType: 'valueFractal',
        frequency: 3.5 / dimension,
        octaves: 10,
      )
    }
    'inland' : {
      threshold = 0.65
      threshold2 = 0.42
      noiseData = Math.noise2d(
        map.width,
        map.height,
        seed: seed,
        noiseType: 'cubicFractal',
        frequency: 10 / dimension,
        octaves: 3,
      )
    }
  }
  map.landIndexes = []
  map.waterIndexes = []
  map.mountainIndexes = []
  map.seaIndexes = []
  map.fisheryIndexes = []
  for (const y in range(map.height)) {
    for (const x in range(map.width)) {
      // 地图边缘留空
      if (y == 0 || y == map.height - 1 || x == 0 || x == map.width - 1) continue
      const noise = noiseData[x][y]
      const normalize = (noise + 1) / 2;
      const index = tilePos2Index(x + 1, y + 1, map.width)
      const tile = map.terrains[index]
      if (normalize > threshold) {
        // 海洋（包括大陆架）
        map.waterIndexes.add(index)
      } else if (normalize > threshold2) {
        // 陆地（包括森林）
        tile.spriteIndex = kSpriteLand
        map.landIndexes.add(index)
      } else {
        // 山地
        tile.spriteIndex = kSpriteLand
        tile.kind = 'mountain'
        tile.sprite = 'object/mountain.png'
        map.mountainIndexes.add(index)
      }
    }
  }
}

function nameZones(world) {
  engine.debug('为地域命名')
  if (world.zones.isEmpty) return

  for (const zone of world.zones) {
    // kZoneWater & kZoneLand 只是临时类型，现在替换为具体的类型
    if (zone.category == kZoneWater) {
      // 将临时类型 water 根据情况替换为 sea 和 lake
      if (zone.terrainIndexes.length < _kMinZoneSizeOfSea) {
        zone.category = kZoneCategoryLake
        // 将可捕鱼区域保存在一个总表中
        world.fisheryIndexes.addAll(zone.terrainIndexes)
      } else {
        zone.category = kZoneCategorySea
        // 将海域保存在一个总表中
        world.seaIndexes.addAll(zone.terrainIndexes)
      }
      // 为该地域中所有地块赋值 kind
      for (const terrainIndex in zone.terrainIndexes) {
        const terrain = world.terrains[terrainIndex]
        terrain.isWater = true
        if (zone.category == kZoneCategoryLake) {
          terrain.kind = 'lake'
          terrain.sprite = 'object/lake.png'
        } else {
          if (terrain.kind != 'shelf') {
            terrain.kind = 'sea'
          }
        }
      }
    } else if (zone.category == kZoneLand) {
      // 将临时类型 land 根据情况替换为 continent 和 island
      if (zone.terrainIndexes.length < _kMinZoneSizeOfIsland) {
        zone.category = kZoneCategoryIsland
      } else {
        zone.category = kZoneCategoryContinent
      }
      // 这里并不会为地块赋值 kind
      // 因为陆地上会生成多种地形类型，在其他的函数中处理
      // for (const terrainIndex in zone.terrainIndexes) {
      //   const terrain = world.terrains[terrainIndex]
      //   // TODO: 道路类型单独的贴图
      // }
    }
    // TODO: 河流类型单独的贴图
    // else if (zone.category == kZoneRiver) {
    //   zone.category = kZoneCategoryRiver
    //   for (const terrainIndex in zone.terrainIndexes) {
    //     const terrain = world.terrains[terrainIndex]
    //     terrain.isWater = true
    //     // TODO: river类型单独的贴图
    //     terrain.sprite = 'object/river.png'
    //   }
    // }

    zone.name = generateZoneName(category: zone.category)
  }
}