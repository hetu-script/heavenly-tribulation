// import 'data.ht'
// import '../world/tile/hexagonal_tile.ht'
// import '../world/tile/tilemap.ht'
// import '../datetime.ht'
// import '../entity/item/material.ht'
// import '../entity/character/battle_entity.ht'
// import '../game/world.ht'
// import '../game/dialog.ht'
// import '../entity/entity.ht'
// import '../entity/organization/organization.ht'
// import '../event/event.ht'
// import '../colors.ht'
// import '../common.ht'
// import '../entity/character/character.ht'
// import '../name/character.ht'
// import '../entity/location/location.ht'
import '../world/tile/common.ht'

external function expForLevel(level: integer) -> integer

external function minLevelForRank(rank) -> integer

external function maxLevelForRank(rank) -> integer

external function getMinMaxExtraAffixCount(rank) -> Map

external function getCardCraftMaterial(operationId, card) -> integer 

external function getDeckLimitForRank(rank) -> Map

external function calculateItemPrice(item, {priceFactor, isSell = true}) -> integer

external function generateZone(world)

const kSearchSuccessProbability = 0.25

// 打猎会增加遇到野兽的概率200%
// 这个概率将会和地点本身的野兽概率相乘
const kHuntBeastProbability = 2.0

// 山峰上可能遇到强盗和野兽，但产出也较高
const kMountainBeastProbability = 0.15
const kMountainFruitProbability = 0.4
const kMountainWoodProbability = 0.3
const kMountainOreProbability = 0.15
const kMountainShardProbability = 0.07
const kMountainHerbProbability = 0.2

// 森林中可能遇到强盗和野兽，但产出也较高
const kForestBeastProbability = 0.07
const kForestFruitProbability = 0.8
const kForestWoodProbability = 0.6
const kForestOreProbability = 0.04
const kForestShardProbability = 0.02
const kForestHerbProbability = 0.4

// 平原上几乎不会遇到强盗和野兽，但产出也较低
const kPlainBeastProbability = 0.02
const kPlainFruitProbability = 0.3
const kPlainWoodProbability = 0.1
const kPlainOreProbability = 0.01
const kPlainShardProbability = 0.001
const kPlainHerbProbability = 0.1

// 湖泊上没有风暴，但产出也较低
const kLakeFishProbability = 0.25

// 海洋上可能会遇到暴风雨，但产出也较高
const kSeaStormProbability = 0.3
const kSeaFishProbability = 0.45

const kMoneyRewardRate = 0.4
const kRewardProbabilityExppack = 1.0
const kRewardProbabilityMoney = 1.0
const kRewardProbabilityShard = 0.4
const kRewardProbabilityEquipment = 0.3
const kRewardProbabilityPotion = 0.2
const kRewardProbabilityCardpack = 0.2
const kRewardProbabilityScrollPaper = 0.1
const kRewardProbabilityDungeonTicket = 0.02
const kRewardProbabilityDungeonTicketNextLevel = 0.4
const kRewardProbabilityCraftMaterial = 0.1
const kRewardProbabilityCraftMaterialReplaceAffix = 0.4
const kRewardProbabilityCraftMaterialRerollAffix = 0.25
const kRewardProbabilityCraftMaterialUpgradeRank = 0.1

const kSpiritWellProbabilitySpirit = 0.75
const kSpiritWellProbabilityCraftMaterial = 0.4

/// 进行打坐、探索、工作时，时间不能跨过一个月，因为每月底会刷新和结算
/// 取本月剩余的天数和英雄剩余的体力的最小值
/// 消耗体力为每天4点（每个tick 1点）。
function getHeroAvaialbeDays() {
  let maxAvailableDays = 29 - day
  if (maxAvailableDays < 1) {
    Dialog.localeLines(['cannotInteractAtEndOfMonth'], isHero: true)
    return 0
  }

  const staminaAvailableDays = hero.life ~/ kTicksPerDay
  if (staminaAvailableDays < 1) {
    Dialog.localeLines(['notEnoughStaminaMonologue'], isHero: true)
    return 0
  }

  const availableDays = Math.min(maxAvailableDays, staminaAvailableDays)
}

const kCondenseSpiritSuccessProbability = 0.25

const maxSpiritSurgingGain = {
  '1': {
    probability: 0.05,
    max: 2,
  },
  '2': {
    probability: 0.09,
    max: 5,
  },
  '3': {
    probability: 0.17,
    max: 9,
  },
  '4': {
    probability: 0.32,
    max: 15,
  },
  '5': {
    probability: 0.6,
    max: 23,
  },
}

async function selectHeroAttribute() {
  final selections = {};
  for (final key in Constants.battleAttributes) {
    final attrName = engine.locale(key)
    final attrDescription = engine.locale('${key}_description')
    selections[key] = {
      'text': attrName,
      'description':
          '${attrDescription}\n${engine.locale('current')}${attrName}: ${hero.stats[key]}',
    }
  }
  selections['cancel'] = engine.locale('cancel')

  Dialog.pushSelectionRaw({
    id: 'selectedAttribute',
    selections: selections,
  })
  await Dialog.execute()
  final selected = Dialog.checkSelected('selectedAttribute')
  return selected
}

// const kExploreLightUpSize = 6

// function onHeroExplore(terrain) {
//   // if (hero.stats.mana < 1) {
//   //   Dialog.localeLines('notEnoughManaMonologue', isHero: true)
//   //   return
//   // } else {
//   //   engine.play('wind-blow-141288.mp3')
//   //   World.lightUpAroundTile(terrain.left, terrain.top, kExploreLightUpSize)
//   // }
//   onWorldEvent('onAfterHeroExplore', terrain)
// }

/// 打坐时可以选择进行三种操作：
/// 
/// 休息（消耗食物和水，恢复生命和体力）
/// 聚气 将灵石化为自身灵气，或者直接吸收天地灵气
/// 凝气 将自身灵气化为灵石
/// 在灵气喷涌的地方打坐，可以直接获得灵气，最多获取数量和自身境界有关
/// 理论上限：116（每天4个tick，乘以29天）
/// 凝气（2），筑基（5），结丹（9），还婴（15），化神（23）
/// 在没有灵气喷涌的地方打坐，可以消耗灵石获得灵气。
async function onHeroMeditate({site, terrain, incurIncident = true}) {
  let selection = await Dialog.localeSelect([
    'rest',
    'gatherSpirit',
    'condenseSpirit',
    'cancel',
  ])

  switch (selection) {
    'rest': {
      
    }
    'gatherSpirit': {
      // let gathered = false
      // // 灵气已满，无法聚气
      // if (hero.stats.mana >= hero.stats.manaMax) {
      //   Dialog.localeLines('hint_manaFull', isHero: true)
      //   return
      // }

      // if (terrain != null) {
      //   // 此地灵气喷涌，可以直接聚气
      //   if (terrain.flags.isSpiritSurging) {
      //     let gainData = maxSpiritSurgingGain[hero.rank]
      //     assert(gainData != null) 
      //     // TODO: 角色神识、天赋被动等stats可以提高成功率
      //     let probability = gainData.probability + hero.stats.gatherSpiritProbabilityAdd ?? 0

      //     let availableDays = getHeroAvaialbeDays()
      //     let selectedDays = await Dialog.inputInteger(engine.locale('timeDays'), 1, availableDays)
      //     if (selectedDays <= 0) return
      //     let days = 0
      //     let found = false
      //     let totalMana = 0
      //     await Dialog.progress(engine.locale('gatherSpirit'), checkProgress: () {
      //       ++days
      //       if (world.isMain) {
      //         updateGame(ticks: kTicksPerDay)
      //       }
      //       tryChangeStats(hero, 'stamina', -kTicksPerDay)
      //       let gatheredSpirit = 0
      //       for (let i in range(4)) {
      //         if (random.nextDouble() < probability) {
      //           ++gatheredSpirit
      //         }
      //       }
      //       totalMana += gatheredSpirit
      //       // 灵气已达上限，无法继续
      //       if (totalMana >= gainData.max) {
      //         return false
      //       }
      //       // 灵气已满，无法继续
      //       if (hero.stats.mana >= hero.stats.manaMax) {
      //         Dialog.localeLines('hint_manaFull', isHero: true)
      //         return false
      //       }
      //       // 达到预定的天数，无法继续
      //       if (days >= selectedDays) {
      //         return false
      //       }
      //       return true
      //     })
      //     if (totalMana < 1) totalMana = 1
      //     let residue = tryChangeStats(hero, 'mana', totalMana)
      //     let restoredValue = totalMana - residue
      //     Player.update()
      //     engine.play('spell-of-healing-876.mp3')
      //     World.addHintText('${engine.locale('mana')} +${restoredValue}', terrain.left, terrain.top, Colors.purple)
      //     if (residue != 0) {
      //       await Dialog.localeLines('hint_wastedSpirit', isHero: true)
      //     }
      //     await Dialog.localeLines('hint_spiritGathered', isHero: true)
      //     // 清空这个地块的灵气喷涌状态
      //     delete terrain.flags.isSpiritSurging
      //     World.clearTerrainOverlayAnimation(terrain.left, terrain.top)

      //     const incidentContent = engine.locale('characterMeditate', interpolations: [
      //       hero.name,
      //       '${terrain.left}, ${terrain.top}',
      //       days,
      //     ])
      //     if (incurIncident) {
      //       Incident(
      //         subjectId: hero.id,
      //         message: incidentContent,
      //         isPrivate: true,
      //       )
      //     } else {
      //       engine.debug(incidentContent)
      //     }

      //     gathered = true
      //   } else {
      //     if (hero.materials.shard <= 0) {
      //       if (hasItemKind('shard')) {
      //         Dialog.localeLines('hint_openPackage.shard', isHero: true)
      //       } else {
      //         Dialog.localeLines('hint_notEnoughShard', isHero: true)
      //       }
      //     } else {
      //       // 消耗灵石来聚气
      //     }
      //   }
      // }

      // if (gathered) {
      //   onWorldEvent('onAfterHeroGatherSpirit')
      // }
    }
    'condenseSpirit': {

    }
  }
}

/// 返回一个包含可移动的tile kind的列表
/// 如果不为null且非空，则英雄可以开始尝试向这个格子移动，但中途有可能停下
/// 否则不会进入移动路径计算
async function onBeforeMove(terrain) {
  final result = await onWorldEvent('onBeforeMove', terrain)
  if (result) {
    return result
  }
  let movableTerrainKinds = getCharacterMovableTerrainKinds(hero)
  
  if (terrain.kind in movableTerrainKinds) {
    return movableTerrainKinds
  } else {
    if (Constants.terrainKindsWater.contains(terrain.kind)) {
      Dialog.pushDialog('hint_ship')
      Dialog.execute()
    } else if (Constants.terrainKindsMountain.contains(terrain.kind)) {
      Dialog.pushDialog('hint_boots')
      Dialog.execute()
    }
    return null
  }
}

// async function onAfterMove(terrain) {
//   final result = await onWorldEvent('onAfterMove', terrain) 
//   if (result != null) {
//     return result
//   }
  /// 如果最终目的地不可到达，但角色停在了目的地旁边一格，则仍会和该目的地互动
  // if (targetTerrain != null && targetTerrain.objectId) {
  //   const object = world.objects[targetTerrain.objectId]
  //   if (object.isDiscovered) {
  //     onInteractMapObject(object, targetTerrain)
  //   } else {
  //     Dialog.pushDialog('hint_sensedUndiscovered', isHero: true)
  //     await Dialog.execute()
  //   }
  // }
  // if (terrain.locationId) {
  //   const location = world.locations[terrain.locationId]
  //   if (location.isDiscovered) {
  //     World.enterLocation(location)
  //   } else {
  //     Dialog.pushDialog('hint_sensedUndiscovered', isHero: true)
  //     await Dialog.execute()
  //   }
  // }
// }

/// 在某个地形块上进行互动操作
/// 山峰或树林产出物品更多，平原产出数量较少
/// 但前者会有几率碰到野兽或者强盗
// function onTouchTerrain(terrain) {

//   if (terrain.kind == kTerrainKindRoad) {
//     // TODO: 道路上不能进行互动
//   }
  
//   // let isInjured = false
//   // for (const status of hero.statusEffects) {
//   //   if (status.category == kStatusCategoryInjury)
//   //   isInjured = true
//   // }
//   // if (isInjured) {
//   //   Dialog.localeLines(['cannotInteractWhenInjured'], isHero: true)
//   //   return
//   // }


//   // 可用的探索天数
//   let availableDays = getHeroAvaialbeDays()

//   const selections = [
//     'search',
//   ]

//   switch (terrain.kind) {
//     kTerrainKindForest : {
//       selections.add('woodcut')
//       selections.add('gather')
//       selections.add('hunt')
//     }
//     kTerrainKindMountain : {
//       selections.add('excavate')
//       selections.add('gather')
//       selections.add('hunt')
//     }
//     kTerrainKindLake, kTerrainKindSea : {
//       selections.add('fish')
//     }
//   }

//   selections.add('cancel')
  
//   Dialog.localeSelect(selections).then((key) {
//     switch (key) {
//       'search' : {
//         let undiscoveredLocation
//         let undiscoveredObject
//         if (terrain.locationId) {
//           const location = world.locations[terrain.locationId]
//           if (!location.isDiscovered) {
//             undiscoveredLocation = location
//           }
//         } else if (terrain.objectId) {
//           const object = world.objects[terrain.objectId]
//           if (!object.isDiscovered) {
//             undiscoveredObject = object
//           }
//         }

//         if (undiscoveredObject) {
//           Dialog.inputInteger(engine.locale('timeDays'), availableDays).then((days) {
//             let i = 0
//             let found = false
//             Dialog.progress(engine.locale('search'), checkProgress: () {
//               ++i
//               updateGame(ticks: kTicksPerDay)
//               changeStamina(hero, -kTicksPerDay)
//               // TODO: 角色神识可以提高成功率
//               if (random.nextDouble() < kSearchSuccessProbability) {
//                 found = true
//                 return false
//               }
//               if (i >= days) return false
//               return true
//             }).then((_) {
//               const incidentContent = engine.locale('characterExplore', interpolations: [
//                 hero.name,
//                 '${terrain.left}, ${terrain.top}',
//                 i,
//               ])
//               engine.debug(incidentContent)
//               // Incident(
//               //   subjectId: hero.id,
//               //   message: incidentContent,
//               //   isPrivate: true,
//               // )
//               if (found) {
//                 undiscoveredObject.isDiscovered = true
//                 // discoverObject(undiscoveredLocation)
//                 onInteractMapObject(object, terrain)
//               } else {
//                 Dialog.localeLines(['searchFailed'], isHero: true)
//               }
//             })
//           })
//         } else if (undiscoveredLocation) {
//           Dialog.inputInteger(engine.locale('timeDays'), availableDays).then((days) {
//             let i = 0
//             let found = false
//             Dialog.progress(engine.locale('search'), checkProgress: () {
//               ++i
//               updateGame(ticks: kTicksPerDay)
//               changeStamina(hero, -kTicksPerDay)
//               // TODO: 角色神识可以提高成功率
//               if (random.nextDouble() < kSearchSuccessProbability) {
//                 found = true
//                 return false
//               }
//               if (i >= days) return false
//               return true
//             }).then((_) {
//               const incidentContent = engine.locale('characterExplore', interpolations: [
//                 hero.name,
//                 '${terrain.left}, ${terrain.top}',
//                 i,
//               ])
//               engine.debug(incidentContent)
//               // Incident(
//               //   subjectIds: [hero.id],
//               //   message: incidentContent,
//               //   isPrivate: true,
//               // )
//               if (found) {
//                 undiscoveredLocation.isDiscovered = true
//                 discoverLocation(undiscoveredLocation)
//                 // TODO: 第一次发现据点事件
//                 const message = engine.locale('firstVisitCity', interpolations: [undiscoveredLocation.name])
//                 Dialog.lines([message]).then((_) {
//                   World.enterLocation(undiscoveredLocation)
//                 })
//               } else {
//                 Dialog.localeLines(['searchFailed'], isHero: true)
//               }
//             })
//           })
//         } else {
//           Dialog.inputInteger(engine.locale('timeDays'), availableDays).then((days) {
//             Dialog.progress(engine.locale('search'), checkProgress: () {
//               updateGame(ticks: kTicksPerDay)
//               changeStamina(hero, -kTicksPerDay)
//               return false
//             }).then((_) {
//               const incidentContent = engine.locale('characterExplore', interpolations: [
//                 hero.name,
//                 '${terrain.left}, ${terrain.top}',
//                 1,
//               ])
//               engine.debug(incidentContent)
//               // Incident(
//               //   subjectIds: [hero.id],
//               //   message: incidentContent,
//               //   isPrivate: true,
//               // )
//               Dialog.localeLines(['exploredEmtpy'], isHero: true)
//             })
//           })
//         }
//       }
//       // 采集，可能会获得：药材（材料）、水果（材料）
//       'gather' : {
//         Dialog.inputInteger(engine.locale('timeDays'), availableDays).then((days) {
//           const lootbox = Lootbox()
//           let metBeast = false
//           let i = 0
//           Dialog.progress(engine.locale('gather'), () {
//             ++i
//             updateGame(ticks: kTicksPerDay)
//             changeStamina(hero, -kTicksPerDay)
//             switch (terrain.kind) {
//               kTerrainKindMountain : {
//                 if (random.nextDouble() < kMountainBeastProbability) {
//                   metBeast = true
//                   return false
//                 }
//                 if (random.nextDouble() < kMountainHerbProbability) {
//                   acquire(lootbox, Material.herb(), incurIncident: false)
//                 }
//                 if (random.nextDouble() < kMountainFruitProbability) {
//                   acquire(lootbox, Material.fruit(), incurIncident: false)
//                 }
//               }
//               kTerrainKindForest : {
//                 if (random.nextDouble() < kForestBeastProbability) {
//                   metBeast = true
//                   return false
//                 }
//                 if (random.nextDouble() < kForestHerbProbability) {
//                   acquire(lootbox, Material.herb(), incurIncident: false)
//                 }
//                 if (random.nextDouble() < kForestFruitProbability) {
//                   acquire(lootbox, Material.fruit(), incurIncident: false)
//                 }
//               }
//               kTerrainKindPlain : {
//                 if (random.nextDouble() < kPlainHerbProbability) {
//                   acquire(lootbox, Material.herb(), incurIncident: false)
//                 }
//                 if (random.nextDouble() < kPlainFruitProbability) {
//                   acquire(lootbox, Material.fruit(), incurIncident: false)
//                 }
//               }
//             }
//             if (i >= days) return false
//             return true
//           }).then((_) {
//             const incidentContent = engine.locale('characterExplore', interpolations: [
//               hero.name,
//               '${terrain.left}, ${terrain.top}',
//               i,
//             ])
//                 engine.debug(incidentContent)
//             // Incident(
//             //   subjectIds: [hero.id],
//             //   message: incidentContent,
//             //   isPrivate: true,
//             // )
//             () async {
//               if (lootbox.inventory.isEmpty) {
//                 return Dialog.localeLines(['interactionGotNothing'], isHero: true)
//               } else {
//                 loot(hero, lootbox)
//               }
//             } ().then((_) {
//               if (metBeast) {
//                 const beast = Beast()
//                 const message = engine.locale('metBeast', interpolations: [beast.name])
//                 Dialog.lines([message]).then((_) {
//                   heroBattle(beast)
//                 })
//               }
//             })
//           })
//         })
//       }
//       // 伐木，可能会获得：木料
//       'woodcut' : {
//         Dialog.inputInteger(engine.locale('timeDays'), availableDays).then((days) {
//           const lootbox = Lootbox()
//           let metBeast = false
//           let i = 0
//           Dialog.progress(engine.locale('woodcut'), () {
//             ++i
//             updateGame(ticks: kTicksPerDay)
//             changeStamina(hero, -kTicksPerDay)
//             switch (terrain.kind) {
//               kTerrainKindMountain : {
//                 if (random.nextDouble() < kMountainBeastProbability) {
//                   metBeast = true
//                   return false
//                 }
//                 if (random.nextDouble() < kMountainWoodProbability) {
//                   acquire(lootbox, Material.wood(), incurIncident: false)
//                 }
//               }
//               kTerrainKindForest : {
//                 if (random.nextDouble() < kForestBeastProbability) {
//                   metBeast = true
//                   return false
//                 }
//                 if (random.nextDouble() < kForestWoodProbability) {
//                   acquire(lootbox, Material.wood(), incurIncident: false)
//                 }
//               }
//               kTerrainKindPlain : {
//                 if (random.nextDouble() < kPlainWoodProbability) {
//                   acquire(lootbox, Material.wood(), incurIncident: false)
//                 }
//               }
//             }
//             if (i >= days) return false
//             return true
//           }).then((_) {
//             const incidentContent = engine.locale('characterWoodcutted', interpolations: [
//               hero.name,
//               '${terrain.left}, ${terrain.top}',
//               i,
//             ])
//             engine.debug(incidentContent)
//             // Incident(
//             //   subjectIds: [hero.id],
//             //   message: incidentContent,
//             //   isPrivate: true,
//             // )
//             () async {
//               if (lootbox.inventory.isEmpty) {
//                 return Dialog.localeLines(['interactionGotNothing'], isHero: true)
//               } else {
//                 loot(hero, lootbox)
//               }
//             } ().then((_) {
//               if (metBeast) {
//                 const beast = Beast()
//                 const message = engine.locale('metBeast', interpolations: [beast.name])
//                 Dialog.lines([message]).then((_) {
//                   heroBattle(beast)
//                 })
//               }
//             })
//           })
//         })
//       }
//       // 挖矿，可能会获得：矿石、灵石
//       'excavate' : {
//         Dialog.inputInteger(engine.locale('timeDays'), availableDays).then((days) {
//           const lootbox = Lootbox()
//           let metBeast = false
//           let i = 0
//           Dialog.progress(engine.locale('excavate'), () {
//             ++i
//             updateGame(ticks: kTicksPerDay)
//             changeStamina(hero, -kTicksPerDay)
//             switch (terrain.kind) {
//               kTerrainKindMountain : {
//                 if (random.nextDouble() < kMountainBeastProbability) {
//                   metBeast = true
//                   return false
//                 }
//                 if (random.nextDouble() < kMountainOreProbability) {
//                   acquire(lootbox, Material.ore(), incurIncident: false)
//                 }
//                 if (random.nextDouble() < kMountainShardProbability) {
//                   acquire(lootbox, Shard(), incurIncident: false)
//                 }
//               }
//               kTerrainKindForest : {
//                 if (random.nextDouble() < kForestBeastProbability) {
//                   metBeast = true
//                   return false
//                 }
//                 if (random.nextDouble() < kForestOreProbability) {
//                   acquire(lootbox, Material.ore(), incurIncident: false)
//                 }
//                 if (random.nextDouble() < kForestShardProbability) {
//                   acquire(lootbox, Shard(), incurIncident: false)
//                 }
//               }
//               kTerrainKindPlain : {
//                 if (random.nextDouble() < kPlainOreProbability) {
//                   acquire(lootbox, Material.ore(), incurIncident: false)
//                 }
//                 if (random.nextDouble() < kPlainShardProbability) {
//                   acquire(lootbox, Shard(), incurIncident: false)
//                 }
//               }
//             }
//             if (i >= days) return false
//             return true
//           }).then((_) {
//             const incidentContent = engine.locale('characterMined', interpolations: [
//               hero.name,
//               '${terrain.left}, ${terrain.top}',
//               i,
//             ])
//             engine.debug(incidentContent)
//             // Incident(
//             //   subjectIds: [hero.id],
//             //   message: incidentContent,
//             //   isPrivate: true,
//             // )
//             () async {
//               if (lootbox.inventory.isEmpty) {
//                 return Dialog.localeLines(['interactionGotNothing'], isHero: true)
//               } else {
//                 loot(hero, lootbox)
//               }
//             } ().then((_) {
//               if (metBeast) {
//                 const beast = Beast()
//                 const message = engine.locale('metBeast', interpolations: [beast.name])
//                 Dialog.lines([message]).then((_) {
//                   heroBattle(beast)
//                 })
//               }
//             })
//           })
//         })
//       }
//       // 捕猎，增加遇到野兽的概率200%
//       'hunt' : {
//         Dialog.inputInteger(engine.locale('timeDays'), availableDays).then((days) {
//           let metBeast = false
//           let i = 0
//           Dialog.progress(engine.locale('hunt'), () {
//             ++i
//             updateGame(ticks: kTicksPerDay)
//             changeStamina(hero, -kTicksPerDay)
//             switch (terrain.kind) {
//               kTerrainKindMountain : {
//                 if (random.nextDouble() < (kMountainBeastProbability * kHuntBeastProbability)) {
//                   metBeast = true
//                   return false
//                 }
//               }
//               kTerrainKindForest : {
//                 if (random.nextDouble() < (kForestBeastProbability * kHuntBeastProbability)) {
//                   metBeast = true
//                   return false
//                 }
//               }
//               kTerrainKindPlain : {
//                 if (random.nextDouble() < (kPlainBeastProbability * kHuntBeastProbability)) {
//                   metBeast = true
//                   return false
//                 }
//               }
//             }
//             if (i >= days) return false
//             return true
//           }).then((_) {
//             const incidentContent = engine.locale('characterHunted', interpolations: [
//               hero.name,
//               '${terrain.left}, ${terrain.top}',
//               i,
//             ])
//             engine.debug(incidentContent)
//             // Incident(
//             //   subjectIds: [hero.id],
//             //   message: incidentContent,
//             //   isPrivate: true,
//             // )
//             if (metBeast) {
//               const beast = Beast()
//               const message = engine.locale('foundBeast', interpolations: [beast.name])
//               Dialog.lines([message]).then((_) {
//                 heroBattle(beast)
//               })
//             } else {
//               return Dialog.localeLines(['interactionGotNothing'], isHero: true)
//             }
//           })
//         })
//       }
//       // 捕鱼，可能会获得：河鱼、海鱼、虾、蟹
//       'fish' : {
//         // if (game.flags.playerMonthly.fished.contains(terrainIndex)) {
//         //   Dialog.localeLines(['terrainAlreadyFished'], isHero: true)
//         //   return
//         // }
//         // game.flags.playerMonthly.fished.add(terrainIndex)
        
//         Dialog.inputInteger(engine.locale('timeDays'), availableDays).then((days) {
//           const lootbox = Lootbox()
//           let i = 0
//           Dialog.progress(engine.locale('fish'), () {
//             ++i
//             updateGame(ticks: kTicksPerDay)
//             changeStamina(hero, -kTicksPerDay)
//             switch (terrain.kind) {
//               kTerrainKindLake : {
//                 if (random.nextDouble() < kLakeFishProbability) {
//                   acquire(lootbox, Material.fish(), incurIncident: false)
//                 }
//               }
//               kTerrainKindSea : {
//                 if (random.nextDouble() < kSeaFishProbability) {
//                   acquire(lootbox, Material.fish(), incurIncident: false)
//                 }
//               }
//             }
//             if (i >= days) return false
//             return true
//           }).then((_) {
//             const incidentContent = engine.locale('characterFished', interpolations: [
//               hero.name,
//               '${terrain.left}, ${terrain.top}',
//               i,
//             ])
//             engine.debug(incidentContent)
//             // Incident(
//             //   subjectIds: [hero.id],
//             //   message: incidentContent,
//             //   isPrivate: true,
//             // )
//             if (lootbox.inventory.isEmpty) {
//               return Dialog.localeLines(['interactionGotNothing'], isHero: true)
//             } else {
//               loot(hero, lootbox)
//             }
//           })
//         })
//       }
//     }
//   })
// }

/// 这个函数时异步的
/// 但一般不要awai这个函数，因为有可能卡在打开物品展示对话框的地方
/// 直到关闭对话框才会返回并继续执行
async function onInteractMapObject(object, terrain) {
  engine.debug('正在和 Object [${object.id}] 互动。')
  if (object.useCustomLogic) {
    engine.debug('Object [${object.id}] 使用自定义交互逻辑')
    onWorldEvent('onInteractMapObject', object, terrain)
  } else {
    if (!object.isDiscovered) {
      discoverObject(object, terrain)
      Dialog.pushDialog('firstDiscover', interpolations: [object.name])
      await Dialog.execute()
    }
    switch (object.category) {
      kObjectCategoryPortal: onInteractPortal(object)
      kObjectCategoryWorldPortal: onInteractWorldPortal(object)
      kObjectCategoryTreasureBox: onInteractTreasureBox(object, terrain)
      kObjectCategorySwitch: onInteractSwitch(object, terrain)
      kObjectCategoryBed: onInteractBed(object)
      kObjectCategoryCharacter: {
        final character = game.characters[object.characterId]
        assert(character != null)
        onInteractCharacter(character)
      }
      kObjectCategoryEnemy: {
        assert(object.battleEntity != null)
        onInteractEnemy(object.battleEntity)
      }
      kObjectCategoryExpArray: onInteractExpArray(object)
      kObjectCategoryCardLibrary: onInteractCardLibraryDesk(object)
      kObjectCategoryMerchant: Game.showMerchant(object.merchant, useShard: object.useShard)
      kObjectCategorySpiritWell: onInteractSpiritWell(object)
      kObjectCategoryWorkbench: Game.showWorkbench()
      kObjectCategoryAlchemyFurnace: Game.showAlchemy()
      default: engine.error('不支持的地图交互物品类型: ${object.category}')
    }
  }
}

async function onInteractEnemy(battleEntity) {
  Game.showBattle(
    hero: hero,
    enemy: battleEntity,
  )
}

async function onInteractPortal(object) {
  if (object.targetTilePosition == null || object.targetTilePosition.left == null || object.targetTilePosition.top == null) {
    engine.error('传送点 ${object.id} 的目标位置未定义！')
    return
  }
  World.moveCameraToTilePosition(object.targetTilePosition.left, object.targetTilePosition.top, animated: false)
  engine.play('magic-smite-6012.mp3')
  await Future.delayed(0.5)
  if (object.darkenBeforeMove) {
    World.darkenAllTiles()
  }
  Player.setTo(object.targetTilePosition.left, object.targetTilePosition.top)
}

async function onInteractWorldPortal(object) {
  assert(universe.containsKey(object.worldId), object.worldId)
  // Dialog.pushBackground('black.png', fadeIn: true)
  engine.play('magic-smite-6012.mp3')
  Player.setTo(object.targetTilePosition.left, object.targetTilePosition.top, worldId: object.worldId, direction: 'south')
  await Future.delayed(0.5)
  World.switchWorld(object.worldId)
  // await Dialog.execute()
}

async function onInteractTreasureBox(object, terrain) {
  if (object.isOpened) return

  object.isOpened = true
  engine.play('dooropened-103851.mp3')
  terrain.overlaySprite ??= {}
  Object.assign(terrain.overlaySprite, {sprite: kSpriteTreasureBoxOpened})
  World.updateTerrainOverlaySprite(terrain.left, terrain.top)
  // await Future.delayed(0.5)
  final items = createLoot(object.items)
  for (final item in items) {
    await Player.acquire(item)
  }
  engine.play('pickup_item-64282.mp3')
  Game.promptItems(items)
}

async function onInteractSwitch(object, terrain) {
  if (object.isOn) {
    Dialog.pushDialog('hint_switch_alreadyOn', isHero: true)
    Dialog.execute()
    return
  }

  object.isOn = true
  engine.play('stone-push-37412.mp3')
  Dialog.pushDialog('hint_switch', isHero: true)
  Dialog.execute()
  terrain.overlaySprite = {sprite: kSpriteSwitchOn} 
  World.updateTerrainOverlaySprite(terrain.left, terrain.top)
  
  // final openedRoadTile = getTerrainByWorldPosition(targetTilePosition.left, targetTilePosition.top)
  // openedRoadTile.spriteIndex = kSpriteDungeonStonePavedTile
  // World.updateTerrainSprite(targetTilePosition.left, targetTilePosition.top)
}

async function onInteractBed(object) {
  if (hero.life >= hero.stats.lifeMax) {
    Dialog.pushDialog('hint_fullHPRest')
    await Dialog.execute()
    return
  }

  if (object.isUsed) {
    Dialog.pushDialog('hint_usedObject')
    await Dialog.execute()
  } else {
    object.isUsed = true
    Dialog.pushBackground('black.png', isFadeIn: true)
    Dialog.pushTask(async () {
      await Future.delayed(0.8)
    })
    Dialog.popBackground(isFadeOut: true)

    let life = hero.life
    let newLife = life + (hero.stats.lifeMax * 0.5).round()
    if (newLife > hero.stats.lifeMax) {
      newLife = hero.stats.lifeMax
    }
    hero.life = newLife
    engine.debug('休息恢复了 ${newLife - life} 生命值')
    Game.updateHero()

    await Dialog.execute()
  }
}

async function onInteractExpArray(object) {
  Dialog.pushDialog('hint_expArray')
  await Dialog.execute()
  Game.showCultivation(location: object)
}

async function onInteractCardLibraryDesk(object) {
  Dialog.pushDialog('hint_cardLibraryStele')
  await Dialog.execute()
  Game.showLibrary(
    enableCardCraft: object.enableCardCraft,
    enableScrollCraft: object.enableScrollCraft,
  )
}

async function onInteractSpiritWell(object) {
  if (object.isUsed) {
    Dialog.pushDialog('hint_dungeon_spiritWell_description2')
    await Dialog.execute()
    return
  }

  let hasVacancy = false
  for (final itemId in hero.equipments.keys) {
    if (hero.equipments[itemId] == null) {
      hasVacancy = true
      break
    }
  }

  final r = Random()

  final items = []
  final spiritWellDropRoll = r.nextDouble()
  if (hasVacancy && spiritWellDropRoll < kSpiritWellProbabilitySpirit) {
    final spirit = StatusSpirit(rank: object.rank)
    await Player.acquire(spirit)
    Player.equip(spirit)
    engine.play('spell-of-healing-876.mp3')
    Dialog.pushDialog('hint_dungeon_spiritWell_use')
    await Dialog.execute()
    items.add(spirit)
  } else if (spiritWellDropRoll < kSpiritWellProbabilityCraftMaterial) {
    let craftMaterialTypeRoll = r.nextDouble()
    let craftMaterial
    if (craftMaterialTypeRoll < kRewardProbabilityCraftMaterialUpgradeRank) {
      craftMaterial = createItemByPrototype('craftmaterial_upgradeRank${r.nearInt(hero.rank)}')
    } else if (craftMaterialTypeRoll < kRewardProbabilityCraftMaterialRerollAffix) {
      craftMaterial = createItemByPrototype('craftmaterial_rerollAffix')
    } else if (craftMaterialTypeRoll < kRewardProbabilityCraftMaterialReplaceAffix) {
      craftMaterial = createItemByPrototype('craftmaterial_replaceAffix')
    } else {
      craftMaterial = createItemByPrototype('craftmaterial_addAffix')
    }
    rewards.add(craftMaterial)
  } else {
    final shard = r.nextInt(hero.level + 1) + 1
    final shardPack = Materialpack(kind: 'shard', amount: shard)
    items.add(shardPack)
  }

  Game.promptItems(items)
  
  object.isUsed = true
}

const _kMinSizeforFishTile = 16
const _kMinSizeforStormTile = 80
const _kMinSizeforSpiritTile = 120

function setFishTile(terrain) {
  engine.debug('鱼群正在在 [${terrain.left},${terrain.top}] 周围活跃。')
  terrain.flags.isFishGathering = true
  terrain.overlaySprite ??= {}
  Object.assign(terrain.overlaySprite, {animation: {path: 'object/animation/fishZone.png'}})
  World.updateTerrainOverlaySprite(terrain.left, terrain.top)
  world.fishTileIndexes.add(terrain.index)
}

function setStormTile(terrain) {
  engine.debug('暴风雨正在 [${terrain.left},${terrain.top}] 周围活跃。')
  terrain.flags.isInStorm = true
  terrain.overlaySprite ??= {}
  Object.assign(terrain.overlaySprite, {animation: {path: 'object/animation/stormZone.png'}})
  World.updateTerrainOverlaySprite(terrain.left, terrain.top)
  world.stormTileIndexes.add(terrain.index)
}

// function setSpiritTile(terrain) {
  // engine.debug('天地灵气正在 [${terrain.left},${terrain.top}] 喷涌。')
  // terrain.flags.isSpiritSurging = true
  // terrain.overlaySprite ??= {}
  // Object.assign(terrain.overlaySprite, {animation: {path: 'object/animation/spirit.png'}})
  // World.updateTerrainOverlaySprite(terrain.left, terrain.top)
  // game.spiritTileIndexes.add(terrain.index)
// }

// 每个tick检查一次当前是否有婴儿出生
function handleBabies {
  const pendingRemovedIds = Set()
  for (const baby of game.babies) {
    final babyTime = game.timestamp - baby.conceptionTimestamp
    if (babyTime < baby.pregnancyTime) continue
    const mother = game.characters[baby.motherId]
    if (mother.isPregnant) {
      mother.isPregnant = false
      mother.carrying.add(baby.id)
    }
    if (babyTime > baby.pregnancyTime + kChildTime) {
      mother.carrying.remove(baby.id)
      assert(mother.homeLocationId != null)
      const location = game.locations[mother.homeLocationId]
      const character = Character(
        surName: baby.surName,
        generateName: baby.generateName,
        shorname: baby.shorname,
        isFemale: baby.isFemale,
        birthTimestamp: baby.conceptionTimestamp + baby.pregnancyTime,
        locationId: location.id,
        isNewBorn: true,
        motherId: baby.motherId,
        fatherId: baby.fatherId,
        relationships: baby.relationships,
        bonds: baby.bonds,
      )
      pendingRemovedIds.add(baby.id)
    }
  }
  for (const id in pendingRemovedIds) {
    delete game.babies[id]
  }
}

/// 动态计算角色声名：对此人的评价大于等于零的人数(n)除以世界总人口(p)。
function calculateCharacterFame(character) {
  let n = 0
  for (final otherChar of game.characters) {
    if (otherChar.id == character.id) {
      continue
    }
    let bond = otherChar.bonds[character.id]
    if (bond && bond.score >= 0) {
      n += 1
    }
  }
  character.fame = (n / game.characters.length * 100).truncate()
}

/// 动态计算角色恶名：对此人的评价小于零的人数(n)除以世界总人口(p)。
function calculateCharacterInfamy(character) {
  let n = 0
  for (final otherChar of game.characters) {
    if (otherChar.id == character.id) {
      continue
    }
    let bond = otherChar.bonds[character.id]
    if (bond && bond.score < 0) {
      n += 1
    }
  }
  character.infamy = (n / game.characters.length * 100).truncate()
}
