
let game
let universe
let world
let history
let hero

/// 仅在特定场景中会被赋值
let location
let terrain
let merchant
let enemy
let self
let opponent
let battleFlags

const kNpcIds = [
  'servant',
  'servant_young',
  'guard',
]

/// 玩家每个月的互动操作记录，月初会重置
struct PlayerMonthly {
  constructor {
    // 战斗相关
    // 本月鉴定敌人卡牌数量
    this.identifiedEnemyCards = 0
    // 本月是否已经参加过门派会议
    this.attendedMeeting = false

    // 对其他角色操作
    this.gifted = []
    this.attacked = []
    this.stolen = []

    // 婚姻关系的嫁娶和离婚
    this.proposed = []

    // 拜师和收徒的尝试
    this.baishi = []
    this.shoutu = []

    // 师徒关系的传授功法
    this.consulted = []
    this.tutored = []

    // 组织的加入
    this.enrolled = []

    // 门派成员的招募
    this.recruited = []

    // 对某个建筑操作
    // 租用过的场地，在月底之前可以进行生产或使用
    this.rented = []

    // 对资源进行买卖会影响价格
    // 这里保存的除了进行过买卖的地点，还会保存交易的总数量，每次交易都会累加
    this.tradedMaterials = {}
  }
}

struct GameData {
  constructor ({
    saveName,
    mainWorldId,
    enableTutorial = true,
  }) {
    assert(saveName != null && saveName.isNotEmpty, '创建游戏时 saveName 不能为空!')
    this.saveName = saveName
    this.mainWorldId = mainWorldId
    this.enableTutorial = enableTutorial

    this.isNewGame = true
    this.currentWorldId = null
    this.heroId = null
    this.timestamp = 0

    // 游戏内的事件标记，
    this.flags = {
      // 游戏本身逻辑所用到的一些事件检查选项
      // 例如每个月是否进行了某个动作之类
      // 这里的事件标记会在每个月1日重置
      playerMonthly: PlayerMonthly(),
      tutorial: {}, // 新手教程
      // 试炼地牢，每次进入地牢前会重置
      trial: {},
      // 秘境地牢，每次进入地牢前会重置
      dungeon: {},
      // 门派事件标记，每次加入门派会重置
      organizations: {},
    }

    this.npcs = {}
    this.deceased = {}
    this.babies = {}
    this.characters = {}
    this.organizations = {}
    // 地图上的城市、场景
    this.locations = {}

    // 家族信息
    // key 是家族的 id，值是一个结构体数组
    // 值的key是人物的 id，值是 MemberRankData 数据，含角色的 generation 和 peer
    this.families = {}
    // 师徒传承信息
    // key 是师徒传承的 id，值是一个结构体数组
    // 值的 key 是人物的 id，值是 SectMember 数据，含角色的 generation 和 peer
    this.sects = {}
    // 门派之间的外交关系
    // key 是外交关系的 id，值是 Diplomacy 数据
    // 在门派自己的数据中保存的则是对方门派和外交关系 id 的对应关系表
    this.diplomacies = {}
    
    // 本次游戏加载的 module，这里是元数据和事件函数绑定的空间
    this.mods = {
      // meta: {} // 模组元数据
      // events: {} // 模组事件处理函数
    }
  }
}

/// 创建新游戏，重置所有状态，返回game
function createGame(saveName, {
  seed: integer,
  mainWorldId: string,
  enableTutorial = true
}) {
  engine.debug('准备开始新游戏')
  game = GameData(
    saveName: saveName,
    mainWorldId: mainWorldId,
    enableTutorial: enableTutorial
  )
  setRandomSeed(seed ?? crypto.crcInt('heavenly_tribulation_2025'))
  universe = {}
  history = {}
  world = null
  hero = null
  
  for (final npcId in kNpcIds) {
    Npc(
      id: npcId,
      nameId: npcId,
      icon: 'illustration/npc/${npcId}_head.png',
      illustration: 'illustration/npc/${npcId}.png',
    )
  }
}

function resetPlayerMonthly() {
  game.flags.playerMonthly = PlayerMonthly()
}

function monthlyActionContains(actionId, targetId) {
  return game.flags.playerMonthly[actionId].contains(targetId)
}

function getTimeData() {
  return {
    ticksOfYear: ticksOfYear,
    ticksOfMonth: ticksOfMonth,
    ticksOfDay: ticksOfDay,
    year: year,
    month: month,
    day: day,
    timeOfDay: timeOfDay,
  }
}

const kTimeOfDay = {
  '1': 'morning',
  '2': 'afternoon',
  '3': 'evening',
  '4': 'midnight',
}

/// 载入游戏数据，返回game
function loadGameFromJsonData({
  gameData,
  universeData,
  historyData,
  // isEditorMode,
}) -> List {
  game = Object.fromJSON(gameData)
  game.isNewGame ??= true

  universe = Object.create(universeData)
  history = Object.create(historyData)
  world = universe[game.currentWorldId]

  assert(world != null, 'world id null, currentWorldId: ${game.currentWorldId}')
  
  engine.debug('当前世界: [${world.id}]')

  if (game.heroId != null) {
    assert(game.characters.containsKey(game.heroId))
    hero = game.characters[game.heroId]
    engine.debug('当前英雄: [${hero.name}]')
  }
}

function addWorld(newWorld) {
  world = universe[newWorld.id] = newWorld
  game.currentWorldId = newWorld.id
}

function getMapComponents() {
  return world.components
}

/// 为地图创建显示组件，注意这里仅限非角色类装饰性数据
function createMapComponent(componentData, left, top) {
  assert(componentData.entityType == null)
  final component = Object.fromJSON(componentData)
  engine.debug('添加显示组件：[${component.id}]')
  component.worldPosition = { left, top }
  world.components.add(component)
  return component
}

function removeMapComponentByPosition(left, top) {
  engine.debug('移除显示组件，位于: [${left}, ${top}]')
  world.components.removeWhere((c) => c.worldPosition.left == left && c.worldPosition.top == top)
}

function removeMapComponentById(id) {
  engine.debug('移除显示组件，id: [${id}]')
  world.components.removeWhere((c) => c.id == id)
}

function setHero(id: string) {
  assert(game.characters.containsKey(id))
  hero = game.characters[id]
  game.flags.playerMonthly = PlayerMonthly()

  Player.calculateStats()
  engine.debug('设置当前玩家人物为 [${hero.id}]。')
  game.heroId = id

  hero = game.characters[id]

  if (game.enableTutorial) {
    /// 用于新手教程的系统角色
    if (game.npcs['xitong'] == null) {
      game.npcs['xitong'] = Npc(
        id: 'xitong',
        name: engine.locale('npc_xitong_name'),
        icon: 'story/illustration/sitone_head.png',
        illustration: 'story/illustration/sitone.png',
        useCustomLogic: true,
      )
    }
    final home = game.locations[hero.homeSiteId]
    home.npcId = 'xitong'
  }

  // 重置主角的战斗卡牌数据
  hero.cardLibrary = {}
  hero.battleDecks = []
  hero.battleDeckIndex = -1

  Game.updateHero()
}

function randomizeHeroWorldPosition() {
  hero.locationId = null
  final location = game.locations[hero.homeLocationId]
  final availableTiles = location.territoryIndexes.where((index) {
    final tile = world.terrains[index]
    return !tile.isWater
  })
  if (availableTiles.isEmpty) {
    hero.worldPosition = {
      left: location.worldPosition.left,
      top: location.worldPosition.top,
    }
  } else {
    final randomTileIndex = random.nextIterable(availableTiles)
    final randomTile = world.terrains[randomTileIndex]
    hero.worldPosition = {
      left: randomTile.left,
      top: randomTile.top,
    }
  }
}

function setHeroWorldId(worldId) {
  hero.worldId = worldId
}

function getHeroHomeLocation({worldId}) {
  // let atWorld = worldId != null ? universe[worldId] : world
  if (hero.homeLocationId) {
    assert(game.locations.containsKey(hero.homeLocationId))
    return game.locations[hero.homeLocationId]
  }
}

function getHeroHomeSite({worldId}) {
  // let atWorld = worldId != null ? universe[worldId] : world
  if (hero.homeSiteId) {
    assert(game.locations.containsKey(hero.homeSiteId))
    return game.locations[hero.homeSiteId]
  }
}

function getHeroOrganization {
  if (hero.organizationId) {
    return game.organizations[hero.organizationId]
  } else {
    return null
  }
}

function getHeroLightedArea {
  return hero.stats.lightRadius
}

// function getHeroCultivationGenre {
//   return hero.cultivationGenre
// }

function getTerrainByIndex(index, {worldId}) {
  let atWorld = worldId != null ? universe[worldId] : world
  return world.terrains[index]
}

function getTerrainByWorldPosition(left, top, {worldId}) {
  let atWorld = worldId != null ? universe[worldId] : world
  return world.terrains[tilePos2Index(left, top, world.width)]
}

function getWorldIds {
  return universe.keys
}

function setCurrentWorld(id) {
  assert(universe.containsKey(id), id)
  world = universe[id]
  game.currentWorldId = id
  engine.debug('设置当前世界为: [${id}]')

  return world
}

function deleteWorldById(id) {
  assert(world.id != id)
  engine.warn('删除世界数据: [${id}]')
  universe.remove(id)
}

function getWorldSize({worldId}) {
  let atWorld = worldId != null ? universe[worldId] : world
  return {
    width: atWorld.width,
    height: atWorld.height,
  }
}

function getZones({worldId}) {
  let atWorld = worldId != null ? universe[worldId] : world
  return atWorld.zones.values
}

function getZoneById(id: string, {worldId}) {
  let atWorld = worldId != null ? universe[worldId] : world
  return atWorld.zones[id]
}

function addObject(object, {worldId}) {
  let atWorld = worldId != null ? universe[worldId] : world
  atWorld.objects[object.id] = object
}

function removeObjectById(id, {worldId}) {
  let atWorld = worldId != null ? universe[worldId] : world
  delete atWorld.objects[id]
}

function getObjects({worldId}) {
  let atWorld = worldId != null ? universe[worldId] : world
  return atWorld.objects.values
}

function getObjectById(id: string, {worldId}) {
  let atWorld = worldId != null ? universe[worldId] : world
  return atWorld.objects[id]
}

function hasObject(id: string, {worldId}) {
  let atWorld = worldId != null ? universe[worldId] : world
  return atWorld.objects[id] != null
}

function getNameFromId(id, [orElse = 'null']) {
  if (id != null) {
    return id.split('.').last
  } else {
    return engine.locale(orElse)
  }
}

async function onNewGame() {
  game.isNewGame = false
  await onWorldEvent('onNewGame')
}

namespace Game {

  external function datetime()
  
  external function updateHero()

  external function updateLocation(location)

  external function pushScene(sceneId, {category, arguments})

  external function switchScene(sceneId, {arguments, restart = false})

  external function popScene({clearCache: bool = false})

  external function popSceneTill(sceneId, {clearCache: bool = false})

  external function pushWorld(worldId, {clearCache: bool = false})
  
  external function updateGame({
    tick = 1,
    timeflow = true,
    udpateWorldMap = true,
    forceUpdate = false,
  })

  external function updateHistory()

  external function updateDungeon(dungeon)

  external function tryEnterDungeon({
    rank,
    isCommon = true,
    dungeonId = 'dungeon_1',
    pushScene = true,
  })

  external function onDying()

  external function characterAllocateSkills(character, {rejuvenate = false} )

  external function updateNpcs(npcs)

  external function hideNpc(id)

  external function promptItems(items: Iterable)

  external function promptJournal(journal, [selections])

  external function promptNewRank(rank)

  external async function selectCharacter([ids])

  external async function selectLocation([ids])

  external async function selectOrganization([ids])

  external function selectItem({
    character,
    title,
    filter,
    multiSelect: bool = false,
  }) -> Iterable

  external function showHeroInfo([value: bool = true])

  external function showTimeflow(max)
  
  external function showLibrary({enableCardCraft: bool = false, enableScrollCraft: bool = false})
  
  external function showCultivation({location, enableCultivate: bool = false})

  external function showPrebattle(enemyData, {
    // prebattlePreventClose: bool = false,
    onBattleStart,
    onBattleEnd,
    background,
  })

  external function showBattle({
    hero,
    enemy,
    isSneakAttack: bool = false,
    // isAutoBattle: bool = false,
    onBattleStart,
    onBattleEnd,
  })

  external function showMerchant(merchantData, {
    depositMode = false,
    materialMode = false,
    useShard = false,
    priceFactor,
    filter,
  })

  external function showWorkbench()

  external function showAlchemy()
}
