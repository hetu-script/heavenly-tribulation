
async function onRested() {
  if (game.enableTutorial) {
    if (game.flags.tutorial.rested) return

    if (hero.life >= hero.stats.lifeMax) {
      game.flags.tutorial.rested = true
      Player.progressJournalById('sandboxTutorial')
    }
  }
}

/// 进入据点场景
/// 这个接口的逻辑较复杂，为了避免 bug 并不会一次就触发所有的事件
/// 每次触发某个事件后，就会返回 true，这样就会跳过后续其他逻辑的判断
async function onAfterEnterLocation(location) -> bool {
  // 游戏教程的提示
  if (game.enableTutorial) {
    if (location.id == hero.homeLocationId) {
      if (!game.flags.tutorial.homeLocation) {
        // 提示进入家宅
        game.flags.tutorial.homeLocation = true
        
        dialog.pushDialog('tutorial_homeLocation_line_1', npc: game.npcs['xitong'])
        await dialog.execute()
        return true
      } else if (!game.flags.tutorial.dummyPractice && game.flags.tutorial.rested) {
        dialog.pushDialog('tutorial_homeLocation_line_3', npc: game.npcs['xitong'])
        await dialog.execute()

        final dummy = BattleEntity(
          name: 'wooden_dummy',
          isFemale: false,
          level: 0,
          rank: 0,
          icon: 'illustration/npc/wooden_dummy_head.png',
          skin: 'wooden_dummy',
          attributes: {
            'charisma': 0,
            'wisdom': 0,
            'luck': 0,
            'spirituality': 0,
            'dexterity': 0,
            'strength': 20,
            'willpower': 0,
            'perception': 0,
          },
          cultivationFavor: '',
          generateDeck: false,
        )
        generateBattleDeck(dummy,
          cardInfoList: [
            {'affixId': 'blank_default'},
            {'affixId': 'blank_default'},
            {'affixId': 'blank_default'},
          ]
        )

        Game.showPrebattle(
          dummy,
          loseOnEscape: false,
          onBattleEnd: async function [onBattleEnd] (battleResult, roundCount) {
            if (!battleResult) return

            game.flags.tutorial.dummyPractice = true
            Player.progressJournalById('sandboxTutorial')

            dialog.pushDialog('tutorial_homeLocation_line_4', npc: game.npcs['xitong'])
            await dialog.execute()
          }
        )
        return true
      }
    } else if (location.id == hero.homeSiteId) {
      if (!game.flags.tutorial.homeSite) {
        // 提示休息
        game.flags.tutorial.homeSite = true
        
        dialog.pushDialog('tutorial_homeLocation_line_2', npc: game.npcs['xitong'])
        await dialog.execute()
        return true
      }
    }
  }

  // 处理角色初入门派的报告，以及门派每月例会
  if (hero.organizationId != null) {
    final organization = game.organizations[hero.organizationId];
    final memberData = organization.membersData[hero.id];
    assert(memberData != null,
        'Member data not found in organization [${organization.id}], member id: ${hero.id}');
    final reportSiteId = memberData.reportSiteId;
    if (reportSiteId == location.id) {
      final superior = game.characters[memberData.superiorId];
      assert(superior != null,
          'character not found, id: ${memberData.superiorId}');
      final initiationQuest = hero.journals.organizationInitiation;
      if (initiationQuest?.stage == 0) {
        characterMet(hero, superior)
        dialog.pushDialog(
          'hint_organization_initiation2',
          character: superior,
        );
        await dialog.execute();

        final itemsInfo = [
          {
            'type': 'potion',
            'rank': hero.rank,
          },
          {
            'type': 'cardpack',
            'genre': organization['genre'],
            'rank': hero.rank,
          },
        ];
        final items = await Player.loot(itemsInfo);
        await Game.promptItems(items);
        Player.progressJournalById('organizationInitiation');
        await Game.promptJournal(initiationQuest);
        return true;
      } else {
        final monthly = game.flags.monthly;
        final day = toDay(game.timestamp)
        if (monthly.attendedMeeting != true && day < 5) {
          monthly.attendedMeeting = true;

          Game.showMeeting(organization, location, superior);
          return true;
        }
      }
    }
  }

  final questJournals = hero.journals.values.where((journal) =>
   !journal.isFinished && journal.quest != null
  )
  for (final journal in questJournals) {
    if (journal.quest.reportSiteId == location.id) {
      final endTime = journal.timestamp + journal.quest.timeLimit
      let isLate = game.timestamp > endTime
      switch (journal.quest.kind) {
        case 'deliver_material', 'deliver_item': {
          final receiverId = journal.quest.receiverId
          final receiver = game.characters[receiverId]
          final success = Player.deliver(journal.quest.package)
          characterMet(receiver, hero)
          if (success) {
            Player.progressJournalById(journal.id)
            if (isLate) {
              dialog.pushDialog('quest_deliver_late_success', character: receiver);
              await dialog.execute();
            } else {
              dialog.pushDialog('quest_deliver_success', character: receiver);
              await dialog.execute();
            }
            final items = await Player.loot(journal.quest.reward)
            Game.promptItems(items)
          } else {
            Player.progressJournalById(journal.id, stage: 2)
            if (isLate) {
              dialog.pushDialog('quest_late_failed', character: receiver);
              await dialog.execute()
            } else {
              dialog.pushDialog('quest_unfinished', character: receiver, interpolations: [journal.title]);
              await dialog.execute()
            }
          }
          return true
        }
        case 'escort': {
          final success = Player.deliver(journal.quest.package)
          if (success) {
            Player.progressJournalById(journal.id)
            final escortType = journal.quest.escortType;
            final escorteeId = journal.quest.package.characterId;
            if (isLate) {
              dialog.pushDialog('quest_escort_late_success_${escortType}', characterId: escorteeId);
              await dialog.execute();
            } else {
              dialog.pushDialog('quest_escort_success_${escortType}', characterId: escorteeId);
              await dialog.execute();
            }
            Game.updateNpcsAtLocation(location)
            final items = await Player.loot(journal.quest.reward)
            Game.promptItems(items)
          }
          return true
        }
        case 'guard_site': {
          return true
        }
        case 'purchase_material': {
          final success = Player.deliver(journal.quest.requirement)
          if (success) {
            Player.progressJournalById(journal.id)
            if (isLate) {
              dialog.pushDialog('quest_purchase_late_success', npcId: location.npcId);
              await dialog.execute();
            } else {
              dialog.pushDialog('quest_purchase_success', npcId: location.npcId);
              await dialog.execute();
            }
            final items = await Player.loot(journal.quest.reward)
            Game.promptItems(items)
          } else {
            if (isLate) {
              Player.exhaust(journal.quest.budget.kind, journal.quest.budget.amount, forceExhaust: true)
              Player.progressJournalById(journal.id, stage: 2)
              dialog.pushDialog('quest_purchase_late_failed', npcId: location.npcId);
              await dialog.execute();
            } else {
              dialog.pushDialog('quest_unfinished', npcId: location.npcId, interpolations: [journal.title]);
              await dialog.execute();
            }
          }
          return true
        }
        case 'purchase_item': {
          if (isLate) {
            dialog.pushDialog('quest_purchase_late_greeting', npcId: location.npcId);
            await dialog.execute();
          } else {
            dialog.pushDialog('quest_purchase_greeting', npcId: location.npcId);
            await dialog.execute();
          }
          final selectedItems = await Game.selectItem(
            character: hero,
            filter: journal.quest.requirement,
            multiSelect: false,
          )
          if (selectedItems.isNotEmpty) {
            Player.progressJournalById(journal.id)
            final item = selectedItems.first
            Player.lose(item)
            if (isLate) {
              dialog.pushDialog('quest_purchase_late_success', npcId: location.npcId);
              await dialog.execute();
            } else {
              dialog.pushDialog('quest_purchase_success', npcId: location.npcId);
              await dialog.execute();
            }
            final items = await Player.loot(journal.quest.reward)
            Game.promptItems(items)
          } else {
            if (isLate) {
              Player.exhaust(journal.quest.budget.kind, journal.quest.budget.amount, forceExhaust: true)
              Player.progressJournalById(journal.id, stage: 2)
              dialog.pushDialog('quest_purchase_late_failed', npcId: location.npcId);
              await dialog.execute();
            } else {
              dialog.pushDialog('quest_unfinished', npcId: location.npcId, interpolations: [journal.title]);
              await dialog.execute();
            }
          }
          return true
        }
        case 'discover_location': {
          final targetLocationId = journal.quest.targetLocationId
          final targetLocation = game.locations[targetLocationId]
          if (targetLocation.isDiscovered) {
            Player.progressJournalById(journal.id)
            if (isLate) {
              dialog.pushDialog('quest_discover_late_success', npcId: location.npcId);
              await dialog.execute();
            } else {
              dialog.pushDialog('quest_discover_success', npcId: location.npcId,
                interpolations: [targetLocation.name],
              );
              await dialog.execute();
            }
            final items = await Player.loot(journal.quest.reward)
            Game.promptItems(items)
          } else {
            if (isLate) {
              Player.progressJournalById(journal.id, stage: 2)
              dialog.pushDialog('quest_discover_late_failed', npcId: location.npcId);
              await dialog.execute();
            } else {
              dialog.pushDialog('quest_unfinished', npcId: location.npcId, interpolations: [journal.title]);
              await dialog.execute();
            }
          }
          return true
        }
      }
    }
  }
}
