// import '../entity/item/item.ht'
// import '../world/dungeon.ht'

const _kBasicRooms = {
  '0': 'chest',
  '1': 'enemy',
  '2': '3portal',
  '3': 'elite',
  '4': 'encampment',
  '5': 'boss',
  '14': 'exit',
}

const _kNormalRooms = {
  '0': 'chest',
  '1': 'enemy',
  '2': '3portal',
  '3': 'enemy',
  '4': '3portal',
  '5': 'enemy',
  '6': 'encampment',
  '7': 'elite',
  '8': '3portal',
  '9': 'enemy',
  '10': 'encampment',
  '11': 'enemy',
  '12': 'encampment',
  '13': 'boss',
  '14': '3exit',
}

const _kStartTile = {
  left: 8,
  top: 9,
}
const _kReturnTile = {
  left: 8,
  top: 10,
}
const _kCenterTile = {
  left: 8,
  top: 7,
}
const _kPortal1Tile = {
  left: 8,
  top: 4,
}
const _kPortal2Tile = {
  left: 4,
  top: 6,
}
const _kPortal3Tile = {
  left: 12,
  top: 6,
}
const _kFunction1 = {
  left: 6,
  top: 6,
}
const _kFunction2 = {
  left: 10,
  top: 6,
}
const _kFunction3 = {
  left: 6,
  top: 8,
}
const _kFunction4 = {
  left: 10,
  top: 8,
}

const _kDungeonEnemyLevelBonus = {
  tutorial: {
    '2': 1,
    '3': 2,
    '5': 3,
  }
  normal: {
    '2': 1,
    '3': 2,
    '4': 3,
    '5': 4,
    '7': 5,
    '8': 6,
    '9': 7,
    '10': 8,
    '13': 10,
  },
}

const _kEncampmentKinds = [
  'exparray',
  'cardlibrary',
  // 'workbench',
  // 'alchemy_furnace',
]

const _kMerchantKinds = [
  'smith',
  'enchanter',
  'alchemist',
  'bookdealer',
  // 'arrayMaster',
]

const _kEncounterKinds = [
  'spiritWell'
]

function _addEncampment() {
  final collectableLight = (expForLevel(hero.level) ~/ 4) ~/ hero.stats.expCollectEfficiency
  addExpArray(
    _kFunction1,
    collectableLight: collectableLight,
  )
  addCardLibraryStele(
    _kFunction2,
    enableCardCraft: true,
    enableScrollCraft: true,
  )
  addRestBed(_kFunction3)
  addMerchant(
    _kFunction4,
    objectId: 'merchant',
    name: engine.locale('merchant'),
    sprite: 'object/characterMan31.png',
    rank: game.dungeon.rank,
    money: 100000,
    shard: 100000,
    category: ['weapon', 'armor', 'jewelry', 'talisman', 'potion', 'cardpack'],
    itemCount: 8 + game.dungeon.rank,
    useShard: game.dungeon.rank > 0,
  )
}

function _addRandomMerchant() {
  final merchantKind = _kMerchantKinds.random
  switch (merchantKind) {
    'smith': {
      addMerchant(
        _kCenterTile,
        objectId: 'merchant',
        name: engine.locale('smith'),
        sprite: 'object/characterMan31.png',
        rank: game.dungeon.rank,
        money: 100000,
        shard: 100000,
        category: ['weapon', 'armor'],
        itemCount: 5 + game.dungeon.rank,
        useShard: game.dungeon.rank > 0,
      )
    }
    'enchanter': {
      addMerchant(
        _kCenterTile,
        objectId: 'merchant',
        name: engine.locale('enchanter'),
        sprite: 'object/characterMan31.png',
        rank: game.dungeon.rank,
        money: 100000,
        shard: 100000,
        category: ['jewelry', 'talisman'],
        itemCount: 5 + game.dungeon.rank,
        useShard: game.dungeon.rank > 0,
      )
    }
    'alchemist': {
      addMerchant(
        _kCenterTile,
        objectId: 'merchant',
        name: engine.locale('alchemist'),
        sprite: 'object/characterMan31.png',
        rank: game.dungeon.rank,
        money: 100000,
        shard: 100000,
        category: ['potion'],
        itemCount: 5 + game.dungeon.rank,
        useShard: game.dungeon.rank > 0,
      )
    }
    'bookdealer': {
      addMerchant(
        _kCenterTile,
        objectId: 'merchant',
        name: engine.locale('bookdealer'),
        sprite: 'object/characterMan31.png',
        rank: game.dungeon.rank,
        money: 100000,
        shard: 100000,
        category: ['cardpack'],
        itemCount: 5 + game.dungeon.rank,
        useShard: game.dungeon.rank > 0,
      )
    }
  }
}

function _addPortalByCategory(tilePosition, {id = 'portal1', tilePosition, category}) {
  tilePosition ??= _kPortal1Tile
  assert(tilePosition?.left != null && tilePosition?.top != null, '_addPortalByCategory error: tilePosition is null')
  let hoverContent
  category ??= 'enemy'
  switch (category) {
    'encampment': {
      hoverContent = engine.locale('dungeon_encampment_description')
    }
    'merchant': {
      hoverContent = engine.locale('dungeon_merchant_description')
    }
    'encounter': {
      hoverContent = engine.locale('dungeon_encounter_description')
    }
    'boss': {
      hoverContent = engine.locale('dungeon_boss_description')
    }
    'elite': {
      hoverContent = engine.locale('dungeon_elite_description')
    }
    'exit': {
      hoverContent = engine.locale('dungeon_exit_description')
    }
    'replay': {
      hoverContent = engine.locale('dungeon_replay_description')
    }
    'nextLevel': {
      hoverContent = engine.locale('dungeon_nextLevel_description')
    }
  }
  addPortal(
    tilePosition,
    objectId: id,
    useCustomLogic: true,
    hoverContent: hoverContent,
  )
}

function _addDebris() {
  addOverlaySprite(_kPortal2Tile, {
    sprite: "object/stoneDebris.png",
  })
  addOverlaySprite(_kPortal3Tile, {
    sprite: "object/stoneDebris.png",
  })
}

function _addPortalByNextRoomType(nextRoomType) {
  switch (nextRoomType) {
    'encampment': {
      _addPortalByCategory(_kPortal1Tile, category: 'encapment')
    }
    'merchant': {
      _addPortalByCategory(_kPortal1Tile, category: 'merchant')
    }
    'encounter': {
      _addPortalByCategory(_kPortal1Tile, category: 'encounter')
    }
    'enemy': {
      _addPortalByCategory(_kPortal1Tile, category: 'enemy')
    }
    'elite': {
      _addPortalByCategory(_kPortal1Tile, category: 'elite')
    }
    'boss': {
      _addPortalByCategory(_kPortal1Tile, category: 'boss')
    }
    '3portal': {
      _addPortalByCategory(_kPortal1Tile, category: 'enemy')
      _addPortalByCategory(_kPortal2Tile, id: 'portal2', category: 'merchant')
      _addPortalByCategory(_kPortal3Tile, id: 'portal3', category: 'encounter')
    }
    '3exit': {
      _addPortalByCategory(_kPortal1Tile, category: 'exit')
      _addPortalByCategory(_kPortal2Tile, id: 'portal2', category: 'replay')
      _addPortalByCategory(_kPortal3Tile, id: 'portal3', category: 'nextLevel')
    }
  }
}

function _prepareMap() {
  engine.debug('生成地牢：当前难度：${game.dungeon.level} 房间编号：${game.dungeon.room}')
  game.dungeon.buildCompleted = true
  game.dungeon.isElite = false
  game.dungeon.isBoss = false
  /// 清理所有的地块贴图和临时对象，还原到空地图
  world.objects = {}
  for (final tile in world.terrains) {
    tile.isNonEnterable = false
    tile.overlaySprite = {}
    tile.objectId = null
    World.updateTerrainData(tile.left, tile.top, updateOverlaySprite: true)
  }

  let rankString = engine.locale('cultivationRank_${game.dungeon.rank}') + engine.locale('rank2') + engine.locale('dungeon')
  let sceneId = '${rankString}-${game.dungeon.level + 1}-${game.dungeon.room + 1}'
  World.promptTextBanner(sceneId)

  Game.updateDungeon(game.dungeon)

  let roomInfo = game.dungeon.isBasic ? _kBasicRooms : _kNormalRooms

  assert(game.dungeon.room <= game.dungeon.roomMax &&
        roomInfo.contains(game.dungeon.room.toString()) &&
        roomInfo.contains((game.dungeon.room + 1).toString()), 
    '房间编号超出范围：${game.dungeon.room}')

  final nextRoomType = roomInfo[game.dungeon.room + 1]
  /// 用随机遭遇填充地图
  if (game.dungeon.isBasic) {
    switch (game.dungeon.room + 1) {
      1: {
        _addPortalByNextRoomType(nextRoomType)
        _addDebris()
        // 第一层固定是一个恢复生命的床，没有敌人。
        addRestBed(_kCenterTile)
      }
      2: {
        addEnemy(
          _kCenterTile,
          name: engine.locale('dungeonGuard'),
          objectId: 'enemy',
          useCustomLogic: true,
          level: game.dungeon.minEnemyLevel + game.dungeon.level + _kDungeonEnemyLevelBonus.tutorial[game.dungeon.room],
          rank: game.dungeon.rank,
        )
      }
      3: {
        switch (game.dungeon.selectedPortal) {
          'portal1': {
            addEnemy(
              _kCenterTile,
              name: engine.locale('dungeonGuard'),
              objectId: 'enemy',
              useCustomLogic: true,
              level: game.dungeon.minEnemyLevel + game.dungeon.level + _kDungeonEnemyLevelBonus.tutorial[game.dungeon.room],
              rank: game.dungeon.rank,
            )
          }
          'portal2': {
            _addPortalByNextRoomType(nextRoomType)
            _addRandomMerchant()
          }
          'portal3': {
            _addPortalByNextRoomType(nextRoomType)
            final encounterKind = _kEncounterKinds.random
            switch (encounterKind) {
              'spiritWell': {
                addSpiritWell(
                  _kCenterTile,
                  objectId: 'spiritWell',
                  rank: game.dungeon.rank + 1,
                )
              }
            }
          }
        }
      }
      4: {
        game.dungeon.isElite = true
        addEnemy(
          _kCenterTile,
          name: engine.locale('dungeonElite'),
          objectId: 'enemy',
          useCustomLogic: true,
          level: game.dungeon.minEnemyLevel + game.dungeon.level + _kDungeonEnemyLevelBonus.tutorial[game.dungeon.room],
          rank: game.dungeon.rank,
          isElite: true,
        )
      }
      5: {
        _addPortalByNextRoomType(nextRoomType)
        _addDebris()
        _addEncampment()
      }
      6: {
        game.dungeon.isBoss = true
        addEnemy(
          _kCenterTile,
          name: engine.locale('dungeonBoss'),
          objectId: 'enemy',
          useCustomLogic: true,
          level: game.dungeon.minEnemyLevel + game.dungeon.level + _kDungeonEnemyLevelBonus.tutorial[game.dungeon.room],
          rank: game.dungeon.rank + 1,
          isElite: true,
        )
      }
    }
  } else {
    switch (game.dungeon.room + 1) {
      1: {
        _addPortalByNextRoomType(nextRoomType)
        _addDebris()
        // 第一层固定是一个恢复生命的床，没有敌人。
        addRestBed(_kCenterTile)
      }
      2, 4, 6, 10, 12: {
        addEnemy(
          _kCenterTile,
          name: engine.locale('dungeonGuard'),
          objectId: 'enemy',
          useCustomLogic: true,
          level: game.dungeon.minEnemyLevel + game.dungeon.level + _kDungeonEnemyLevelBonus.normal[game.dungeon.room],
          rank: game.dungeon.rank,
        )
      }
      3, 5, 9, 11: {
        switch (game.dungeon.selectedPortal) {
          'portal1': {
            addEnemy(
              _kCenterTile,
              name: engine.locale('dungeonGuard'),
              objectId: 'enemy',
              useCustomLogic: true,
              level: game.dungeon.minEnemyLevel + game.dungeon.level + _kDungeonEnemyLevelBonus.normal[game.dungeon.room],
              rank: game.dungeon.rank,
            )
          }
          'portal2': {
            _addPortalByNextRoomType(nextRoomType)
            _addRandomMerchant()
          }
          'portal3': {
            _addPortalByNextRoomType(nextRoomType)
            final encounterKind = _kEncounterKinds.random
            switch (encounterKind) {
              'spiritWell': {
                addSpiritWell(
                  _kCenterTile,
                  objectId: 'spiritWell',
                  rank: game.dungeon.rank + 1,
                )
              }
            }
          }
        }
      }
      7, 13: {
        _addPortalByNextRoomType(nextRoomType)
        _addDebris()
        _addEncampment()
      }
      8: {
        game.dungeon.isElite = true
        addEnemy(
          _kCenterTile,
          name: engine.locale('dungeonElite'),
          objectId: 'enemy',
          useCustomLogic: true,
          level: game.dungeon.minEnemyLevel + game.dungeon.level + _kDungeonEnemyLevelBonus.normal[game.dungeon.room],
          rank: game.dungeon.rank,
          isElite: true,
        )
      }
      14: {
        game.dungeon.isBoss = true
        addEnemy(
          _kCenterTile,
          name: engine.locale('dungeonBoss'),
          objectId: 'enemy',
          useCustomLogic: true,
          level: game.dungeon.minEnemyLevel + game.dungeon.level + _kDungeonEnemyLevelBonus.normal[game.dungeon.room],
          rank: game.dungeon.rank + 1,
          isElite: true,
        )
      }
    }
  }
}

function _generateReward({probability: {}, entity}) {
  let rank = entity?.rank ?? hero.rank

  final r = Random()
  let rewardExp
  if (entity == null || (hero.rank - entity.rank) > 2) {
    rewardExp = false
  } else {
    rewardExp = r.nextDouble() < (probability?.exp ?? kRewardProbabilityExppack)
  }
  
  let rewardMoney
  let rewardShard
  if (entity?.rank <= 0) {
    rewardShard = false
    rewardMoney = r.nextDouble() < (probability?.money ?? kRewardProbabilityMoney)
  } else {
    rewardMoney = false
    rewardShard = r.nextDouble() < (probability?.shard ?? kRewardProbabilityShard)
  }
  final rewardEquipment = r.nextDouble() < (probability?.equipment ?? kRewardProbabilityEquipment)
  final rewardCardpack = r.nextDouble() < (probability?.cardpack ?? kRewardProbabilityCardpack)
  final rewardPotion = r.nextDouble() < (probability?.potion ?? kRewardProbabilityPotion)
  let rewardScrollPaper
  let rewardCraftMaterial
  let rewardDungeonTicket
  if (rank > 0) {
    rewardScrollPaper = r.nextDouble() < (probability?.scrollPaper ?? kRewardProbabilityScrollPaper)
    rewardCraftMaterial = r.nextDouble() < (probability?.craftMaterial ?? kRewardProbabilityCraftMaterial)
    rewardDungeonTicket = r.nextDouble() < (probability?.dungeonTicket ?? kRewardProbabilityDungeonTicket)
  }

  final rewards = []
  final refQuantity = expForLevel(entity?.level ?? 0)
  if (rewardExp) {
    final rankRate = entity?.rank / (hero.rank + 0.1);
    final levelRatio = entity?.level / (hero.level + 0.1);
    final exp = (rankRate * levelRatio * expForLevel(hero.level)) / ((Math.sqrt(hero.level + 0.1)) * 4.5) + 40
    final expPack = createItemByPrototype('exp_pack', amount: exp.round())
    rewards.add(expPack)
  }
  if (rewardMoney) {
    final money = r.nextInt(refQuantity * kMoneyRewardRate) + 50
    final moneyPack = Materialpack(kind: 'money', amount: money)
    rewards.add(moneyPack)
  }
  if (rewardShard) {
    final shard = r.nextInt((entity?.level ?? hero.level) + 1) + 1
    final shardPack = Materialpack(kind: 'shard', amount: shard)
    rewards.add(shardPack)
  }
  if (rewardEquipment) {
    final equipment = Equipment(rank: rank)
    rewards.add(equipment)
  }
  if (rewardCardpack) {
    let genre = Constants.attributeToGenre[entity?.cultivationFavor ?? hero.cultivationFavor]
    final cardpack = Cardpack(rank: rank, genre: genre)
    rewards.add(cardpack)
  }
  if (rewardPotion) {
    final potion = Potion(rank: rank)
    rewards.add(potion)
  }
  if (rewardScrollPaper) {
    assert(rank > 0)
    final scrollPaper = createItemByPrototype('scroll_paper_rank${rank}')
    rewards.add(scrollPaper)
  }
  if (rewardCraftMaterial) {
    let craftMaterialTypeRoll = r.nextDouble()
    let craftMaterial
    if (craftMaterialTypeRoll < kRewardProbabilityCraftMaterialUpgradeRank) {
      craftMaterial = createItemByPrototype('craftmaterial_upgradeRank${r.nearInt(rank) + 1}')
    } else if (craftMaterialTypeRoll < kRewardProbabilityCraftMaterialRerollAffix) {
      craftMaterial = createItemByPrototype('craftmaterial_rerollAffix')
    } else if (craftMaterialTypeRoll < kRewardProbabilityCraftMaterialReplaceAffix) {
      craftMaterial = createItemByPrototype('craftmaterial_replaceAffix')
    } else {
      craftMaterial = createItemByPrototype('craftmaterial_addAffix')
    }
    rewards.add(craftMaterial)
  }
  if (rewardDungeonTicket) {
    let ticketRank
    if (entity != null) {
      if (entity.rank > 1) {
        ticketRank = entity.rank - 1
      } else {
        ticketRank = 1
      }
    } else {
      ticketRank = hero.rank
    }
    assert(rank > 0)
    if (ticketRank < kCultivationRankMax) {
      if (r.nextDouble() < (probability?.dungeonTicketNextLevel ?? kRewardProbabilityDungeonTicketNextLevel)) {
        ticketRank += 1
      }
    }
    final dungeonTicket = createItemByPrototype('dungeon_ticket_rank${ticketRank}')
    rewards.add(dungeonTicket)
  }

  if (rewards.isEmpty) {
    engine.warn('生成的奖励列表为空！')
  }
  return rewards
}

async function onEnterMap() {
  if (game.dungeon.battleResult == true) {
    game.dungeon.battleResult = null
    final rewards = _generateReward(
      probability: {
        exp: kRewardProbabilityExppack,
        money: kRewardProbabilityMoney,
        shard: game.dungeon.isBoss ? 1.0 : 
          (game.dungeon.isElite ? 0.5 : kRewardProbabilityShard),
        equipment: game.dungeon.isBoss ? 0.8 : 
          (game.dungeon.isElite ? 0.4 : kRewardProbabilityEquipment),
        potion: game.dungeon.isBoss ? 0.6 : 
          (game.dungeon.isElite ? 0.3 : kRewardProbabilityPotion),
        cardpack: game.dungeon.isBoss ? 0.6 : 
          (game.dungeon.isElite ? 0.3 : kRewardProbabilityCardpack),
        scrollPaper: game.dungeon.isBoss ? 0.4 : 
          (game.dungeon.isElite ? 0.2 : kRewardProbabilityScrollPaper),
        craftMaterial: game.dungeon.isBoss ? 0.6 : 
          (game.dungeon.isElite ? 0.3 : kRewardProbabilityCraftMaterial),
        dungeonTicket: game.dungeon.isBoss ? 0.8 : 
          (game.dungeon.isElite ? 0.4 : kRewardProbabilityDungeonTicket),
      },
      entity: game.dungeon.battleEntity,
    )
    for (final item in rewards) {
      Player.acquire(item)
    }
    Game.promptItems(rewards)
    game.dungeon.battleEntity = null
  } else if (game.dungeon.battleResult == false) {
    game.dungeon.battleResult = null
    await World.promptTextBanner(engine.locale('hint_dungeon_failed'))
    Game.updateDungeon(null)
    Game.popScene(clearCache: true)
    return
  } else if (!game.dungeon.buildCompleted) {
    Dialog.pushBackground('black.png')
    Dialog.pushTask(() {
      _prepareMap()
      World.lightUpAllTiles()
      Player.setTo(_kStartTile.left, _kStartTile.top, worldId: world.id, direction: 'north')
      Game.showHeroInfo()
    })
    Dialog.popBackground(isFadeOut: true)
    await Dialog.execute()
  }
}

async function promptExit() {
  Dialog.pushDialog('hint_exitDungeon_description')
  Dialog.pushSelection(
    'exitDungeon',
    [
      'exitDungeon',
      'forgetIt',
    ]
  )
  await Dialog.execute()
  final selected = Dialog.checkSelected('exitDungeon')
  if (selected == 'exitDungeon') {
    engine.debug('地牢已经完成，准备退出')
    Game.popScene(clearCache: true)
  }
}

async function onInteractMapObject(object, terrain) {
  switch (object.id) {
    'portal1': {
      if (game.dungeon.room < game.dungeon.roomMax) {
        game.dungeon.selectedPortal = object.id
        game.dungeon.buildCompleted = false
        game.dungeon.room += 1
        onEnterMap()
      } else {
        promptExit()
      }
    }
    'portal2': {
      if (game.dungeon.room < game.dungeon.roomMax) {
        assert(game.dungeon.room < game.dungeon.roomMax)
        game.dungeon.selectedPortal = object.id
        game.dungeon.buildCompleted = false
        game.dungeon.room += 1
        onEnterMap()
      } else {
        engine.debug('即将重玩当前地牢，当前境界：${game.dungeon.rank}')
        Game.tryEnterDungeon(rank: game.dungeon.rank, pushScene: false)
        onEnterMap()
      }
    }
    'portal3': {
      if (game.dungeon.room < game.dungeon.roomMax) {
        assert(game.dungeon.room < game.dungeon.roomMax)
        game.dungeon.selectedPortal = object.id
        game.dungeon.buildCompleted = false
        game.dungeon.room += 1
        onEnterMap()
      } else {
        if (game.dungeon.level < game.dungeon.levelMax) {
          Dialog.pushDialog('hint_enterNextLevel_description')
          Dialog.pushSelection(
            'enterNextDungeonLevel',
            [
              'enterNextDungeonLevel',
              'forgetIt',
            ]
          )
          await Dialog.execute()
          final selected = Dialog.checkSelected('enterNextDungeonLevel')
          if (selected == 'enterNextDungeonLevel') {
            engine.debug('将进入下一层地牢，等级：${game.dungeon.level}')
            let hasStatusSpirit = false
            for (final itemId of hero.equipments) {
              if (itemId == null) continue
              final item = hero.inventory[itemId]
              assert(item != null)
              if (item.category == kItemCategoryStatusSpirit) {
                Player.unequip(item)
                Player.lose(item)
                hasStatusSpirit = true
              }
            }
            if (hasStatusSpirit) {
              Dialog.pushDialog('hint_dungeonStatusReset')
              await Dialog.execute()
            }
            game.dungeon.buildCompleted = false
            game.dungeon.room = 0
            game.dungeon.level += 1
            onEnterMap()
          }
        } else {
          if (game.dungeon.rank < kCultivationRankMax) {
            Dialog.pushDialog('hint_enterNextDungeonRank_description')
            Dialog.pushSelection(
              'enterNextDungeonRank',
              [
                'enterNextDungeonRank',
                'forgetIt',
              ]
            )
            await Dialog.execute()
            final selected = Dialog.checkSelected('enterNextDungeonRank')
            if (selected == 'enterNextDungeonRank') {
              engine.debug('即将进入下一个境界的地牢，当前境界：${game.dungeon.rank}')
              Game.tryEnterDungeon(isCommon: false, pushScene: false)
              onEnterMap()
            }
          } else {
            promptExit()
          }
        }
      }
    }
    'enemy': {
      Game.showPrebattle(
        object.battleEntity,
        onBattleEnd: async function [BoolInt] (battleResult, roundCount) {
          if (battleResult) {
            engine.debug('战斗胜利，添加出口')
            game.dungeon.battleResult = true
            game.dungeon.battleEntity = object.battleEntity
            let tile = getTerrainByWorldPosition(_kCenterTile.left, _kCenterTile.top)
            tile.objectId = null
            tile.isNonEnterable = false
            world.objects.remove(object.id)
            // tile.overlaySprite = {}
            World.updateTerrainData(tile.left, tile.top)
            World.removeCharacter(object.battleEntity.id)
            final nextRoomType = game.dungeon.isBasic ?
              _kBasicRooms[game.dungeon.room + 1] :
              _kNormalRooms[game.dungeon.room + 1]
            _addPortalByNextRoomType(nextRoomType)
          } else {
            engine.debug('战斗失败，准备退出地牢')
            game.dungeon.battleResult = false
          }
        }
      )
    }
  }
}
