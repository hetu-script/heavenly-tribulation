const kQuestDifficultyEasy = 'easy'
const kQuestDifficultyNormal = 'normal'
const kQuestDifficultyChallenging = 'challenging'
const kQuestDifficultyHard = 'hard'
const kQuestDifficultyTough = 'tough'
const kQuestDifficultyBrutal = 'brutal'

const kQuestDifficultyMax = 5

const kBaseBountyReplenishAmount = 1

const kBaseAmountForDeliveryMaterial = 100
const kTimeLimitDaysBase = 5
const kTimeLimitDaysVariation1 = 10
const kTimeLimitDaysVariation2 = 45

const kHiddenCityShardReward = 2

const kBaseReward = 500
const kBaseRewardForEscort = 1500
const kBaseRewardForDiscoverLocation = 4500

const kBudgetFactorForPurchaseMaterial = 0.8

const kOrganizationQuestCount = 3

function _createTimeLimit(difficulty) {
  return (kTimeLimitDaysBase
          + random.nextInt(kTimeLimitDaysVariation1)
          + (kTimeLimitDaysVariation2 * (1 - difficulty / kQuestDifficultyMax)).round()) * Constants.ticksPerDay
}

struct Quest {
  construct ({
    kind,
    difficulty,
    timeLimit,
    acquiredFromSiteId,
    receiverId,
    package,
    requirement,
    targetLocationId,
    budget,
    reward: List,
    reportSiteId,
    interpolations: List,
    contribution,
    organizationId,
  }) {
    this.kind = kind;
    assert(game.quests.containsKey(this.kind), 'invalid quest kind: ${this.kind}');
    this.difficulty = difficulty ?? 0;
    this.timeLimit = timeLimit;
    assert(timeLimit != null, 'Quest constructor: timeLimit must not be null');
    this.acquiredFromSiteId = acquiredFromSiteId;
    assert(acquiredFromSiteId != null, 'Quest constructor: acquiredFromSiteId must not be null');
    this.receiverId = receiverId;
    this.package = package;
    this.requirement = requirement;
    this.targetLocationId = targetLocationId;
    this.budget = budget;
    this.reward = reward ?? [];
    assert(contribution != null, 'Quest constructor: contribution must not be null');
    this.reward.add({
      type: 'contribution',
      amount: contribution,
      organizationId: organizationId,
      locationId: acquiredFromSiteId,
    })
    this.contribution = contribution;
    this.organizationId = organizationId;
    this.reportSiteId = reportSiteId;
    assert(reportSiteId != null, 'Quest constructor: reportSiteId must not be null');
    this.interpolations = interpolations;
  }
}

namespace Quests {
  // 运送材料
  // 报酬是材料基础价值的 1/5
  // 运送时可能遇到其他修士抢劫，几率与材料数量和价值成正比
  function deliver_material(cityhall, {
    difficulty = 0,
    organization,
  }) {
    final sites = game.locations.values
      .where((loc) {
        if (loc.atLocationId != null) {
          final atLocation = game.locations[loc.atLocationId]
          if (!atLocation.isDiscovered) return false
        }
        return loc.category == 'site' && loc.atLocationId != cityhall.atLocationId && !loc.isAffiliate
      })
    if (sites.isEmpty) return
    final endSite = random.nextIterable(sites)
    final endLocation = game.locations[endSite.atLocationId]

    let receiver
    let characters
    if (organization != null) {
      characters = organization.membersData.keys
        .map((id) => game.characters[id])
        .where((char) => char.rank == difficulty)
    } else {
      characters = game.characters.values
        .where((char) => char.rank == difficulty && char.organizationId == null)
    }
    if (characters.isNotEmpty) {
      receiver = random.nextIterable(characters)
    } else {
      receiver = Character(
        locationId: cityhall.atLocationId,
        rank: difficulty,
      )
    }

    final material = random.nextIterable(Constants.nonCurrencyMaterialKinds)
    final amount = kBaseAmountForDeliveryMaterial + random.nextInt(kBaseAmountForDeliveryMaterial * difficulty + 1)
    
    final difficultyFactor = (difficulty + 1) * (difficulty + 1) ~/ 2 + 1
    final moneyRewardAmount = kBaseReward * difficultyFactor + Constants.materialBasePrice[material] * amount ~/ 4
    final shardRewardAmount = convertMoneyToShard(moneyRewardAmount)

    final endLocationDesc
    if (endLocation != null) {
      endLocationDesc = endLocation.name
    } else {
      assert(endSite.worldPosition != null)
      endLocationDesc = '${engine.locale('worldMap')}[${endSite.worldPosition.left}, ${endSite.worldPosition.top}]';
    }

    final interpolations = [
      amount,
      engine.locale(material),
      endLocationDesc,
      endSite.name,
    ]
    
    final contribution = game.quests.deliver_material.contribution * (difficulty + 1)

    final quest = Quest(
      kind: 'deliver_material',
      difficulty: difficulty,
      timeLimit: _createTimeLimit(difficulty),
      acquiredFromSiteId: cityhall.id,
      receiverId: receiver?.id,
      package: {
        type: 'material',
        material: material,
        amount: amount,
      },
      reward: [
        {
          type: 'material',
          kind: difficulty == 0 ? 'money' : 'shard',
          amount: difficulty == 0 ? moneyRewardAmount : shardRewardAmount,
        },
      ],
      reportSiteId: endSite.id,
      interpolations: interpolations,
      contribution: contribution,
      organizationId: organization?.id,
    )
    return quest;
  }

  // 运送物品
  // 报酬是物品基础价值的 1/5
  // 运送时可能遇到其他修士抢劫，几率与材料数量和价值成正比
  function deliver_item(cityhall, {
    difficulty = 0,
    organization,
  }) {
    final sites = game.locations.values
      .where((loc)  {
        if (loc.atLocationId != null) {
          final atLocation = game.locations[loc.atLocationId]
          if (!atLocation.isDiscovered) return false
        }
        return loc.category == 'site' && loc.atLocationId != cityhall.atLocationId && !loc.isAffiliate
      })
    if (sites.isEmpty) return
    final endSite = random.nextIterable(sites)
    final endLocation = game.locations[endSite.atLocationId]

    let receiver
    let characters
    if (organization != null) {
      characters = organization.membersData.keys
        .map((id) => game.characters[id])
        .where((char) => char.rank == difficulty)
    } else {
      characters = game.characters.values
        .where((char) => char.rank == difficulty && char.organizationId == null)
    }
    if (characters.isNotEmpty) {
      receiver = random.nextIterable(characters)
    } else {
      receiver = Character(
        locationId: cityhall.atLocationId,
        rank: difficulty,
      )
    }

    let item
    final typeRoll = random.nextDouble()
    if (typeRoll < 0.33) {
      item = Equipment(rank: difficulty)
    } else if (typeRoll < 0.66) {
      item = Potion(rank: difficulty)
    } else {
      item = Cardpack(rank: difficulty)
    }

    final difficultyFactor = (difficulty + 1) * (difficulty + 1) ~/ 2 + 1
    final moneyRewardAmount = kBaseReward * difficultyFactor + item.basePrice ~/ 4
    final shardRewardAmount = convertMoneyToShard(moneyRewardAmount)

    final endLocationDesc
    if (endLocation != null) {
      endLocationDesc = endLocation.name
    } else {
      if (endSite.worldPosition == null) {
        engine.warn('endSite worldPosition is null, id: ${endSite.id}, name: ${endSite.name}, kind: ${endSite.kind}')
      }
      assert(endSite.worldPosition != null)
      endLocationDesc = '${engine.locale('worldMap')}[${endSite.worldPosition.left}, ${endSite.worldPosition.top}]';
    }

    final interpolations = [
      item.name,
      endLocationDesc,
      endSite.name,
    ]

    final contribution = game.quests.deliver_item.contribution * (difficulty + 1)

    final quest = Quest(
      kind: 'deliver_item',
      difficulty: difficulty,
      timeLimit: _createTimeLimit(difficulty),
      acquiredFromSiteId: cityhall.id,
      receiverId: receiver?.id,
      package: {
        'type': 'item',
        'item': item,
      },
      reward: [
        {
          type: 'material',
          kind: difficulty == 0 ? 'money' : 'shard',
          amount: difficulty == 0 ? moneyRewardAmount : shardRewardAmount,
        },
      ],
      reportSiteId: endSite.id,
      interpolations: interpolations,
      contribution: contribution,
      organizationId: organization?.id,
    )
    return quest;
  }

  // 护送角色
  // 陪同某个人从一个据点的某个场景到另一个据点的某个场景
  function escort(cityhall, {
    difficulty = 0,
    organization,
  }) {
    final sites = game.locations.values
      .where((loc)  {
        if (loc.atLocationId != null) {
          final atLocation = game.locations[loc.atLocationId]
          if (!atLocation.isDiscovered) return false
        }
        return loc.category == 'site' && loc.atLocationId != cityhall.atLocationId && !loc.isAffiliate
      })
    if (sites.isEmpty) return
    final endSite = random.nextIterable(sites)
    final endLocation = game.locations[endSite.atLocationId]

    let escortee
    let characters
    if (organization != null) {
      characters = organization.membersData.keys
        .map((id) => game.characters[id])
        .where((char) => char.rank == difficulty)
    } else {
      characters = game.characters.values
        .where((char) => char.rank == difficulty && char.organizationId == null)
    }
    if (characters.isNotEmpty) {
      escortee = random.nextIterable(characters)
    } else {
      escortee = Character(
        locationId: cityhall.atLocationId,
        rank: difficulty,
      )
    }

    final difficultyFactor = (difficulty + 1) * (difficulty + 1) ~/ 2 + 1
    final moneyRewardAmount = kBaseRewardForEscort * difficultyFactor
    final shardRewardAmount = convertMoneyToShard(moneyRewardAmount)

    final endLocationDesc
    if (endLocation != null) {
      endLocationDesc = endLocation.name
    } else {
      assert(endSite.worldPosition != null)
      endLocationDesc = '${engine.locale('worldMap')}[${endSite.worldPosition.left}, ${endSite.worldPosition.top}]';
    }
    
    final interpolations = [
      escortee.name,
      endLocationDesc,
      endSite.name,
    ]

    final contribution = game.quests.escort.contribution * (difficulty + 1)

    final quest = Quest(
      kind: 'escort',
      difficulty: difficulty,
      timeLimit: _createTimeLimit(difficulty),
      acquiredFromSiteId: cityhall.id,
      package: {
        'type': 'character',
        'characterId': escortee.id,
      },
      reward: [
        {
          type: 'material',
          kind: difficulty == 0 ? 'money' : 'shard',
          amount: difficulty == 0 ? moneyRewardAmount : shardRewardAmount,
        },
      ],
      reportSiteId: endSite.id,
      interpolations: interpolations,
      contribution: contribution,
      organizationId: organization?.id,
    )
    return quest;
  }

  // 购买任务，材料，获取某种数量的指定材料
  // 报酬是剩余的预算
  function purchase_material(cityhall, {
    difficulty = 0,
    organization,
  }) {
    final atLocation = game.locations[cityhall.atLocationId]
    assert(atLocation != null, 'location not found, id: ${cityhall.atLocationId}')
    assert(atLocation.category == 'city')

    final material = random.nextIterable(Constants.nonCurrencyMaterialKinds)
    final amount = kBaseAmountForDeliveryMaterial + random.nextInt(kBaseAmountForDeliveryMaterial) * (difficulty + 1)

    final moneyBudget = (Constants.materialBasePrice[material] * amount).round()

    final interpolations = [
      amount,
      engine.locale(material),
      atLocation.name,
      cityhall.name,
    ]

    final contribution = game.quests.purchase_material.contribution * (difficulty + 1)

    final quest = Quest(
      kind: 'purchase_material',
      difficulty: difficulty,
      timeLimit: _createTimeLimit(difficulty),
      acquiredFromSiteId: cityhall.id,
      requirement: {
        type: 'material',
        material: material,
        amount: amount,
      },
      budget: {
        type: 'material',
        kind: 'money',
        amount: moneyBudget,
      },
      reportSiteId: cityhall.id,
      interpolations: interpolations,
      contribution: contribution,
      organizationId: organization?.id,
    )
    return quest;
  }

  // 购买任务，获取某种指定的装备、丹药或者秘籍
  // 报酬是剩余的预算
  function purchase_item(cityhall, {
    difficulty = 0,
    organization,
  }) {
    final atLocation = game.locations[cityhall.atLocationId]
    assert(atLocation != null, 'location not found, id: ${cityhall.atLocationId}')
    assert(atLocation.category == 'city')

    let requirement
    let itemDesc
    final rarity = Constants.rankToRarity[difficulty]
    final typeRoll = random.nextDouble()
    if (typeRoll < 0.33) {
      final randomEquipmentCategory = random.nextIterable(Constants.equipmentCategoryKinds.keys)
      final randomEquipmentKind = random.nextIterable(Constants.equipmentCategoryKinds[randomEquipmentCategory])
      requirement = {
        'type': 'equipment',
        category: randomEquipmentCategory,
        kind: randomEquipmentKind,
        rank: difficulty,
        rarity: rarity,
      }
      itemDesc = engine.locale(rarity) + engine.locale(randomEquipmentKind)
    } else if (typeRoll < 0.66) {
      requirement = {
        'type': 'potion',
        category: 'potion',
        rank: difficulty,
        rarity: rarity,
      }
      itemDesc = engine.locale(rarity) + engine.locale('potion')
    } else {
      requirement = {
        'type': 'cardpack',
        category: 'cardpack',
        genre: difficulty == 0 ? 'none' : random.nextIterable(Constants.cultivationGenres),
        rank: difficulty,
      }
      itemDesc = engine.locale('cultivationRank_${difficulty}') + engine.locale('rank2') + engine.locale('cardpack')
    }

    // final difficultyFactor = (difficulty + 1) * (difficulty + 1) ~/ 2 + 1
    final budget = 
          // kBaseReward * difficultyFactor +
          estimateItemPrice(requirement.category, requirement.rank, 'expensive')
    final shardRewardAmount = convertMoneyToShard(budget)

    final interpolations = [
      itemDesc,
      atLocation.name,
      cityhall.name,
    ]

    final contribution = game.quests.purchase_item.contribution * (difficulty + 1)

    final quest = Quest(
      kind: 'purchase_item',
      difficulty: difficulty,
      timeLimit: _createTimeLimit(difficulty),
      acquiredFromSiteId: cityhall.id,
      requirement: requirement,
      budget: {
        type: 'material',
        kind: difficulty == 0 ? 'money' : 'shard',
        amount: difficulty == 0 ? budget : shardRewardAmount,
      },
      reportSiteId: cityhall.id,
      interpolations: interpolations,
      contribution: contribution,
      organizationId: organization?.id,
    )
    return quest;
  }

  // 探索某个隐藏据点
  function discover_location(cityhall, {
    difficulty = 0,
    organization,
  }) {
    final atLocation = game.locations[cityhall.atLocationId]
    assert(atLocation != null, 'location not found, id: ${cityhall.atLocationId}')
    assert(atLocation.category == 'city')

    final sites = game.locations.values
      .where((loc) => loc.category == 'city' && loc.isHidden == true && loc.isDiscovered == false)
    if (sites.isEmpty) return
    final targetLocation = random.nextIterable(sites)

    final targetLeft = targetLocation.worldPosition.left
    final targetTop = targetLocation.worldPosition.top

    final deviation = difficulty + 1
    final deviationLeft = targetLeft + (random.nextBool() ? deviation : -deviation)
    final deviationTop = targetTop + (random.nextBool() ? deviation : -deviation)
    
    final difficultyFactor = (difficulty + 1) * (difficulty + 1) ~/ 2 + 1
    let moneyRewardAmount = kBaseRewardForDiscoverLocation * difficultyFactor
    if (targetLocation.kind == 'island') {
      moneyRewardAmount *= 2
    } 
    final shardRewardAmount = convertMoneyToShard(moneyRewardAmount)

    final interpolations = [
      '[${deviationLeft}, ${deviationTop}]',
      targetLocation.name,
    ]

    final contribution = game.quests.discover_location.contribution * (difficulty + 1)

    final quest = Quest(
      kind: 'discover_location',
      difficulty: difficulty,
      timeLimit: _createTimeLimit(difficulty),
      acquiredFromSiteId: cityhall.id,
      targetLocationId: targetLocation.id,
      reward: [
        {
          type: 'material',
          kind: difficulty == 0 ? 'money' : 'shard',
          amount: difficulty == 0 ? moneyRewardAmount : shardRewardAmount,
        },
      ],
      reportSiteId: cityhall.id,
      interpolations: interpolations,
      contribution: contribution,
      organizationId: organization?.id,
    );
    return quest;
  }
}

function initEscort(quest) {
  assert(quest.kind == 'escort', 'quest kind is not escort, kind: ${quest.kind}')
  final escorteeId = quest.package.characterId;
  final escortee = game.characters[escorteeId];

  let escortType = 'stranger'
  final bond = haveMet(escortee, hero)
  if (bond?.score > 0) {
    escortType = 'acquintance'
  }

  if (escortee.organizationId && escortee.organizationId == hero.organizationId) {
    final organization = game.organizations[escortee.organizationId]
    final escorteeMemberData = organization.membersData[escortee.id]
    final heroMemberData = organization.membersData[hero.id]
    if (escorteeMemberData.rank > heroMemberData.rank) {
      escortType = 'superior'
    } else if (escorteeMemberData.rank < heroMemberData.rank) {
      escortType = 'respectful'
    }
  } else {
    if (escortee.rank > hero.rank) {
      escortType = 'intimidate'
    } else if (escortee.rank < hero.rank) {
      escortType = 'respectful'
    }
  }

  quest.escortType = escortType

  characterMet(escortee, hero)

  return escortType
}

function createQuest(cityhall, {
  kind, organization,
  isBounty = false,
  policy,
  maxDifficulty: integer,
}) {
  let quest
  // 因为任务可能会因为一些原因生成失败导致返回 null，这里需要循环尝试
  while(quest == null) {
    let questData = random.nextIterable(game.quests.values.where((q) {
      if (isBounty && !q.isBounty) return false
      if (policy && q.policy && q.policy != policy) return false
      return true
    }))
    final difficulty = random.nextInt(maxDifficulty + 1)
    final ctor = Quests[questData.id]
    assert(ctor != null, 'quest generator function not found: ${questData.id}')
    quest = ctor(
      cityhall,
      difficulty: difficulty,
      organization: organization,
    )
  }

  return quest
}

/// 刷新悬赏任务，这里不检查据点类型
function replenishBounty(location) {
  // 此处的 organization 可能为 null
  final organization = game.organizations[location.organizationId]
  
  // 清空现有悬赏任务
  location.bounties = []
  
  final amount = kBaseBountyReplenishAmount + location.development
  for (var i in range(amount)) {
    final bountyQuest = createQuest(location,
      organization: organization,
      isBounty: true,
      maxDifficulty: location.development,
    )
    location.bounties.add(bountyQuest)
  }
}

function generateOrganizationQuests(organization, location) {
  final quests = []

  for (var i in range (kOrganizationQuestCount)) {
    final quest = createQuest(location,
      organization: organization,
      policy: organization.policies[location.id],
      maxDifficulty: hero.rank,
    )
    quests.add(quest)
  }

  return quests
}
