const kQuestDifficultyEasy = 'easy'
const kQuestDifficultyNormal = 'normal'
const kQuestDifficultyChallenging = 'challenging'
const kQuestDifficultyHard = 'hard'
const kQuestDifficultyTough = 'tough'
const kQuestDifficultyBrutal = 'brutal'

const kQuestDifficultyMax = 5

const kBaseBountyReplenishAmount = 1

const kBaseAmountForDeliveryMaterial = 100
const kTimeLimitDaysBase = 5
const kTimeLimitDaysVariation1 = 10
const kTimeLimitDaysVariation2 = 25

const kHiddenCityShardReward = 2

const kBaseReward = 50
const kBaseRewardForEscort = 150
const kBaseRewardForDiscoverLocation = 450

const kBudgetFactorForPurchaseMaterial = 0.8

const kSectQuestCount = 3

function _createTimeLimit(difficulty) {
  return (kTimeLimitDaysBase
          + random.nextInt(kTimeLimitDaysVariation1)
          + (kTimeLimitDaysVariation2 * (1 - difficulty / kQuestDifficultyMax)).round()) * Constants.ticksPerDay
}

struct Quest {
  construct ({
    kind,
    difficulty,
    timeLimit,
    acquiredFromSiteId,
    receiverId,
    package,
    requirement,
    targetLocationId,
    budget,
    reward: List,
    reportSiteId,
    interpolations: List,
    contribution,
    sectId,
    // 该任务的世界观参数
    orderly,
    idealistic,
    goodwill,
  }) {
    this.kind = kind;
    assert(game.quests.containsKey(this.kind), 'invalid quest kind: ${this.kind}');
    this.difficulty = difficulty ?? 0;
    this.timeLimit = timeLimit;
    assert(timeLimit != null, 'Quest constructor: timeLimit must not be null');
    this.acquiredFromSiteId = acquiredFromSiteId;
    assert(acquiredFromSiteId != null, 'Quest constructor: acquiredFromSiteId must not be null');
    this.receiverId = receiverId;
    this.package = package;
    this.requirement = requirement;
    this.targetLocationId = targetLocationId;
    this.budget = budget;
    this.reward = reward ?? [];
    
    this.rank = game.quests[this.kind].rank
    // final rankFactor = this.rank * this.rank + 1
    final difficultyFactor = this.difficulty * this.difficulty / 2 + 1
    final contribution = (game.quests[this.kind].contribution * difficultyFactor).round()
    
    this.reward.add({
      type: 'contribution',
      amount: contribution,
      sectId: sectId,
      locationId: acquiredFromSiteId,
      // 该任务的世界观参数
      orderly: orderly,
      idealistic: idealistic,
      goodwill: goodwill,
    })
    this.sectId = sectId;
    this.reportSiteId = reportSiteId;
    assert(reportSiteId != null, 'Quest constructor: reportSiteId must not be null');
    this.interpolations = interpolations;

  }
}

namespace Quests {
  // 运送材料
  // 报酬是材料基础价值的 1/5
  // 运送时可能遇到其他修士抢劫，几率与材料数量和价值成正比
  function deliver_material(cityhall, {
    difficulty = 0,
    sect,
  }) {
    final sites = game.locations.values
      .where((loc) {
        if (loc.atCityId != null) {
          final atCity = game.locations[loc.atCityId]
          if (!atCity.isDiscovered) return false
        }
        return loc.category == 'site' && loc.atCityId != cityhall.atCityId && !loc.isAffiliate
      })
    if (sites.isEmpty) return
    final endSite = random.nextIterable(sites)
    final endLocation = game.locations[endSite.atCityId]

    let receiver
    let characters
    if (sect != null) {
      characters = sect.membersData.keys
        .map((id) => game.characters[id])
        .where((char) => char.rank == difficulty)
    } else {
      characters = game.characters.values
        .where((char) => char.rank == difficulty && char.sectId == null)
    }
    if (characters.isNotEmpty) {
      receiver = random.nextIterable(characters)
    } else {
      receiver = Character(
        locationId: cityhall.atCityId,
        rank: difficulty,
      )
    }

    final material = random.nextIterable(Constants.nonCurrencyMaterialKinds)
    final amount = kBaseAmountForDeliveryMaterial * (difficulty + 1)
    
    final difficultyFactor = difficulty * difficulty + 1
    final moneyRewardAmount = kBaseReward * difficultyFactor + Constants.materialBasePrice[material] * amount ~/ 4
    final shardRewardAmount = convertMoneyToShard(moneyRewardAmount)

    final endLocationDesc
    if (endLocation != null) {
      endLocationDesc = '${endLocation.name}[${endLocation.worldPosition.left},${endLocation.worldPosition.top}]';
    } else {
      if (endSite.worldPosition != null) {
        endLocationDesc = '${engine.locale('worldMap')}[${endSite.worldPosition.left},${endSite.worldPosition.top}]';
      } else {
        endLocationDesc = endSite.name
      }
    }

    final interpolations = [
      amount,
      engine.locale(material),
      endLocationDesc,
      endSite.name,
    ]

    final quest = Quest(
      kind: 'deliver_material',
      difficulty: difficulty,
      timeLimit: _createTimeLimit(difficulty),
      acquiredFromSiteId: cityhall.id,
      receiverId: receiver?.id,
      package: {
        type: 'material',
        material: material,
        amount: amount,
      },
      reward: [
        {
          type: 'material',
          kind: difficulty == 0 ? 'money' : 'shard',
          amount: difficulty == 0 ? moneyRewardAmount : shardRewardAmount,
        },
      ],
      reportSiteId: endSite.id,
      interpolations: interpolations,
      sectId: sect?.id,
    )
    return quest;
  }

  // 运送物品
  // 报酬是物品基础价值的 1/5
  // 运送时可能遇到其他修士抢劫，几率与材料数量和价值成正比
  function deliver_item(cityhall, {
    difficulty = 0,
    sect,
  }) {
    final sites = game.locations.values
      .where((loc)  {
        if (loc.atCityId != null) {
          final atCity = game.locations[loc.atCityId]
          if (!atCity.isDiscovered) return false
        }
        return loc.category == 'site' && loc.atCityId != cityhall.atCityId && !loc.isAffiliate
      })
    if (sites.isEmpty) return
    final endSite = random.nextIterable(sites)
    final endLocation = game.locations[endSite.atCityId]

    let receiver
    let characters
    if (sect != null) {
      characters = sect.membersData.keys
        .map((id) => game.characters[id])
        .where((char) => char.rank == difficulty)
    } else {
      characters = game.characters.values
        .where((char) => char.rank == difficulty && char.sectId == null)
    }
    if (characters.isNotEmpty) {
      receiver = random.nextIterable(characters)
    } else {
      receiver = Character(
        locationId: cityhall.atCityId,
        rank: difficulty,
      )
    }

    let item
    final typeRoll = random.nextDouble()
    if (typeRoll < 0.33) {
      item = Equipment(rank: difficulty)
    } else if (typeRoll < 0.66) {
      item = Potion(rank: difficulty)
    } else {
      item = Cardpack(rank: difficulty)
    }

    final difficultyFactor = difficulty * difficulty + 1
    final moneyRewardAmount = kBaseReward * difficultyFactor + item.basePrice ~/ 4
    final shardRewardAmount = convertMoneyToShard(moneyRewardAmount)

    final endLocationDesc
    if (endLocation != null) {
      endLocationDesc = '${endLocation.name}[${endLocation.worldPosition.left},${endLocation.worldPosition.top}]';
    } else {
      if (endSite.worldPosition != null) {
        endLocationDesc = '${engine.locale('worldMap')}[${endSite.worldPosition.left},${endSite.worldPosition.top}]';
      } else {
        endLocationDesc = endSite.name
      }
    }

    final interpolations = [
      item.name,
      endLocationDesc,
      endSite.name,
    ]

    final quest = Quest(
      kind: 'deliver_item',
      difficulty: difficulty,
      timeLimit: _createTimeLimit(difficulty),
      acquiredFromSiteId: cityhall.id,
      receiverId: receiver?.id,
      package: {
        'type': 'item',
        'item': item,
      },
      reward: [
        {
          type: 'material',
          kind: difficulty == 0 ? 'money' : 'shard',
          amount: difficulty == 0 ? moneyRewardAmount : shardRewardAmount,
        },
      ],
      reportSiteId: endSite.id,
      interpolations: interpolations,
      sectId: sect?.id,
    )
    return quest;
  }

  // 护送角色
  // 陪同某个人从一个城市的某个场景到另一个城市的某个场景
  function escort(cityhall, {
    difficulty = 0,
    sect,
  }) {
    final sites = game.locations.values
      .where((loc)  {
        if (loc.atCityId != null) {
          final atCity = game.locations[loc.atCityId]
          if (!atCity.isDiscovered) return false
        }
        return loc.category == 'site' && loc.atCityId != cityhall.atCityId && !loc.isAffiliate
      })
    if (sites.isEmpty) return
    final endSite = random.nextIterable(sites)
    final endLocation = game.locations[endSite.atCityId]

    let escortee
    let characters
    if (sect != null) {
      characters = sect.membersData.keys
        .map((id) => game.characters[id])
        .where((char) => char.rank == difficulty)
    } else {
      characters = game.characters.values
        .where((char) => char.rank == difficulty && char.sectId == null)
    }
    if (characters.isNotEmpty) {
      escortee = random.nextIterable(characters)
    } else {
      escortee = Character(
        locationId: cityhall.atCityId,
        rank: difficulty,
      )
    }

    final difficultyFactor = difficulty * difficulty + 1
    final moneyRewardAmount = kBaseRewardForEscort * difficultyFactor
    final shardRewardAmount = convertMoneyToShard(moneyRewardAmount)

    final endLocationDesc
    if (endLocation != null) {
      endLocationDesc = '${endLocation.name}[${endLocation.worldPosition.left},${endLocation.worldPosition.top}]';
    } else {
      if (endSite.worldPosition != null) {
        endLocationDesc = '${engine.locale('worldMap')}[${endSite.worldPosition.left},${endSite.worldPosition.top}]';
      } else {
        endLocationDesc = endSite.name
      }
    }
    
    final interpolations = [
      escortee.name,
      endLocationDesc,
      endSite.name,
    ]

    final quest = Quest(
      kind: 'escort',
      difficulty: difficulty,
      timeLimit: _createTimeLimit(difficulty),
      acquiredFromSiteId: cityhall.id,
      package: {
        'type': 'character',
        'characterId': escortee.id,
      },
      reward: [
        {
          type: 'material',
          kind: difficulty == 0 ? 'money' : 'shard',
          amount: difficulty == 0 ? moneyRewardAmount : shardRewardAmount,
        },
      ],
      reportSiteId: endSite.id,
      interpolations: interpolations,
      sectId: sect?.id,
    )
    return quest;
  }

  // 购买任务，材料，获取某种数量的指定材料
  // 报酬是剩余的预算
  function purchase_material(cityhall, {
    difficulty = 0,
    sect,
  }) {
    final material = random.nextIterable(Constants.nonCurrencyMaterialKinds)
    final amount = kBaseAmountForDeliveryMaterial + random.nextInt(kBaseAmountForDeliveryMaterial) * (difficulty + 1)

    final moneyBudget = (Constants.materialBasePrice[material] * amount).round()

    final interpolations = [
      amount,
      engine.locale(material),
      cityhall.name,
    ]

    final quest = Quest(
      kind: 'purchase_material',
      difficulty: difficulty,
      timeLimit: _createTimeLimit(difficulty),
      acquiredFromSiteId: cityhall.id,
      requirement: {
        type: 'material',
        material: material,
        amount: amount,
      },
      budget: {
        type: 'material',
        kind: 'money',
        amount: moneyBudget,
      },
      reportSiteId: cityhall.id,
      interpolations: interpolations,
      sectId: sect?.id,
    )
    return quest;
  }

  // 购买任务，获取某种指定的装备、丹药或者秘籍
  // 报酬是剩余的预算
  function purchase_item(cityhall, {
    difficulty = 0,
    sect,
  }) {
    let requirement
    let itemDesc
    final rarity = Constants.rankToRarity[difficulty]
    final typeRoll = random.nextDouble()
    if (typeRoll < 0.33) {
      final randomEquipmentCategory = random.nextIterable(Constants.equipmentCategoryKinds.keys)
      final randomEquipmentKind = random.nextIterable(Constants.equipmentCategoryKinds[randomEquipmentCategory])
      requirement = {
        'type': 'equipment',
        category: randomEquipmentCategory,
        kind: randomEquipmentKind,
        rank: difficulty,
        rarity: rarity,
      }
      itemDesc = engine.locale(rarity) + engine.locale(randomEquipmentKind)
    } else if (typeRoll < 0.66) {
      requirement = {
        'type': 'potion',
        category: 'potion',
        rank: difficulty,
        rarity: rarity,
      }
      itemDesc = engine.locale(rarity) + engine.locale('potion')
    } else {
      requirement = {
        'type': 'cardpack',
        category: 'cardpack',
        genre: difficulty == 0 ? 'none' : random.nextIterable(Constants.cultivationGenres),
        rank: difficulty,
      }
      itemDesc = engine.locale('cultivationRank_${difficulty}') + engine.locale('rank2') + engine.locale('cardpack')
    }

    final difficultyFactor = difficulty * difficulty + 1
    let budget = 
          estimateItemPrice(requirement.category, requirement.rank, 'expensive')
    if (!Constants.itemWithAffixCategories.contains(requirement.category)) {
      budget += kBaseReward * difficultyFactor + budget ~/ 4;
    }
    final shardRewardAmount = convertMoneyToShard(budget)

    final interpolations = [
      itemDesc,
      cityhall.name,
    ]

    final quest = Quest(
      kind: 'purchase_item',
      difficulty: difficulty,
      timeLimit: _createTimeLimit(difficulty),
      acquiredFromSiteId: cityhall.id,
      requirement: requirement,
      budget: {
        type: 'material',
        kind: difficulty == 0 ? 'money' : 'shard',
        amount: difficulty == 0 ? budget : shardRewardAmount,
      },
      reportSiteId: cityhall.id,
      interpolations: interpolations,
      sectId: sect?.id,
    )
    return quest;
  }

  // 探索某个隐藏城市
  function discover_location(cityhall, {
    difficulty = 0,
    sect,
  }) {
    final sites = game.locations.values
      .where((loc) => loc.category == 'city' && loc.isHidden == true && loc.isDiscovered == false)
    if (sites.isEmpty) return
    final targetLocation = random.nextIterable(sites)

    final targetLeft = targetLocation.worldPosition.left
    final targetTop = targetLocation.worldPosition.top

    final deviation = difficulty + 1
    final deviationLeft = targetLeft + (random.nextBool() ? deviation : -deviation)
    final deviationTop = targetTop + (random.nextBool() ? deviation : -deviation)
    
    final difficultyFactor = difficulty * difficulty + 1
    let moneyRewardAmount = kBaseRewardForDiscoverLocation * difficultyFactor
    if (targetLocation.kind == 'island') {
      moneyRewardAmount *= 2
    } 
    final shardRewardAmount = convertMoneyToShard(moneyRewardAmount)

    final interpolations = [
      '[${deviationLeft},${deviationTop}]',
      targetLocation.name,
    ]

    final quest = Quest(
      kind: 'discover_location',
      difficulty: difficulty,
      timeLimit: _createTimeLimit(difficulty),
      acquiredFromSiteId: cityhall.id,
      targetLocationId: targetLocation.id,
      reward: [
        {
          type: 'material',
          kind: difficulty == 0 ? 'money' : 'shard',
          amount: difficulty == 0 ? moneyRewardAmount : shardRewardAmount,
        },
      ],
      reportSiteId: cityhall.id,
      interpolations: interpolations,
      sectId: sect?.id,
      orderly: 1,
      idealistic: -1,
    );
    return quest;
  }
}

function initEscort(quest) {
  assert(quest.kind == 'escort', 'quest kind is not escort, kind: ${quest.kind}')
  final escorteeId = quest.package.characterId;
  final escortee = game.characters[escorteeId];

  let escortType = 'stranger'
  final bond = escortee.bonds[hero.id]
  if (bond?.score > 0) {
    escortType = 'acquintance'
  }

  if (escortee.sectId && escortee.sectId == hero.sectId) {
    final sect = game.sects[escortee.sectId]
    final escortee = game.characters[escorteeId];
    if (escortee.sectJobRank > hero.sectJobRank) {
      escortType = 'superior'
    } else if (escortee.sectJobRank < hero.sectJobRank) {
      escortType = 'respectful'
    }
  } else {
    if (escortee.rank > hero.rank) {
      escortType = 'intimidate'
    } else if (escortee.rank < hero.rank) {
      escortType = 'respectful'
    }
  }

  quest.escortType = escortType

  characterMet(escortee, hero)

  return escortType
}

function createQuest(cityhall, {
  kind, sect,
  isBounty = false,
  policy,
  maxDifficulty: integer,
}) {
  let quest
  // 因为任务可能会因为一些原因生成失败导致返回 null，这里需要循环尝试
  while(quest == null) {
    let questData = random.nextIterable(game.quests.values.where((q) {
      if (isBounty && !q.isBounty) return false
      if (isBounty && q.rank > 2) return false
      if (policy && q.policy && q.policy != policy) return false
      return true
    }))
    final difficulty = random.nextInt(maxDifficulty + 1)
    final ctor = Quests[questData.id]
    assert(ctor != null, 'quest generator function not found: ${questData.id}')
    quest = ctor(
      cityhall,
      difficulty: difficulty,
      sect: sect,
    )
  }

  return quest
}

/// 刷新悬赏任务，这里不检查城市类型
function replenishBounty(location) {
  // 此处的 sect 可能为 null
  final sect = game.sects[location.sectId]
  
  // 清空现有悬赏任务
  location.bounties = []
  
  final amount = kBaseBountyReplenishAmount + location.development
  for (var i in range(amount)) {
    final bountyQuest = createQuest(location,
      sect: sect,
      isBounty: true,
      maxDifficulty: location.development,
    )
    location.bounties.add(bountyQuest)
  }
}

function generateSectQuests(sect, location) {
  final quests = []

  for (var i in range (kSectQuestCount)) {
    final quest = createQuest(location,
      sect: sect,
      policy: sect.policies[location.id],
      maxDifficulty: hero.rank,
    )
    quests.add(quest)
  }

  return quests
}
