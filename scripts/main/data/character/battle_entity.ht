
import '../achievements.ht'

// number of the avatar images
const _kAvatarCount = 41

const _kCostumeCount = 5
const _kCostumeColorCount = 3

const _kInitialMoneyPerLevel = 500
const _kInitialShardPerRank = 5

/// 容貌等数值计算时的最大值: 100.0
const kAttributeValueMax = 100.0;
const kNonBattleAttributeValueAverage = 50.0;
const kNonBattleAttributeValueMajor = 75.0;
const kNonBattleAttributeValueDeviation = 25.0;
const kBattleAttributesValueBase = 25
const kBattleAttributesValueMajor = 50

const kBattleCardBasicAttacks = [
  'punch',
  'kick',
];

const kBattleCardBasicBuffs = [
  'punch',
  'kick',
  'xinfa',
  'shenfa',
  'qinggong',
];

const kBattleCardWeaponKinds = [
  'sabre',
  'sword',
  'spear',
  'staff',
  'bow',
  'dart',
];

const kBattleCardGenreWeaponKinds = {
  'bodyforge': ['sabre'],
  'swordcraft': ['sword'],
  'spellcraft': [],
  'vitality': ['bow', 'dart'],
  'avatar': ['staff', 'spear'],
};

/// battle entity 指一个可以参与战斗的对象。
/// 此对象拥有一个牌库和一个卡组。
/// 卡组是战斗中使用的。而牌库可以用来交换卡牌收藏（偷取、学习或者交换）。
struct BattleEntity {
  constructor ({
    id,
    isFemale,
    race,
    icon,
    illustration,
    skin,
    name,
    shortName,
    surName,
    generationName,
    generateName = true,
    description,
    level,
    rank,
    attributes,
    stats,
    allocateSkills = true,
    generateDeck = true,
    cultivationFavor,
    cultivationStyle,
  }) {
    this.entityType = kEntityTypeBattleEntity
    this.isFemale = isFemale ?? random.nextBool()
    if (race != null) {
      assert(Constants.races.contains(race))
      this.race = race
    } else {
      this.race = random.nextIterable(Constants.races)
    }

    const sex = this.isFemale ? 'female' : 'male'
    this.illustration = illustration
    if (icon == null) {
      const avatarIndex = random.nextInt(_kAvatarCount)
      this.icon = 'illustration/avatar/${this.race}/${sex}/${avatarIndex}.png'
    } else {
      this.icon = icon
    }
    // this.usedNames = []
    this.skin = skin ?? '${sex}_${this.race}_costume${random.nextInt(_kCostumeCount) + 1}_color${random.nextInt(_kCostumeColorCount) + 1}'

    if (name == null && generateName) {
      let randomName
      let conflict = false
      do {
        randomName = generateCharacterName(
          isFemale: this.isFemale,
          surName: surName,
          middleName: generationName,
        )
        conflict = game.characters[randomName.fullName] != null
      } while (conflict)
      this.name = randomName.fullName
      this.surName = randomName.surName
      this.generationName = randomName.middleName
      this.shortName = randomName.shortName
    } else {
      this.name = name ?? engine.locale('noname')
      this.surName = surName
      this.generationName = generationName
      this.shortName = shortName ?? name
    }
    this.id = id ?? this.name
    
    // 非主角色不参与 update, interact 等逻辑交互，也不会自动显示在地图或场景中。
    // this.isMain = isMain ?? false

    this.description = description ?? ''

    // 修真境界，凝气期是1
    // 境界决定了升级时能获得卡牌的最高稀有度，但具体获得的卡牌是随机的
    // 在所有流派中，只有修为等级最高的那个流派决定了境界
    this.rank = rank ?? 0
    // 修为等级，每次提升修为等级可以获得1点天赋点
    this.level = level
    final minLevel = minLevelForRank(this.rank)
    final maxLevel = maxLevelForRank(this.rank)
    if (this.level == null) {
      this.level = random.nextInt(maxLevel - minLevel + 1) + minLevel
    } else {
      this.level = this.level.clamp(minLevel, maxLevel)
    }

    this.tribulationCount = 0

    // 身上携带的材料，材料本身没有特殊属性，多个材料只是堆叠数字增加
    // 材料单独显示在物品栏上方，没有携带的材料不会显示
    // 金钱也是一种材料，其他材料包括可以用来建筑的木材、石料等
    this.materials = {
      money: _kInitialMoneyPerLevel * (this.level + 1),
      shard: _kInitialShardPerRank * (this.rank),
    }

    // 身上携带的普通物品，每一个都是单独生成，无法堆叠
    this.inventory = {}

    // 装备栏的位置是固定的 7 个
    // 装备栏只能装备法宝，获得其佩戴效果
    // key 是 0-7 的数字，代表第几栏，
    // value 是 物品的 id，物品的具体数据在角色的 inventory 中
    this.equipments = {
      '0': null,
      '1': null,
      '2': null,
      '3': null,
      '4': null,
      '5': null,
      // '6': null,
    }

    // 随角色移动的其他角色，这里只保存id
    this.companions = []

    // 角色当前卡牌库，关于战斗卡牌的具体信息另行参阅文档
    // 卡牌库是一个 map，key 是卡牌的 id，value 是卡牌数据
    this.cardLibrary = {}
    // 战斗卡组的数组，数组的值是一个结构体，包含卡组的命名（可修改）和卡组内容
    // [
    //   {
    //     title: 'deck name',
    //     isBattleDeck: false, // 是否是当前使用的战斗卡组
    //     // isValid: false, // 卡组是否合法（数量，装备要求等是否满足）
    //     cards: [
    //       'card id 1', // 卡组中只保存卡牌id，实际数据在角色的library中
    //       'card id 2',
    //     ]
    //   }
    // ]
    this.battleDecks = []
    // 当前使用的战斗卡组，记录的是战斗卡组数组的index
    this.battleDeckIndex = -1

    // 角色的属性
    // 包括：灵力、身法、体魄、念力、神识
    if (attributes == null) {
      generateAttributes(this)
    } else {
      for (final id in Constants.attributes) {
        this[id] = attributes[id] ?? 0
      }
    }
    
    // 已解锁的天赋技能节点， key 是 nodeId ，代表天赋盘上某个位置的坐标。
    // 如果存在某个 key 意味着该位置已经被解锁
    // 对于属性类节点，值是该属性的名字
    // 对于其他节点，值是 true
    this.unlockedPassiveTreeNodes = {}

    // 从装备或者天赋树中获得的被动加成，key是词条id
    this.passives = {}

    // 从丹药中获得的被动加成，临时性加成将会在战斗结束时移除
    this.potionPassives = {}

    // 在秘境中获得的被动加成，将会在离开秘境时移除
    this.dungeonPassives = {}

    // 角色的数值
    // 包括经过物品、天赋和状态加成的基本属性值
    // 通过属性还会计算出：攻击、防御、体力、生命、灵气
    this.stats = stats ?? {}

    // 煞气：角色击败过的其他角色的数量，本身也是一种资源，可以被消耗
    this.karma = 0
    
    this.mainAttribute = getMainAttribute(this)

    // 主流派：御剑、道术、锻体、炼魂、法身
    this.cultivationFavor = cultivationFavor ?? Constants.attributeToGenre[this.mainAttribute]
    // 加点路线
    this.cultivationStyle = cultivationStyle ?? random.nextIterable(Constants.cultivationStyles[this.mainAttribute])
    
    this.achievements = Achievements()
    if (allocateSkills) {
      Game.characterAllocateSkills(this, rejuvenate: true)
    } else {
      characterCalculateStats(this, rejuvenate: true)
    }
    
    if (generateDeck) {
      generateBattleDeck(this)
    }
  }
}

function generateAttributes(entity) {
  let mainAttributes = Constants.raceMainAttributes[entity.race]
  assert(mainAttributes != null, 'raceMainAttributes not found, ${entity.race}');

  let attributes = {}
  for (final id in Constants.nonBattleAttributes) {
    attributes[id] = Math.gaussianNoise(
      mainAttributes.contains[id] ? kNonBattleAttributeValueMajor : kNonBattleAttributeValueAverage,
      kNonBattleAttributeValueDeviation,
      min: 1,
      max: kAttributeValueMax,
      randomGenerator: random,
    ).round()
  }
  for (final id in Constants.battleAttributes) {
    if (mainAttributes.contains[id]) {
      attributes[id] = random.nearInt(kBattleAttributesValueMajor)
    } else {
      attributes[id] = random.distantInt(kBattleAttributesValueBase)
    }
  }
  Object.assign(entity, attributes)
}

function getMainAttribute(character) {
  let maxAttr = Constants.battleAttributes.first
  let maxValue = character[maxAttr]

  for (final attr in Constants.battleAttributes) {
    if (character[attr] > maxValue) {
      maxAttr = attr
      maxValue = character[attr]
    }
  }

  return maxAttr
}

/// 当前状态数值，由特性、属性、物品、天赋、技能、增益减损等计算得来
/// 状态包括：生命、伤害、防御等。
function characterCalculateStats(character, { reset = false, rejuvenate = false}) {
  if (reset) {
    character.stats = {}
  }

  final baseLife = Constants.baseLife + character.level * Constants.baseLifePerLevel
  character.lifeMax = baseLife + character.strength
  character.manaMax = character.spirituality ~/ 10
  character.chakraMax = character.dexterity ~/ 10
  character.karmaMax = character.willpower ~/ 10
  // character.expMax = (expForLevel(character.level) * 2.5).truncate()

  character.tribulationCountMax = getTribulationCountForRank(character.rank)
  character.lightRadius = Constants.baseLightRadius + character.perception ~/ 10
  character.monthlyIdentifyCardsMax = Constants.baseMonthlyIdentifyCardsMax + character.perception ~/ 10
  character.expGainPerLight = (character.rank * character.rank + (character.rank + 1)) * Constants.baseExpGainPerLight
  character.speedExpCollect = Constants.baseExpCollectSpeed
  character.speedOnPlain = Constants.baseMoveSpeedOnPlain
  character.speedOnMountain = Constants.baseMoveSpeedOnMountain
  character.speedOnWater = Constants.baseMoveSpeedOnWater
  character.staminaCostOnMountain = Constants.baseStaminaCostOnMountain
  character.staminaCostOnWater = Constants.baseStaminaCostOnWater
  character.workEfficiency = 1.0
  character.staminaCostWork = 1.0
  character.craftSkillLevel = Constants.baseCraftSkillLevel

  character.physicalResistMax = Constants.baseResistMax
  character.chiResistMax = Constants.baseResistMax
  character.elementalResistMax = Constants.baseResistMax
  character.psychicResistMax = Constants.baseResistMax

  character.quickThreshold = Constants.baseTurnActionThreshold
  character.slowThreshold = Constants.baseTurnActionThreshold
  character.nimbleThreshold = Constants.baseTurnActionThreshold
  character.clumsyThreshold = Constants.baseTurnActionThreshold

  // 基础属性，在此基础上还要加上物品和状态的加成
  character.stats.charisma = character.charisma + character.passives.charisma?.value
  character.stats.wisdom = character.wisdom + character.passives.wisdom?.value
  character.stats.luck = character.luck + character.passives.luck?.value

  character.stats.dexterity = character.dexterity + character.passives.dexterity?.value + character.potionPassives.dexterity?.value
  character.stats.spirituality = character.spirituality + character.passives.spirituality?.value + character.potionPassives.spirituality?.value
  character.stats.strength = character.strength + character.passives.strength?.value + character.potionPassives.strength?.value
  character.stats.perception = character.perception + character.passives.perception?.value + character.potionPassives.perception?.value
  character.stats.willpower = character.willpower + character.passives.willpower?.value + character.potionPassives.willpower?.value

  character.stats.lifeMax = baseLife + character.stats.strength + character.passives.lifeMax?.value + character.potionPassives.lifeMax?.value
  character.stats.manaMax = character.stats.spirituality ~/ 10 + character.passives.manaMax?.value + character.potionPassives.manaMax?.value
  character.stats.chakraMax = character.stats.dexterity ~/ 10 + character.passives.chakraMax?.value + character.potionPassives.chakraMax?.value
  character.stats.karmaMax = character.stats.willpower ~/ 10 + character.passives.karmaMax?.value + character.potionPassives.karmaMax?.value
  
  if (character.rank > 0) {
    character.stats.tribulationCountMax = (character.tribulationCountMax * (1 + character.passives.tribulationCountMax?.value / 100)).round()
  } else {
    character.stats.tribulationCountMax = -1
  }
  character.stats.monthlyIdentifyCardsMax = Constants.baseMonthlyIdentifyCardsMax + character.stats.perception ~/ 10 + character.passives.monthlyIdentifyCardsMax?.value + character.potionPassives.monthlyIdentifyCardsMax?.value
  character.stats.lightRadius = Constants.baseLightRadius + character.stats.perception ~/ 10 + character.passives.lightRadius?.value + character.potionPassives.lightRadius?.value
  character.stats.speedOnPlain = (character.speedOnPlain * (1 - character.passives.speedOnPlain?.value / 100) * (1 - character.potionPassives.speedOnPlain?.value / 100)).toFixed(2)
  character.stats.speedOnMountain = (character.speedOnMountain * (1 - character.passives.speedOnMountain?.value / 100) * (1 - character.potionPassives.speedOnMountain?.value / 100)).toFixed(2)
  character.stats.speedOnWater = (character.speedOnWater * (1 - character.passives.speedOnWater?.value / 100) * (1 - character.potionPassives.speedOnWater?.value / 100)).toFixed(2)
  character.stats.staminaCostOnMountain = (character.staminaCostOnMountain * (1 + character.passives.staminaCostOnMountain?.value / 100) * (1 + character.potionPassives.staminaCostOnMountain?.value / 100)).toFixed(2)
  character.stats.staminaCostOnWater = (character.staminaCostOnWater * (1 + character.passives.staminaCostOnWater?.value / 100) * (1 + character.potionPassives.staminaCostOnWater?.value / 100)).toFixed(2)
  character.stats.expGainPerLight = (character.expGainPerLight * (1 + character.passives.expGainPerLight?.value / 100) * (1 + character.potionPassives.expGainPerLight?.value / 100)).round()
  character.stats.speedExpCollect = (character.speedExpCollect * (1 - character.passives.speedExpCollect?.value / 100) * (1 - character.potionPassives.speedExpCollect?.value / 100)).toFixed(2)
  character.stats.workEfficiency = (character.workEfficiency * (1 + character.passives.workEfficiency?.value / 100) * (1 + character.potionPassives.workEfficiency?.value / 100)).toFixed(2)
  character.stats.staminaCostWork = (character.staminaCostWork * (1 + character.passives.staminaCostWork?.value / 100) * (1 + character.potionPassives.staminaCostWork?.value / 100)).toFixed(2)
  character.stats.craftSkillLevel = character.craftSkillLevel + character.passives.craftSkillLevel?.value + character.potionPassives.craftSkillLevel?.value

  character.stats.unarmedAttack = character.passives.unarmedAttack?.value + character.potionPassives.unarmedAttack?.value
  character.stats.weaponAttack = character.passives.weaponAttack?.value + character.potionPassives.weaponAttack?.value
  character.stats.spellAttack = character.passives.spellAttack?.value + character.potionPassives.spellAttack?.value
  character.stats.curseAttack = character.passives.curseAttack?.value + character.potionPassives.curseAttack?.value

  character.stats.physicalResist = character.passives.physicalResist?.value + character.potionPassives.physicalResist?.value
  character.stats.chiResist = character.passives.chiResist?.value + character.potionPassives.chiResist?.value
  character.stats.elementalResist = character.passives.elementalResist?.value + character.potionPassives.elementalResist?.value
  character.stats.psychicResist = character.passives.psychicResist?.value + character.potionPassives.psychicResist?.value

  character.stats.physicalResistMax = character.physicalResistMax + character.passives.physicalResistMax?.value + character.potionPassives.physicalResistMax?.value
  character.stats.chiResistMax = character.chiResistMax + character.passives.chiResistMax?.value + character.potionPassives.chiResistMax?.value
  character.stats.elementalResistMax = character.elementalResistMax + character.passives.elementalResistMax?.value + character.potionPassives.elementalResistMax?.value
  character.stats.psychicResistMax = character.psychicResistMax + character.passives.psychicResistMax?.value + character.potionPassives.psychicResistMax?.value

  if (character.stats.physicalResist > character.stats.physicalResistMax) {
    character.stats.physicalResist = character.stats.physicalResistMax
  }
  if (character.stats.chiResist > character.stats.chiResistMax) {
    character.stats.chiResist = character.stats.chiResistMax
  }
  if (character.stats.elementalResist > character.stats.elementalResistMax) {
    character.stats.elementalResist = character.stats.elementalResistMax
  }
  if (character.stats.psychicResist > character.stats.psychicResistMax) {
    character.stats.psychicResist = character.stats.psychicResistMax
  }

  character.stats.quickThreshold = (Constants.baseTurnActionThreshold + character.passives.quickThreshold?.value + character.potionPassives.quickThreshold?.value).clamp(Constants.minTurnActionThreshold, Constants.maxTurnActionThreshold)
  character.stats.slowThreshold = (Constants.baseTurnActionThreshold + character.passives.slowThreshold?.value + character.potionPassives.slowThreshold?.value).clamp(Constants.minTurnActionThreshold, Constants.maxTurnActionThreshold)
  character.stats.nimbleThreshold = (Constants.baseTurnActionThreshold + character.passives.nimbleThreshold?.value + character.potionPassives.nimbleThreshold?.value).clamp(Constants.minTurnActionThreshold, Constants.maxTurnActionThreshold)
  character.stats.clumsyThreshold = (Constants.baseTurnActionThreshold + character.passives.clumsyThreshold?.value + character.potionPassives.clumsyThreshold?.value).clamp(Constants.minTurnActionThreshold, Constants.maxTurnActionThreshold)

  if (rejuvenate) {
    setCharacterLife(character, character.stats.lifeMax)
  }
}

/// 设定生命值，最终值一定大于 0
/// 若尝试将生命设为小于 0 则会触发劫难 并返回 true
function setCharacterLife(character, life, { overflow = false }) {
  let isDying = false
  if (life <= 0) {
    engine.warn('角色 ${character.id} 遭遇劫难，生命值重设为 1')
    life = 1.0
    isDying = true
    character.tribulationCount += 1
  } else if (!overflow && life > character.stats.lifeMax) {
    life = character.stats.lifeMax
  }
  character.life = life.toDouble()

  return isDying
}

/// 恢复指定角色指定数量的生命，不会超过当前生命上限，并返回实际恢复的数值
function characterRestoreLife(character, amount) {
  assert(amount > 0)
  let before = character.life
  setCharacterLife(character, character.life + amount, overflow: false)
  return character.life - before
}

function getCharacterStats(character) {
  const stats = character.stats.clone()
  return stats
}

/// 返回一个包含可移动的tile kind的列表
/// 如果不为null且非空，则英雄可以开始尝试向这个格子移动，但中途有可能停下
/// 否则不会进入移动路径计算
function getCharacterMovableTerrainKinds(character) {
  let aircraft = characterEquippedCategory(character, 'aircraft')
  if (aircraft) {
    return Constants.terrainKindsAll
  } else {
    let kinds = Constants.terrainKindsLand.toList()
    if (characterEquippedKind(character, 'boots')) {
      kinds.addAll(Constants.terrainKindsMountain)
    }
    if (characterEquippedKind(character, 'ship')) {
      kinds.addAll(Constants.terrainKindsWater)
    }
    return kinds
  }
}

/// 提升或降低天赋技能等级
/// 注意此函数调用时并不会检测天赋树节点位置和链接情况
/// 也不会检查角色是否有足够的技能点
/// 升级天赋时，并不会立刻影响角色数据，
/// 只有在执行 characterCalculateStats() 之后，人物数据才会最终计算出来
function characterSetPassive(character, dataId, {level = 1}) {
  assert(level != 0, 'Character set passive error: level is zero')
  if (character.passives[dataId] == null) {
    if (level < 0) {
      engine.warn('Could not found passive dataId [${dataId}] on character for decrease!')
      return
    }
    final passiveRawData = game.passives[dataId]
    assert(passiveRawData != null, 'passive data not found! id: ${dataId}')
    final passiveData = PassiveData(
      id: dataId,
      priority: passiveRawData.priority ?? 0,
      level: level,
      maxLevel: passiveRawData.maxLevel,
      description: passiveRawData.description,
    )
    if (passiveRawData.increment != null) {
      passiveData.increment = passiveRawData.increment
      let passiveLevel = passiveData.level
      if (passiveData.maxLevel && passiveData.level > passiveData.maxLevel) {
        passiveLevel = passiveData.maxLevel
      }
      passiveData.value = (passiveData.increment * passiveLevel).round()
    }
    character.passives[dataId] = passiveData
  } else {
    final passiveData = character.passives[dataId]
    passiveData.level += level
    if (passiveData.level <= 0) {
      if (passiveData.level < 0) {
        engine.warn('decrease passive level below zero, dataId: ${dataId}')
      }
      delete character.passives[dataId]
    } else {
      let passiveLevel = passiveData.level
      if (passiveData.maxLevel && passiveData.level > passiveData.maxLevel) {
        passiveLevel = passiveData.maxLevel
      }
      passiveData.value = (passiveData.increment * passiveLevel).round()
    }
  }
}

/// 降低天赋技能等级
// function characterRefundPassive(character, dataId, {level = 1}) {
//   if (level == 0) {
//     engine.warn('refund passive error: level is zero')
//     return
//   }
//   if (character.passives[dataId] == null) {
//     engine.warn('dataId [${dataId}] not found on character passives data for refund!')
//     return
//   }
//   final passiveData = character.passives[dataId]
//   passiveData.level -= level
//   if (passiveData.value != null) {
//     let passiveLevel = passiveData.level
//     if (passiveData.maxLevel && passiveData.level > passiveData.maxLevel) {
//       passiveLevel = passiveData.maxLevel
//     }
//     passiveData.value = (passiveData.increment * passiveLevel).round()
//   }
// }

/// 检查角色是否拥有某个天赋技能，并将其数据返回
function characterHasPassive(character, dataId) {
  return character.passives[dataId]
}

function generateBattleDeck(character, { maxOutLevel = false, cardInfoList }) {
  let deck = []
  if (cardInfoList is List && cardInfoList.isNotEmpty) {
    for (final info in cardInfoList) {
      final card = BattleCard(
        category: info.category,
        affixId: info.affixId,
        kind: info.kind,
        genre: info.genre,
        rank: info.rank ?? character.rank,
        maxOutLevel: maxOutLevel,
        maxRank: info.maxRank,
        isIdentified: info.isIdentified ?? false,
      )
      deck.add(card)
    }
  } else {
    final deckLimit = getDeckLimitForRank(character.rank)
    let weaponKind = random.nextIterable(kBattleCardGenreWeaponKinds[character.cultivationFavor])
    let weaponKind2 = random.nextIterable(kBattleCardWeaponKinds)
    let buffs = []
    let attacks = []
    for (var i in range(deckLimit.limit)) {
      let genre = character.rank > 0 ? character.cultivationFavor : null
      final isBuff = random.nextDouble() < 0.35
      let kind
      final kindRoll = random.nextDouble()
      if (kindRoll < 0.35) {
        if (weaponKind != null) {
          kind = weaponKind
        } else {
          kind = weaponKind2
          genre = 'none'
        }
      } else {
        if (character.rank == 0) {
          if (isBuff) {
            kind = random.nextIterable(kBattleCardBasicBuffs)
          } else {
            kind = random.nextIterable(kBattleCardBasicAttacks)
          }
        } else {
          if (isBuff) {
            kind = random.nextIterable(Constants.battleCardGenreBuffs[genre])
          } else {
            kind = random.nextIterable(Constants.battleCardGenreAttacks[genre])
          }
        }
      }
      final card = BattleCard(
        category: isBuff ? 'buff' : 'attack',
        genre: genre,
        kind: kind,
        rank: character.rank,
        isIdentified: false,
      )
      deck.add(card)
    }
    final equipment = Equipment(kind: weaponKind, rank: character.rank)
    characterEquip(character, equipment)
  }
  for (final card in deck) {
    characterAcquireBattleCard(character, card, incurIncident: false)
  }
  character.battleDecks.add({
    title: 'battleDeck',
    isBattleDeck: true,
    cards: deck.map((card) => card.id).toList(),
  })
  character.battleDeckIndex = character.battleDecks.length - 1
  
  engine.info('为 ${character.name} 生成了战斗卡组: [${deck.map((card) => card.name).join(', ')}]')
}

function characterEquip(entity, item, { index }) {
  assert(entity.entityType == kEntityTypeBattleEntity || entity.entityType == kEntityTypeCharacter, entity.entityType)
  assert(index == null || (index >= 0 && index <= kEquipmentMax))

  if (entity.inventory[item.id] == null) {
    // engine.warn('${item.name} 不在${entity.name}的物品栏中，无法装备。')
    item = entityAcquire(entity, item)
  }

  if (!item.isEquippable) {
    engine.warn('${item.name} 无法装备。')
    return false
  }
  if (item.equippedPosition) {
    engine.warn('${item.name} 已经在装备中了。')
    return false
  }

  let equipped = false
  // 如果有空位就装备在空位上
  if (index == null) {
    for (const i in range(kEquipmentMax + 1)) {
      if (entity.equipments[i] == null) {
        entity.equipments[i] = item.id
        item.equippedPosition = i
        equipped = true
        break
      }
    }
    // 否则替换掉第一个空位
    // index = 0
  }

  // if (!equipped) {
  //   assert(index != null)

  //   const oldEquipId = entity.equipments[index]
  //   if (oldEquipId != null) {
  //     const oldItem = entity.inventory[oldEquipId]
  //     delete oldItem.equippedPosition
  //   }
  //   entity.equipments[index] = item.id
  //   item.equippedPosition = index
  //   equipped = true
  // }

  if (equipped) {
    if (item.affixes is List) {
      for (final passiveData in item.affixes) {
        characterSetPassive(entity, passiveData.id, level: passiveData.level)
      }
      // 重新计算角色状态值
      characterCalculateStats(entity, rejuvenate: false)
    }

    if (entity == hero) {
      engine.info('${entity.name}装备了${item.name}')
      onGameEvent('onEquip', item)
    }
  }

  return equipped
}

function characterUnequip(entity, item) {
  assert(item.equippedPosition != null)
  hero.equipments[item.equippedPosition] = null
  delete item.equippedPosition

  if (item.affixes is List) {
    for (final passiveData in item.affixes) {
      characterSetPassive(entity, passiveData.id, level: -(passiveData.level ?? 1))
    }
    // 重新计算角色状态值
    characterCalculateStats(entity, rejuvenate: false)
  }
  
  engine.info('${entity.name}取下了${item.name}')
}

function characterEquippedCategory(entity, category) {
  let count = 0
  for (final itemId in entity.equipments.values) {
    if (itemId == null) continue
    final item = entity.inventory[itemId]
    if (item.category == category) {
      ++count
    }
  }
  return count
}

function characterFirstEquippedCategory(entity, category) {
  for (final itemId in entity.equipments.values) {
    if (itemId == null) continue
    final item = entity.inventory[itemId]
    if (item.category == category) {
      return item
    }
  }
  return null
}

function characterEquippedKind(entity, kind) {
  let count = 0
  for (final itemId in entity.equipments.values) {
    if (itemId == null) continue
    final item = entity.inventory[itemId]
    if (item.kind == kind) {
      ++count
    }
  }
  return count
}

function characterFirstEquippedKind(entity, kind) {
  for (final itemId in entity.equipments.values) {
    if (itemId == null) continue
    final item = entity.inventory[itemId]
    if (item.kind == kind) {
      return item
    }
  }
  return null
}

/// 修改从丹药中获得的被动属性
/// 相同的属性会被覆盖
/// 只有在执行 characterCalculateStats() 之后，人物数据才会最终计算出来
function characterSetPotionPassive(character, dataId, {level = 1}) {
  if (level == 0) {
    engine.warn('Character gain passive error: level is zero')
    return
  }
  final passiveRawData = game.passives[dataId]
  assert(passiveRawData != null, 'passive data not found! id: ${dataId}')
  final passiveData = PassiveData(
    id: dataId,
    priority: passiveRawData.priority ?? 0,
    level: level,
    description: passiveRawData.description,
    isPermanent: passiveRawData.isPermanentPotionAffix ?? false,
  )
  if (passiveRawData.increment != null) {
    passiveData.increment = passiveRawData.increment
    let passiveLevel = passiveData.level
    if (passiveData.maxLevel && passiveData.level > passiveData.maxLevel) {
      passiveLevel = passiveData.maxLevel
    }
    passiveData.value = (passiveData.increment * passiveLevel).round()
  }
  character.potionPassives[dataId] = passiveData
}

function characterSetUpgradeRankPotionPassive(character, rank) {
  assert(rank > 0 && rank <= kCultivationRankMax)
  character.potionPassives['upgradeRank'] = {
    id: 'upgradeRank',
    priority: 3498,
    level: rank,
    description: engine.locale('passive_upgradeRank_${rank}_description'),
    isPermanent: true,
  }
}

function characterConsumePotion(entity, item) {
  assert(item.category == kItemCategoryPotion)

  engine.info('${entity.name}服用了${item.name}')

  final mainAffix = item.affixes.first
  switch (mainAffix.id) {
    case 'overheal': {
      setCharacterLife(entity, entity.life + mainAffix.value, overflow: true)
    }
    else: {
      characterSetPotionPassive(entity, passiveData.id, level: passiveData.level)
    }
  }

  for (final passiveData in item.affixes.skip(1)) {
    characterSetPotionPassive(entity, passiveData.id, level: passiveData.level)
  }
  // 重新计算角色状态值
  characterCalculateStats(entity, rejuvenate: false)

  entityLose(entity, item)
}
