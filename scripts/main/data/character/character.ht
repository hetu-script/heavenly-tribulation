export 'battle_entity.ht'

// 进行某些互动的时候的判定阈值
const kCharacterImpressionCheck = 10

const kSameRaceScore = 5.0
const kSameSectScore = 5.0
const kGenerationScore = 5.0
const kPeerScore = 2.0
const kSameHomeLocationScore = 5.0

const _kPregnancyTime = Constants.ticksPerMonth * 9
const _kPregnancyTimeVariable = Constants.ticksPerMonth * 2
const kChildTime = Constants.ticksPerYear * 12

const _kCharacterRandomAgeMin = 12
const _kCharacterRandomAgeMax = 29

/// 主要动机决定了门派发展类型
/// 除了无为之外，主要动机都有正反两面
const kMajorMotivations= [
  'wuwei', // 无欲：不愿意加入任何门派
  'cultivation', // 修真：悟道，功法，战斗
  'immortality', // 长生：宗教，等级，境界
  'chivalry', // 任侠：江湖豪杰
  'entrepreneur', // 权霸：扩张国家领地，发展下属和附庸
  'wealth', // 财富：经营商号，积累钱币和灵石
  'pleasure', // 欢愉：享乐，赌博，情色
]

// 次要动机
const kMinorMotivations = [
  // 人物关系动机
  'romance',
  'friendship',
  'spouse',
  'child',
  'shifu',
  'tudi',
  // 悟道衍生动机
  'enthusiastic', // 武痴
  'conqueror', // 征服者
  'protector', // 守护者
  // 长生衍生动机
  'missionary', // 普度世人
  'religious', // 出家人：侍奉神明
  'heritage', // 传承：寻找自身财富、知识和地位的继承人
  // 侠义衍生动机
  'swornBrotherhood', // 义气
  'goldPromise', // 一诺千金
  'gallantry', // 英雄豪杰
  // 财富衍生动机
  'everyOneIsForHimself', // 人人为己
  'asLongAsProfit', // 在商言商
  'monopolism', // 垄断
  // 权霸衍生动机
  // 欢愉衍生动机
  'adventurer', // 冒险精神：赌博，追求刺激
  'collector', // 收藏家：收藏和鉴定法宝
  'erotic', // 纵情欲海
  // 无欲衍生动机
  'celibate', // 独身
  'dink', // 无后
  'escapist', // 避世：避免接触其他人，隐瞒自己的过往
  // 负面动机
  'avenger', // 复仇
  'prankster', // 捉弄
  'plunderer', // 掠夺
  'destroyer', // 破坏
  'domination', // 支配：获取仆役和姬妾
]

const kRelationshipCategories = [
  'family', // 由婚姻或血缘构成的家族关系
  'sect', // 由拜师或收徒构成的门派关系
  'romance', // 由爱情构成的浪漫关系
  'friendship', // 由友谊或仇恨构成的交往关系
  'domination', // 由主仆或姬妾构成的支配关系
]

/// 所有的关系类型名称
/// 及其对应的亲密值
/// TODO: 离婚或者退出家族、门派后如何处理？
const kRelationshipScore = {
  family: {
    // 直接关系
    'spouse': 40, // 丈夫妻子

    // 血缘关系
    'parent': 45, // 父母
    'child': 45, // 子女
    'siblings': 35, // 兄弟姐妹
    
    // 前任
    'exspouse': 25,

    // 隔代
    'grandParent': 40, // 祖父母
    'grandChild': 40, // 孙辈
    
    // 没有特别称呼的关系
    'farfamily': 30, // 亲族，有血缘关系的亲属
    'farkin': 25, // 同族，同一个家族但没有血缘关系
    
    // 再婚关系
    'stepParent': 30, // 继父母
    'stepChild': 30, // 继子女
    'stepSiblings': 30, // 继兄弟姐妹

    // 收养关系
    'fosterChild': 40, // 养子女
    'fosterParent': 45, // 养父母

    // 结义关系
    'swornSibling': 45, // 义兄弟姐妹
  },
  sect: {
    'shifu': 45, // 师父
    'tudi': 40, // 徒弟
    'tongmen': 20, // 同门 (同一个师父)
    
    // 前任
    'exshifu': 25,
    'extudi': 25,

    'shizu': 30, // 师祖
    'tusun': 25, // 徒孙

    'qianbei': 10, // 前辈
    'wanbei': 10, // 晚辈
  }
}

function createBirthTimestamp({min = _kCharacterRandomAgeMin, max = _kCharacterRandomAgeMax}) {
  assert(min > 0)
  const age = random.nextInt(max - min) + min
  const randomDateInAYear = random.nextInt(Constants.ticksPerYear)
  return game.timestamp - (age * Constants.ticksPerYear + randomDateInAYear)
}

/// 生成寿命
/// 每次提升境界时寿命会重新计算
function createLifespan(cultivationRank) {
  let { min, max } = getLifeSpanForRank(cultivationRank)
  let minTick = min * Constants.ticksPerYear
  let maxTick = max * Constants.ticksPerYear
  let randomSpan = minTick + random.nextInt(maxTick)
  return randomSpan
}

function getCharacterFameRank(character) {
  let fame = character.fame
  for (var i in range(kFameRankMax + 1)) {
    if (fame < fameForRank(i + 1)) {
      return i
    }
  }
  return kFameRankMax
}

function getCharacterFameString(character) {
  return engine.locale('fame_${getCharacterFameRank(character)}')
}

function getCharacterInfamyRank(character) {
  let infamy = character.infamy
  for (var i in range(kFameRankMax + 1)) {
    if (infamy < fameForRank(i + 1)) {
      return i
    }
  }
  return kFameRankMax
}

function getCharacterInfamyString(character) {
  return engine.locale('infamy_${getCharacterInfamyRank(character)}')
}

/// 容貌评价的计算公式
/// favor 是本角色的容貌偏好，0 <= favor <= 100
/// charisma 代表对方容貌在大众眼中的评价，0 <= charisma <= 100
/// 此公式以这两个数值为基础，计算对另一个角色的容貌的评价
/// 对方容貌越接近自己的偏好，或对方容貌值越接近100，评价都会更高
/// 最终得分最高10分，最低可能是负值
function _calculateCharismaScore(favor, charisma) -> float {
  assert(0 <= favor && favor <= kAttributeValueMax)
  assert(0 <= charisma && charisma <= kAttributeValueMax)
  if (charisma < ((favor + kAttributeValueMax) / 2)) {
    return ((-(charisma - favor) * (charisma - favor)) / 20 + kAttributeValueMax) / 10
  } else {
    return ((-(charisma - kAttributeValueMax) * (charisma - kAttributeValueMax)) / 20 + kAttributeValueMax) / 10
  }
}

/// 第一印象算法
/// 用于第一次创建羁绊时的初始评价分
function _calculateFirstImpression(subject, target) {
  /// 是否符合容貌偏好
  let score = _calculateCharismaScore(subject.charismaFavor, target.stats.charisma)
  /// 是否早已名声在外
  score += target.fame / 10
  /// 是否是同一种族
  if (subject.race == target.race) {
    score += kSameRaceScore
  }
  /// 是否当前属于同一门派
  if (subject.sectId && subject.sectId == target.sectId) {
    score += kSameSectScore
    // final sect = game.sects[subject.sectId]
    // assert(sect != null, 'sect not exist: ${subject.sectId}')
    // if (target.jobRank > subject.jobRank) {
    //   score += kGenerationScore
    // } else if (targetJob.peer > subjectJob.peer) {
    //   score += kPeerScore
    // }
  }
  /// 是否有亲戚关系
  if (subject.familyId && subject.familyId == target.familyId) {
    score += kSameFamilyScore
  }
  /// 是否当前住在同一个城市，这里不考虑还拥有其他住所的情况
  if (subject.homeLocationId == target.homeLocationId) {
    score += kSameHomeLocationScore
  }
  
  return score.toFixed(2)
}

const kSameMotivationScore = 5.0

/// 浪漫关系初始亲密度算法
/// 用于第一次创建浪漫关系时的初始亲密度
function _calculateFirstRomance(subject, target) {
  // 是否符合容貌偏好
  let score = _calculateCharismaScore(subject.charismaFavor, target.stats.charisma)
  // 是否具有相似人格
  for (final id in Constants.personalities) {
    final diff = (subject.personality[id] - target.personality[id]).abs()
    score += 1 - diff / 100
  }
  // 是否具有相似动机
  for (final motivation in subject.motivations) {
    if (target.motivations.contains(motivation)) {
      score += kSameMotivationScore
    }
  }

  return score
}

/// 羁绊：保存了对其他角色的主观印象和评价
/// 羁绊不一定是双向的，可能只有单方面的数据
struct Bond {
  constructor ({
    character,
    target,
    score = 0,
    haveMet = false,
  }) {
    assert(character != null)
    assert(target != null)

    this.id = target.id
    this.name = target.name
    // 自己对对象的好感度评价
    this.score = score
    // 自己是否见过此对象
    this.haveMet = haveMet
    // 注意这里是反过来的：
    // 记录了对象和自己的关系
    // 注意可以同时存在多种关系
    // 这里只保存关系的 kind
    this.relationships = []

    character.bonds[this.id] = this
  }
}

/// 家族或门派成员的地位数据
/// 包含了职级、头衔和贡献值
/// 贡献值可能是负的
struct MemberData {
  constructor ({
    id,
    rank = 0,
    peer,
    generation,
    isAbsent = false,
  }) {
    this.id = id
    this.rank = rank
    this.peer = peer
    this.generation = generation
    this.isAbsent = isAbsent
  }
}

/// 获取或创建新的家族数据
function getFamily(character) {
  if (character.familyId == null) {
    final familyName = (character.surName ?? character.name) + engine.locale('familyName')
    character.familyId = familyName + '_${crypto.randomUID(withTime: true)}'
    assert(!game.families.containsKey(character.familyId))
    family = game.families[character.familyId] = {
      id: character.familyId,
      name: familyName,
      membersData: {},
    }
    family.membersData[character.id] = MemberData
  } else {
    family = game.families[character.familyId]
    assert(family != null, 'family not exist: ${character.familyId}')
  }
  return family
}

function createSpouseRelationships(husband, wife) {
  husband.familyRelationships.spouseIds.add(wife.id)
  wife.familyRelationships.spouseIds.add(husband.id)
  wife.familyIds.addAll(husband.familyIds)
  wife.familyId = husband.familyId
  characterMet(husband, wife)

  updateBond(husband, wife, score: kRelationshipScore.family.spouse, relationship: {
    kind: 'spouse',
    operation: 'add',
  })
  updateBond(wife, husband, score: kRelationshipScore.family.spouse, relationship: {
    kind: 'spouse',
    operation: 'add',
  })
}

function createChildRelationships(father, mother, child) {
  // 孩子所属的家族是父亲的当前家族
  // 如果此时尚未建立家族，会创建新的家族数据
  final family = getFamily(father)
  assert(!family.membersData.containsKey(child.id))
  family.membersData[child.id] = MemberData(
    id: child.id,
    // 辈分是父母的辈分数字 + 1
    generation: mother.familyGeneration + 1,
    // 同辈序号是父亲当前孩子的数量
    peer: father.childIds.length,
  )
  child.familyId = father.familyId

  child.familyRelationships.fatherId = father.id
  child.familyRelationships.motherId = mother.id
  child.familyRelationships.siblingIds = [
    ...father.familyRelationships.childIds,
    ...mother.familyRelationships.childIds,
  ].toSet().toList()

  father.familyRelationships.childIds.add(child.id)
  mother.familyRelationships.childIds.add(child.id)
  
  updateBond(child, father, score: kRelationshipScore.family.parent, relationship: {
    kind: 'parent',
    operation: 'add',
  })
  updateBond(child, mother, score: kRelationshipScore.family.parent, relationship: {
    kind: 'parent',
    operation: 'add',
  })
  updateBond(father, child, score: kRelationshipScore.family.child, relationship: {
    kind: 'child',
    operation: 'add',
  })
  updateBond(mother, child, score: kRelationshipScore.family.child, relationship: {
    kind: 'child',
    operation: 'add',
  })

  for (final siblingId in child.familyRelationships.siblingIds) {
    final sibling = game.characters[siblingId]
    sibling.familyRelationships.siblingIds.add(child.id)
    updateBond(child, sibling, score: kRelationshipScore.family.siblings, relationship: {
      kind: 'siblings',
      operation: 'add',
    })
    updateBond(sibling, child, score: kRelationshipScore.family.siblings, relationship: {
      kind: 'siblings',
      operation: 'add',
    })
  }
}

function createShituRelationships(shifu, tudi) {
  assert(tudi.sectId == shifu.sectId, '师徒必须属于同一个门派!')
  assert(tudi.shituRelationships.shifuIds.contains(shifu.id) == false, '已经存在师徒关系，不能再次拜师!')

  tudi.shituRelationships.shifuIds.add(shifu.id)
  tudi.shituRelationships.tongmenIds = shifu.shituRelationships.tudiIds.toList()

  shifu.shituRelationships.tudiIds.add(tudi.id)
  
  updateBond(shifu, tudi, score: kRelationshipScore.sect.tudi, relationship: {
    kind: 'tudi',
    operation: 'add',
  })
  updateBond(tudi, shifu, score: kRelationshipScore.sect.shifu, relationship: {
    kind: 'shifu',
    operation: 'add',
  })
  for (final siblingId in tudi.shituRelationships.tongmenIds) {
    final sibling = game.characters[siblingId]
    sibling.shituRelationships.tongmenIds.add(tudi.id)
    updateBond(tudi, sibling, score: kRelationshipScore.sect.tongmen, relationship: {
      kind: 'tongmen',
      operation: 'add',
    })
    updateBond(sibling, tudi, score: kRelationshipScore.sect.tongmen, relationship: {
      kind: 'tongmen',
      operation: 'add',
    })
  }
}

/// 创建一个婴儿
/// 注意创建一个婴儿和创建浪漫、夫妻、师徒关系等不同，是通过一个构造函数来实现
/// 因为婴儿此时尚未有实体，而其他的关系则是建立一些已经存在的实体的关系
struct Baby {
  constructor ({
    id,
    father,
    mother,
    isFemale,
    generationName,
    shortName,
    incurIncident = true,
  }) {
    assert(father != null)
    assert(mother != null)
    this.entityType = kEntityTypeBaby

    mother.isPregnant = true

    this.fatherId = father.id
    this.motherId = mother.id
    this.conceptionTimestamp = game.timestamp
    this.pregnancyTime = Math.gaussianNoise(
      _kPregnancyTime,
      _kPregnancyTimeVariable, 
      randomGenerator: random,
    )
    this.isFemale = isFemale ?? random.nextBool()
    this.surName = father.surName
    this.generationName = generationName
    
    if (shortName) {
      this.shortName = (generationName ?? '') + shortName
    } else {
      let randomName
      let conflict = false
      do {
        randomName = generateCharacterName(
          isFemale: this.isFemale,
          surName: this.surName,
          middleName: generationName,
        )
        conflict = game.characters[randomName.fullName] != null
      } while (conflict)
      this.name = randomName.fullName
      this.surName = randomName.surName
      this.generationName = randomName.middleName
      this.shortName = randomName.shortName
    }
    this.id = id ?? this.name
    if (game.babies.containsKey(this.id)) {
      engine.warn('已经存在 id 为 ${this.id} 的婴儿。旧数据将会被覆盖。')
    }
    game.babies[this.id] = this
    const incidentContent = engine.locale('characterConception', interpolations: [
      mother.name,
      father.name,
      this.name,
    ])
    if (incurIncident) {
      Incident(
        message: incidentContent,
        subjectId: father.id,
        targetId: mother.id,
        idealistic: -2,
      )
    } else {
      engine.info(incidentContent)
    }
  }
}

struct Character {
  constructor ({
    id,
    isFemale,
    icon,
    illustration,
    skin,
    shipModel,
    name,
    surName, // 姓氏
    shortName,
    generationName,
    generateName = true,
    description,
    level,
    rank,
    attributes,
    stats,
    allocateSkills = true,
    generateDeck = true,
    cultivationFavor,
    cultivationStyle,
    birthTimestamp,
    exp,
    skillPoints,
    worldId,
    worldPositionX,
    worldPositionY,
    locationId,
    isNewBorn = false,
    fatherId,
    motherId,
  }) {
    // 生成战斗单位相关数据，并写入当前对象
    // 不使用继承主要是因为这些数据经常会改动，直接写在这个对象上的话会更清晰
    const battleInfo = BattleEntity(
      id: id,
      isFemale: isFemale,
      icon: icon,
      illustration: illustration,
      skin: skin,
      name: name,
      shortName: shortName,
      surName: surName,
      generationName: generationName,
      generateName: generateName,
      description: description,
      level: level,
      rank: rank,
      attributes: attributes,
      stats: stats,
      allocateSkills: allocateSkills,
      generateDeck: generateDeck,
      cultivationFavor: cultivationFavor,
      cultivationStyle: cultivationStyle,
    )
    Object.assign(this, battleInfo)
    
    this.entityType = kEntityTypeCharacter

    if (game.characters.containsKey(this.id)) {
      engine.warn('已经存在 id 为 ${this.id} 的角色。旧数据将会被覆盖。')
    }
    game.characters[this.id] = this

    // this.entityType = 'character'
    // this.category = category ?? 'character'

    this.shipModel = shipModel ?? 'ship1'

    // 转换后的修为经验值，经验值达到下一等级需求后，自动扣除并提升修为能级
    this.exp = exp ?? 0
    this.expForLevel = expForLevel(this.level)
    // 未分配的修为点数，修为点数可以用来在天赋盘上升级天赋
    this.skillPoints = skillPoints ?? 0

    this.worldId = worldId ?? world?.id

    // let atWorld = universe[this.worldId]
    
    this.charismaFavor =  Math.gaussianNoise(
      kNonBattleAttributeValueAverage,
      kNonBattleAttributeValueDeviation,
      min: 1,
      max: kAttributeValueMax,
      randomGenerator: random,
    ).toInt()

    // 该人物的事件触发选项
    this.flags = {
      monthly: {},
    }

    // 该角色曾经拥有过的称号，只保存 id
    // this.titleIds = []
    // if (titleId != null) {
    //   this.titleIds.add(titleId)
    // }
    // this.titleId = titleId

    // 声望，对此人好评的人的数量
    this.fame = 0
    // 恶名，对此人差评的人的数量
    this.infamy = 0

    // 该角色的人格纬度
    // 角色的人格是天生的，之后不会再发生改变
    // 人格决定了角色对人或者事物的看法
    // 人格一共包含18个层面，其中最重要的是三观，决定了最基础的羁绊评价系统
    // 其次是关于他人的5个，关于事物的5个，以及关于自己的5个层面
    // 人格数值最小 -50 最大 +50
    this.personality = {}
    for (final id in Constants.personalities) {
      this.personality[id] = (random.nextDouble() * 100.0 - 50.0).toInt()
    }

    // 动机列表
    // 动机决定了角色如何安排行动，以及角色对事物的看法
    // 和人格不同，动机是后天获得的
    // 主要动机会永久存在，次要动机可能持续多年存在
    // 动机没有程度的区分，只有有或者没有
    // 角色先天默认会有一个主要动机，就是动机列表的第一项
    // 先天动机只会是六种主要动机之一
    // 角色可能随着时间推移获得新的次要动机，但不会再获得其他主要动机
    this.motivations = []
    this.motivations.add(random.nextIterable(kMajorMotivations))

    // 情绪列表
    // 情绪决定了角色对别人行动的反应
    // 和人格不同，情绪是后天获得的
    // 相比思想和动机，情绪十分短暂，可能只是持续几个月或几天
    this.emotions = {}

    // 该角色当前的事项
    // 门派任务和悬赏任务同样以事项形式保存在这里
    this.journals = {}
    // 当前追踪的事项id列表
    // 追踪的事项会以漂浮文字显示在屏幕右上角
    this.activeJournalIds = []
    
    // 这些列表保存的是incident的index
    // 该角色经历过的事情
    this.experienced = []
    // 该对象听说的事情
    this.known = []

    // 该角色和角色的交互历史
    // key是角色id，value是一个bond data
    // bond数据结构
    this.bonds = {}

    // 角色的爱情、仇敌、朋友关系，直接保存的对方的角色id
    this.friendIds = []
    this.romanceIds = []
    this.enemyIds = []

    // 角色目前和曾加入过的家族，保存的是家族数据的 id
    // 家族的具体数据保存在 game.families 中
    this.familyIds = []
    // 妻子结婚后会加入丈夫的家族，但仍保留原本的家族的关系和familyId
    // 当前的family
    // this.familyId = null
    // 和角色有亲属关系的其他角色的 id
    this.familyRelationships = {
      fatherId: null,
      motherId: null,
      childIds: [],
      siblingIds: [],
      spouseIds: [],
    }

    // 角色目前和曾加入过的门派，保存的是门派数据的 id
    this.sectIds = []
    // 角色的门派倾向，决定了角色更愿意于加入哪种类型的门派
    this.sectFavor = this.motivations.first
    // 当前的门派
    // this.sectId = null
    // 和角色有师徒关系的其他角色的 id
    this.shituRelationships = {
      shifuIds: [],
      tudiIds: [],
      tongmenIds: [],
    }

    // this.titleId = null
    
    /// 每个角色的家是一个单例对象。
    /// 尽管角色可以在多个地点拥有家，但指向的都是同一个场景
    /// 此处创建的家宅场景此时尚未绑定到任何城市
    final home = Location(
      id: '${this.id})_${kLocationKindHome}',
      category: 'site',
      kind: kLocationKindHome,
      name: engine.locale('characterHomeSite', interpolations: [this.name]),
      managerId: this.id,
      isAffiliate: true,
    )
    this.homeSiteId = home.id
    // 所有该角色拥有住所的城市的 id 列表
    this.homeLocationIds = []
    // this.homeLocationId = null // 主要住所 id

    if (isNewBorn) {
      assert(father != null)
      assert(mother != null)
      assert(birthTimestamp != null, '新生儿必须指定出生时间!')
      final father = game.characters[fatherId]
      final mother = game.characters[motherId]
      this.birthTimestamp = birthTimestamp
      createChildRelationships(father, mother, this)
      // 出生事件会修改自身，需要放在最后处理
      const incidentContent = engine.locale('characterBorn',
        interpolations: [
          mother.name,
          this.name,
        ])
      Incident(
        message: incidentContent,
        subjectId: mother.id,
        targetId: this.id,
        locationId: locationId,
        orderly: 1,
        idealistic: -1,
      )
      characterMet(mother, this, firstImpression: false)
      characterMet(father, this, firstImpression: false)
      if (locationId != null) {
        this.birthLocationId = locationId
      }
    }
    
    if (locationId) {
      const location = game.locations[locationId]
      this.worldPosition = {
        left: location.worldPosition?.left,
        top: location.worldPosition?.top,
      }
      setCharacterHome(this, location)
    } else {
      if (worldPositionX != null && worldPositionY != null) {
        this.worldPosition = {
          left: worldPositionX,
          top: worldPositionY,
        }
      }
    }
    
    // age 的格式是 timestamp, 精确到 tick. 
    if (this.birthTimestamp == null) {
      this.birthTimestamp = createBirthTimestamp()
    }

    /// 寿命必须在已知境界之后计算
    this.deathTimestamp = this.birthTimestamp + createLifespan(this.rank)
    
    // 随角色移动的孩童（Baby 对象），这里只保存id
    this.carrying = []

    // 角色管辖的场景 ID 列表
    this.managingLocationIds = []

    // 角色的逻辑更新日
    // 为了避免游戏卡顿随机分布在每个月的1-30号之间
    this.updateDay = random.nextInt(30) + 1
  }
}

function getCharacterAge(character) {
  return (game.timestamp - character.birthTimestamp) ~/ Constants.ticksPerYear
}

function getCharacterAgeString(character) {
  return formatAgeString(game.timestamp - character.birthTimestamp)
}

function getCharacterRestLifespanString(character) {
  return formatAgeString(character.deathTimestamp - game.timestamp)
}

function getCharacterBirthDayString(character) {
  return formatDateTimeString(character.birthTimestamp, format: 'date.md')
}

function getCharacterBirthDateString(character) {
  return formatDateTimeString(character.birthTimestamp, format: 'date.ymd')
}

function haveMet(subject, target) {
  if (subject == target) return true
  if (target.entityType != 'character') return true

  assert(subject.entityType == 'character')

  const bond = subject.bonds[target.id]
  if (bond && bond.haveMet) {
    return true
  } else {
    // 这里必须传 null
    return null
  }
}

/// 计算第一印象分
function _characterMet(subject, target, { firstImpression = true, incurIncident }) {
  assert(subject != null && target != null)
  assert(subject.entityType == 'character')
  assert(target.entityType == 'character')
  let bond = subject.bonds[target.id] 
  if (bond != null) {
    if (bond.haveMet) {
      return bond
    } else {
      bond.haveMet = true
    }
  } else {
    bond = Bond(character: subject, target: target, haveMet: true)
  }

  let score
  if (firstImpression) {
    score = _calculateFirstImpression(subject, target)
  } else {
    score = _calculateCharismaScore(subject.charismaFavor, target.stats.charisma)
  }
  updateBond(subject, target, score: score)
  
  let incidentContent
  if (bond.score < -kCharacterImpressionCheck) {
    incidentContent = engine.locale('characterFirstMeetHate', interpolations: [
      subject.name,
      target.name,
    ])
  } else if (bond.score >= kCharacterImpressionCheck) {
    incidentContent = engine.locale('characterFirstMeetLike', interpolations: [
      subject.name,
      target.name,
    ])
  } else {
    incidentContent = engine.locale('characterFirstMeetNormal', interpolations: [
      subject.name,
      target.name,
    ])
  }
  if (incurIncident) {
    Incident(
      message: incidentContent,
      subjectId: subject.id, // 见面是一个单向事件
    )
  } else {
    engine.info(incidentContent)
  }
  return bond
}

function characterMet(subject, target, { firstImpression = true, incurIncident }) {
  if (subject == target) return null
  let bond = _characterMet(subject, target, firstImpression: firstImpression, incurIncident: incurIncident)
  _characterMet(target, subject, firstImpression: firstImpression, incurIncident: incurIncident)
  return bond
}

function getCharacterHomeSite(character, {worldId}) {
  if (character.homeSiteId == null) {
    engine.warn('角色 ${character.name} 目前没有住宅！')
    return
  }
  
  // let atWorld = worldId != null ? universe[worldId] : world
  assert(game.locations.containsKey(character.homeSiteId))
  return game.locations[character.homeSiteId]
}

function clearCharacterHomeLocations(character, {worldId}) {
  // let atWorld = worldId != null ? universe[worldId] : world
  for (final locId in character.homeLocationIds) {
    final location = game.locations[locId]
    location.residents.remove(character.id)
  }
  character.homeLocationIds.clear()
}

function getCharacterHomeLocation(character) {
  return game.locations[character.homeLocationId]
}

function setCharacterHome(character, location, { moveToHome = true, incurIncident = true }) {
  if (character.homeLocationId == location.id) {
    engine.warn('角色 ${character.name} 已经定居在 ${location.name} 了！')
    return
  }
  assert(!location.residents.contains(character.id), 'location already has resident: ${character.id}')
  final oldLocation = game.locations[character.homeLocationId]
  if (oldLocation != null) {
    oldLocation.residents.remove(character.id)
  }
  if (!character.homeLocationIds.contains(location.id)) {
    character.homeLocationIds.add(location.id)
  }
  location.residents.add(character.id)
  character.homeLocationId = location.id
  if (moveToHome) {
    let homeSiteId = '${character.id}_${kLocationKindHome}'
    character.locationId = homeSiteId
    character.worldPosition = {
      left: location.worldPosition.left,
      top: location.worldPosition.top,
    }
  }
  let incidentContent
  incidentContent = engine.locale('characterSettle', interpolations: [
    character.name,
    location.name,
  ])
  if (incurIncident) {
    Incident(
      message: incidentContent,
      subjectId: character.id,
    )
  } else {
    engine.info(incidentContent)
  }
  
  return
}

function getCharacterWorldPosition(character) {
  return character.worldPosition
}

// 赋值时位置可以是Null，但worldId为Null则会被忽略
function setCharacterWorldPosition(character, left, top, {worldId}) {
  if (left == null || top == null) {
    character.worldPosition = null
  } else {
    character.worldPosition = { left, top }
  }
  if (worldId != null) {
    character.worldId = worldId
  }
}

// function addCharacter(character) {
//   // assert(character != null)
//   // engine.debug('向当前世界添加新角色：${character.id}')
//   game.characters[character.id] = character
// }

// function addCharacters(chars: List) {
//   for (const char in chars) {
//     addCharacter(char)
//   }
// }

/// 如果不传 ids，就返回所有的角色
function getCharacters([ids]) {
  if (ids?.isNotEmpty) {
    return game.characters.values.where( (char) => char.id in ids)
  } else {
    return game.characters.values
  }
}

function getCharactersOnWorldMap([ worldId ]) {
  worldId ??= world.id
  return game.characters.values.where((char) {
    if (char.worldId != worldId) return false
    if (char.worldPosition == null) return false
    if (char.locationId != null) return false
    return true
  })
}

function getCharactersAtWorldMapPosition(left, top, [ worldId ]) {
  worldId ??= world?.id
  return game.characters.values.where((char) {
    if (char.worldId != worldId) return false
    if (char.worldPosition == null) return false
    if (char.worldPosition.left != left || char.worldPosition.top != top) return false
    if (char.locationId != null) return false
    return true
  })
}

function getCharactersAtLocation(location) {
  return game.characters.values.where((char) {
    if (char.locationId != location.id) return false
    return true
  })
}

function getResidingCharacters(location) {
  // let atWorld = universe[location.worldId]
  location.residents.map((id) {
    final homeSiteId = '${id}_${kLocationKindHome}'
    final homeSite = game.locations[homeSiteId]
    assert(homeSite != null, 'home is null, id: ${homeSiteId}')
    final character = game.characters[homeSite.managerId]
    assert(character != null, 'home owner is null, home id: ${homeSiteId}, owner id: ${homeSite.managerId}')
    return character
  }).toList()
}

// function getResidingCharactersIds(location) {
//   return location.residents
  // let atWorld = universe[location.worldId]
  // location.residents.map((id) {
  //   assert(game.locations.containsKey(id))
  //   final homeSite = game.locations[id]
  //   return homeSite.managerId
  // }).toList()
// }

// function getNpcs() {
//   return game.characters.values.where( (char) => (char.id != game.heroId))
// }

function removeCharacterById(id: string) {
  engine.warn('正在移除ID为 [${id}] 的角色。')
  // TODO: 角色相关的信息，例如门派首领，拥有的建筑等等需要一并清除才行
  delete game.characters[id]
}

/// 更新羁绊数据，如果之前不存在羁绊会创建新的羁绊数据
function updateBond(subject, target, {
  score,
  relationship: {},
}) {
  assert(score != null, 'score cannot be null when updating bond!')
  let bond = subject.bonds[target.id]
  if (bond == null) {
    bond = Bond(character: subject, target: target)
  }
  score = score.toDouble().toFixed(2)
  bond.score += score
  // TODO: 朋友和仇敌的类型是根据当前好感度动态变化的
  // if (bond.score < 0) {
  //   if (!bond.relationships.contains('enemy')) {
  //     bond.relationships.add('enemy')
  //   }
  // }
  // else if (bond.score > 0 && bond.haveMet) {
  //   if (!bond.relationships.contains('friend')) {
  //     bond.relationships.add('friend')
  //   }
  // }
  if (relationship != null) {
    if (relationship.operation == 'add') {
      if (!bond.relationships.contains(relationship.kind)) {
        engine.warn('${subject.name} 现在是 ${target.name} 的 ${engine.locale(relationship.kind)}')
        bond.relationships.add(relationship.kind)
      }
    } else if (relationship.operation == 'remove') {
      bond.relationships.remove(relationship.kind)
      engine.warn('${subject.name} 不再是 ${target.name} 的 ${engine.locale(relationship.kind)}')
      return
    }
  }
  engine.info('更新 ${subject.name} 对 ${target.name} 的羁绊，好感变动：${score}')
}

function getBondScore(subject, target) {
  let bond = subject.bonds[target.id]
  if (bond != null) {
    return bond.score
  } else {
    return 0
  }
}

/// 提升NPC的修为等级，NPC不会有天赋盘，所以这里不处理经验值和天赋点数等问题
function characterCultivationLevelUp(character, {level = 1, incurIncident = true }) {
  assert(level > 0)
  final levelMax = maxLevelForRank(character.rank)
  if (character.level >= levelMax) {
    engine.warn('角色 ${character.name} 已经达到当前境界允许的最高等级，无法再提升。')
    return
  }

  let originalLevel = character.level

  character.level += level

  if (character.level > levelMax) {
    character.level = levelMax
  }

  if (character.level <= originalLevel) {
    engine.warn('角色 ${character.name} 已经达到当前境界允许的最高等级，无法再提升。')
    return
  }

  const incidentContent = engine.locale('characterCultivationLevelUp', interpolations: [
    character.name,
    character.level,
  ])
  if (incurIncident) {
    Incident(
      message: incidentContent,
      subjectId: character.id,
    )
  }
  engine.info(incidentContent)
  return character.level
}

/// 提升NPC的境界
/// 和玩家只能一级一级提升不同，NPC可以直接提升多个境界
function characterRankUp(character, {rank, incurIncident = true }) {
  if (character.rank >= kCultivationRankMax) {
    engine.warn('角色已经达到最高境界，无法再提升。')
    return character.rank
  }

  if (rank != null) {
    assert(rank > character.rank)
    character.rank += rank
  } else {
    ++character.rank
  }

  if (character.rank > kCultivationRankMax) {
    character.rank = kCultivationRankMax
  }

  const incidentContent = engine.locale('characterCultivationRankUp', interpolations: [
    character.name,
    getCultivationRankName(character),
  ])
  if (incurIncident) {
    Incident(
      message: incidentContent,
      subjectId: character.id,
    )
  }
  engine.info(incidentContent)

  return character.rank
}

function characterGainExp(character, value) {
  character.exp += value

  const incidentContent = engine.locale('characterExpGained', interpolations: [
    character.name, 
    value,
  ])
  Incident(
    message: incidentContent,
    subjectId: hero.id,
  )
}

function characterMakeContribution(character, data, { incurIncident = true }) {
  let contribution = data.stackSize ?? data.amount ?? 0
  if (contribution <= 0) {
    engine.warn('contribution amount is less than or equal to 0, cannot collect!')
    return false
  }

  let contributionTarget
  if (data.sectId) {
    // 如果是门派领地的任务
    const sect = game.sects[data.sectId]
    assert(sect != null,
      'sect not found in contribution pack: ${data.sectId}')
    const memberData = sect.membersData[character.id]
    assert(memberData != null,
      'member data not found for character id: ${character.id} in sect: ${sect.id}')
    if (character.sectId == data.sectId) {
      // 如果主角是该门派成员
      assert(memberData != null,
          'Member data not found in sect [${sect.id}], member id: ${character.id}');
      memberData.contribution += contribution;
      // 记录门派成员当月贡献
      sect.flags.monthly.contributions[character.id] += contribution;
    } else {
      contribution = contribution ~/ 2
      // 非门派成员功勋减半
      if (memberData == null) {
        memberData = MemberData(
          id: character.id,
          rank: -1,
          isAbsent: true,
        )
        memberData.contribution = contribution;
        sect.membersData[character.id] = memberData;
      } else {
        memberData.contribution += contribution;
      }
    }
    contributionTarget = sect.name;
  } else {
    // 非门派领地任务，同样可以获得功勋，但直接保存在城市数据中
    const location = game.locations[data.locationId]
    assert(location != null,
      'location not found in contribution pack: ${data.locationId}')
    contributionTarget = location.name;
    location.contributions[character.id] += contribution;
  }
  
  let incidentContent = engine.locale('characterMakeContribution',
    interpolations: [
      character.name,
      contributionTarget,
      contribution,
    ])
  if (incurIncident) {
    Incident(
      message: incidentContent,
      subjectId: character.id,
      sectId: data.sectId,
      locationId: data.locationId,
      orderly: data.orderly,
      idealistic: data.idealistic,
      goodwill: data.goodwill,
    )
  } else {
    engine.info(incidentContent)
  }
  
  return true;
}
