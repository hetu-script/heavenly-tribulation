export 'battle_entity.ht'

// 进行某些互动的时候的判定阈值
const kCharacterImpressionCheck = 10

const kSameRaceScore = 5.0
const kSameOrganizationScore = 5.0
const kGenerationScore = 5.0
const kPeerScore = 2.0
const kSameHomeLocationScore = 5.0

const _kPregnancyTime = Constants.ticksPerMonth * 9
const _kPregnancyTimeVariable = Constants.ticksPerMonth * 2
const kChildTime = Constants.ticksPerYear * 12

const kParentCloseness = 45
const kSpouseCloseness = 40
const kSiblingCloseness = 30
const kGrandParentCloseness = 25
const kfarkinCloseness = 25
const kConcubineCloseness = 20

const kBaseRomanceScore = 5.0

const _kCharacterRandomAgeMin = 12
const _kCharacterRandomAgeMax = 29

/// 主要动机决定了门派发展类型
/// 除了无为之外，主要动机都有正反两面
const kMajorMotivations= [
  'wuwei', // 无欲：不愿意加入任何门派
  'cultivation', // 修真：悟道，功法，战斗
  'immortality', // 长生：宗教，等级，境界
  'chivalry', // 任侠：江湖豪杰
  'entrepreneur', // 权霸：扩张国家领地，发展下属和附庸
  'wealth', // 财富：经营商号，积累钱币和灵石
  'pleasure', // 欢愉：享乐，赌博，情色
]

// 次要动机
const kMinorMotivations = [
  // 人物关系动机
  'romance',
  'friendship',
  'spouse',
  'child',
  'shifu',
  'tudi',
  // 悟道衍生动机
  'enthusiastic', // 武痴
  'conqueror', // 征服者
  'protector', // 守护者
  // 长生衍生动机
  'missionary', // 普度世人
  'religious', // 出家人：侍奉神明
  'heritage', // 传承：寻找自身财富、知识和地位的继承人
  // 侠义衍生动机
  'swornBrotherhood', // 义气
  'goldPromise', // 一诺千金
  'gallantry', // 英雄豪杰
  // 财富衍生动机
  'everyOneIsForHimself', // 人人为己
  'asLongAsProfit', // 在商言商
  'monopolism', // 垄断
  // 权霸衍生动机
  // 欢愉衍生动机
  'adventurer', // 冒险精神：赌博，追求刺激
  'collector', // 收藏家：收藏和鉴定法宝
  'erotic', // 纵情欲海
  // 无欲衍生动机
  'celibate', // 独身
  'dink', // 无后
  'escapist', // 避世：避免接触其他人，隐瞒自己的过往
  // 负面动机
  'avenger', // 复仇
  'prankster', // 捉弄
  'plunderer', // 掠夺
  'destroyer', // 破坏
  'domination', // 支配：获取仆役和姬妾
]

const kRelationshipCategories = [
  'family', // 由婚姻或血缘构成的家族关系
  'sect', // 由拜师或收徒构成的门派关系
  'romance', // 由爱情构成的浪漫关系
  'friendship', // 由友谊或仇恨构成的交往关系
  'domination', // 由主仆或姬妾构成的支配关系
]

/// 所有的关系类型名称
/// 及其对应的亲密值
const kRelationshipScore = {
  family: {
    // 婚姻关系
    'spouse': 40, // 丈夫妻子

    // 血缘关系
    'parent': 45, // 父母
    'child': 45, // 子女
    'grandParent': 40, // 祖父母
    'grandChild': 40, // 孙辈
    'brothers': 35, // 兄弟
    'sisters': 35, // 姐妹

    // 没有特别称呼的关系
    'farfamily': 30, // 亲族，有血缘关系的亲属
    'farkin': 25, // 同族，同一个家族但没有血缘关系
    
    // 再婚关系
    'stepParent': 30, // 继父母
    'stepChild': 30, // 继子女
    'stepBrothers': 30, // 继兄弟
    'stepSisters': 30, // 继姐妹

    // 收养关系
    'fosterChild': 40, // 养子女
    'fosterParent': 45, // 养父母

    // 结义关系
    'swornSibling': 45, // 义兄弟姐妹
  },
  sect: {
    'shifu': 45, // 师父
    'grandShifu': 40, // 师父的师父
    'daolv': 40, // 道侣
    'tudi': 30, // 徒弟
    'grandTudi': 25, // 徒孙
    'tongmen': 20, // 同一个门派的其他人
    'luding': 15, // 炉鼎
  }
}

const kChildRelationships = [
  'child',
  'stepChild',
  'fosterChild',
]

const kLifespan = {
  '0': {
    min: 62,
    max: 87,
  },
  '1': {
    min: 75,
    max: 125,
  },
  '2': {
    min: 100, // 前一等级的中心点
    max: 200, // min + 前一等级跨度的两倍
  },
  '3': {
    min: 150,
    max: 350,
  },
  '4': {
    min: 250,
    max: 650,
  },
  '5': {
    min: 450,
    max: 1250,
  },
  '6': {
    min: 850,
    max: 2450,
  }
}

function createBirthTimestamp({min = _kCharacterRandomAgeMin, max = _kCharacterRandomAgeMax}) {
  assert(min > 0)
  const age = random.nextInt(max - min) + min
  const randomDateInAYear = random.nextInt(Constants.ticksPerYear)
  return game.timestamp - (age * Constants.ticksPerYear + randomDateInAYear)
}

/// 生成寿命
/// 每次提升境界时寿命会重新计算
function createLifespan(cultivationRank) {
  let { min, max } = kLifespan[cultivationRank]
  let minTick = min * Constants.ticksPerYear
  let maxTick = max * Constants.ticksPerYear
  let randomSpan = minTick + random.nextInt(maxTick)
  return randomSpan
}

function getCharacterFameRank(character) {
  let fame = character.fame
  for (var i in range(kFameRankMax + 1)) {
    if (fame < fameForRank(i + 1)) {
      return i
    }
  }
  return kFameRankMax
}

function getCharacterFameString(character) {
  return engine.locale('fame_${getCharacterFameRank(character)}')
}

function getCharacterInfamyRank(character) {
  let infamy = character.infamy
  for (var i in range(kFameRankMax + 1)) {
    if (infamy < fameForRank(i + 1)) {
      return i
    }
  }
  return kFameRankMax
}

function getCharacterInfamyString(character) {
  return engine.locale('infamy_${getCharacterInfamyRank(character)}')
}

/// 容貌评价的计算公式
/// favor 是本角色的容貌偏好，0 <= favor <= 100
/// charisma 代表对方容貌在大众眼中的评价，0 <= charisma <= 100
/// 此公式以这两个数值为基础，计算对另一个角色的容貌的评价
/// 对方容貌越接近自己的偏好，或对方容貌值越接近100，评价都会更高
/// 最终得分最高10分，最低可能是负值
function _calculateCharismaScore(favor, charisma) -> float {
  assert(0 <= favor && favor <= kAttributeValueMax)
  assert(0 <= charisma && charisma <= kAttributeValueMax)
  if (charisma < ((favor + kAttributeValueMax) / 2)) {
    return ((-(charisma - favor) * (charisma - favor)) / 20 + kAttributeValueMax) / 10
  } else {
    return ((-(charisma - kAttributeValueMax) * (charisma - kAttributeValueMax)) / 20 + kAttributeValueMax) / 10
  }
}

/// 第一印象算法
/// 用于第一次创建羁绊时的初始评价分
function _calculateFirstImpression(subject, target) {
  /// 是否符合容貌偏好
  let score = _calculateCharismaScore(subject.charismaFavor, target.stats.charisma)
  /// 是否早已名声在外
  score += target.fame / 10
  /// 是否是同一种族
  if (subject.race == target.race) {
    score += kSameRaceScore
  }
  /// 是否属于同一门派
  if (subject.organizationId && subject.organizationId == target.organizationId) {
    score += kSameOrganizationScore
    final organization = game.organizations[subject.organizationId]
    assert(organization != null, 'organization not exist: ${subject.organizationId}')
    final subjectJob = organization.membersData[subject.id]
    final targetJob = organization.membersData[target.id]
    if (targetJob.rank > subjectJob.rank) {
      score += kGenerationScore
    } else if (targetJob.peer > subjectJob.peer) {
      score += kPeerScore
    }
    // if (subjectJob > targetJob) {
    //   score += organization.characterId[target.id] * 2
    // }
  }
  /// 是否有亲戚关系
  let family = subject.relationships.family[target.id]
  if (family != null) {
    score += family.closeness / 10
  }
  /// 是否当前住在同一个据点，这里不考虑还拥有其他住所的情况
  if (subject.homeLocationId == target.homeLocationId) {
    score += kSameHomeLocationScore
  }
  
  return score.toFixed(2)
}

const kSameMotivationScore = 5.0

/// 浪漫关系初始亲密度算法
/// 用于第一次创建浪漫关系时的初始亲密度
function _calculateFirstRomance(subject, target) {
  // 是否符合容貌偏好
  let score = _calculateCharismaScore(subject.charismaFavor, target.stats.charisma)
  // 是否具有相似人格
  for (final id in Constants.personalities) {
    final diff = (subject.personality[id] - target.personality[id]).abs()
    score += 1 - diff / 100
  }
  // 是否具有相似动机
  for (final motivation in subject.motivations) {
    if (target.motivations.contains(motivation)) {
      score += kSameMotivationScore
    }
  }

  return score
}

/// 关系网中的个体的地位数据，家庭，师承和组织职位都使用这个数据
/// [generation] 辈分决定了地位，数字越大，地位越低
/// [peer] 同辈中的地位，数字越大，地位越低
struct MemberRankData {
  constructor ({
    characterId,
    rank,
    peer,
  }) {
    this.characterId = characterId
    this.rank = rank
    this.peer = peer
  }
}

/// 羁绊：人物对其他事物（角色，组织，物品，据点等）的主观印象和评价
/// 人物对其他人物的羁绊不一定是双向的，可能只有单方面的数据
struct Bond {
  constructor ({
    character,
    target,
    score = 0,
    haveMet = false,
  }) {
    assert(character != null)
    assert(target != null)

    this.id = target.id
    this.name = target.name
    // 好感度评价
    this.score = score
    // 是否见过此对象
    this.haveMet = haveMet
    // 关系类型，注意可以同时存在多种关系
    // 这里只保存关系的 kind
    this.relationships = []

    character.bonds[this.id] = this
  }
}

/// 关系：人和人之间的客观纽带，包括亲情，宗门，爱情，友情(仇恨)，雇佣等等
/// 分为：亲族、宗门、支配
/// | 类型  | score >= 0  | score >= 40         | score >= 80     |
/// | ----- | ----------- | ------------------- | --------------- |
/// | 亲族  | 远亲        | 血亲/结拜/收养/过继 | 夫妻/父母/儿女  |
/// | 宗门  | 同门        | 同宗                | 师承            |
/// | 支配  | 仆役/姬妾   | 高级仆役/侧室       | 主要仆役/正室   |
/// [category]: 'family', 'sect', 'romance', 'friendship'
/// [kind]: 'parent', 'spouse'
/// [addressName]: 称谓，称谓和关系本身的名字不同，比如对外将自己的wife称作妻子，但面对妻子时称呼对方娘子
/// 配偶、亲情和师徒关系会有[kind]，用来描述具体的关系，其他的关系则只有[category]
/// 两个人可能同时存在多种不同[category]关系，比如同时是师徒，又是爱人
/// 新创建关系时，会在双方的数据中同时创建对应的关系数据
/// 同时也会检索其他的关系图，将所有对应的关系数据添加到和这两个角色有关系的其他角色身上
/// 创建新关系数据时，如果不存在羁绊[Bond]，会自动添加羁绊数据
/// 创建关系时本身只有一个初始的亲近程度，0-50 ，数字越大，越亲近，典型值：45代表师父，儿女，40代表夫妻等等。
/// 但角色之间真正的好感度由羁绊[Bond]维护
/// 对于亲族、宗门和支配，在创建关系并使用初始亲密更新好感度后，便不会再变化
/// 但对于爱情、友情和仇恨关系，随着羁绊中的好感度变化，会改变关系的类型。
/// 在爱情、友情和仇恨关系的第一阶段，并不会出现在Bond.relationships中
struct Relationship {
  constructor ({
    characterId,
    category, 
    kind,
    addressName,
  }) {
    assert(characterId != null)
    assert(category != null)
    assert(kRelationshipCategories.contains(category))

    this.characterId = characterId
    this.category = category
    this.kind = kind

    // 某些关系，例如亲戚关系和宗门关系有专门的称呼
    if (addressName) {
      this.addressName = engine.locale(addressName)
    }
  }
}

/// 创建 **单方面** 的浪漫关系，意味着[subject]爱上了[target]
/// 这里仅涉及浪漫关系，夫妻关系会单独保存
/// 浪漫关系是单向的，不影响双方已经存在的其他关系
/// 注意：玩家角色并不能主动发起浪漫关系
/// 只能有概率的被动触发 NPC 爱上自己的事件
/// 只有对方爱上自己的情况下，才可以创建婚姻关系
/// TODO: 当亲密度在0以下，并再次降低时，关系会自动解除
function createRomance(subject, target) {
  if (subject.relationships['romance'].containsKey(target.id)) {
    engine.error('${subject.name} 和 ${target.name} 已经有浪漫关系，不能重复创建！')
    return
  }

  let score = _calculateFirstRomance(subject, target)
  
  // 亲戚关系会导致亲密度降低
  let kindRelationship = subject.relationships.family[target.id]
  if (kindRelationship) {
    score -= kindRelationship.closeness / 2
    if (score < 0) {
      engine.warn('因为亲戚关系的存在，${subject.name} 和 ${target.name} 的初始浪漫关系亲密度过低，将会被忽略！')
      return
    }
  }

  subject.relationships.romance[target.id] = Relationship(
    characterId: target.id,
    category: 'romance',
  )

  updateBond(subject, target, score: score, relationship: 'romance')

  // engine.info('${subject.name}和${target.name}现在是浪漫关系，亲密度提高 [${score}]')
}

/// 创建 **单方面** 的朋友关系，意味着[subject]认为[target]是自己的朋友
/// 朋友关系是单向的，不影响双方已经存在的其他关系
/// 注意：玩家角色并不能主动发起朋友关系
/// 只能有概率的被动触发 NPC 认可自己为朋友的事件
/// TODO: 当亲密度在0以下，并再次降低时，关系会自动解除
function createFriendship(subject, target, [score = 0]) {
  if (subject.relationships['friendship'].containsKey(target.id)) {
    engine.error('${subject.name} 和 ${target.name} 已经有朋友关系，不能重复创建！')
    return
  }

  assert(score > 0 || score < 0, '朋友关系的初始亲密度必须是非零值！')

  subject.relationships.friendship[target.id] = Relationship(
    characterId: target.id,
    category: 'friendship',
  )
  
  updateBond(subject, target, score: score, relationship: score > 0 ? 'friend' : 'enemy')

  // engine.info('${subject.name} 和 ${target.name} 现在是朋友关系，亲密度提高 [${score}]')
}

function _addSpouseRelationship(subject, target) {
  final addressName = engine.locale('address_${target.isFemale ? 'wife' : 'husband'}')
  subject.relationships.family[target.id] = Relationship(
    characterId: target.id,
    category: 'family',
    kind: 'spouse',
    addressName: addressName,
  )

  for (final relationship of subject.relationships.family) {
    if (relationship.characterId == target.id) {
      continue
    }
    final character = game.characters[relationship.characterId]
    character.relationships.family[target.id] = Relationship(
      characterId: target.id,
      category: 'family',
      kind: 'farkin',
    )
    updateBond(character, target, score: kRelationshipScore.family.farkin, relationship: 'farkin')
    target.relationships.family[character.id] = Relationship(
      characterId: character.id,
      category: 'family',
      kind: 'farkin',
    )
    updateBond(target, character, score: kRelationshipScore.family.farkin, relationship: 'farkin')
  }

  for (final relationship of target.relationships.family) {
    if (relationship.characterId == subject.id) {
      continue
    }
    final character = game.characters[relationship.characterId]
    character.relationships.family[subject.id] = Relationship(
      characterId: subject.id,
      category: 'family',
      kind: 'farkin',
    )
    updateBond(character, subject, score: kRelationshipScore.family.farkin, relationship: 'farkin')
    subject.relationships.family[character.id] = Relationship(
      characterId: character.id,
      category: 'family',
      kind: 'farkin',
    )
    updateBond(subject, character, score: kRelationshipScore.family.farkin, relationship: 'farkin')
  }
  
  let score = kRelationshipScore.family.spouse
  updateBond(subject, target, score: score, relationship: 'spouse')
  
  // engine.info('${target.name} 现在是 ${subject.name} 的 配偶，${subject.name} 对 ${target.name} 的好感度提高 [${score}]')
}

/// 创建双方面的夫妻关系
/// 这里仅涉及夫妻关系，浪漫关系会单独保存
/// 创建夫妻关系时，会连带更新双方已有的家族关系中的其他人的关系图
/// 注意：同性可以恋爱(创建浪漫关系)，但不能结婚
/// householder代表拥有家族之人，marrier代表嫁入家族之人
/// 如果是入赘，则householder一方不是丈夫，而是女方
function createSpouse(householder, marrier, {locationId, incurIncident = true}) {
  assert(householder.isFemale != marrier.isFemale)

  final relationship = householder.relationships.family[marrier.id]
  if (relationship != null && relationship.kind == 'spouse') {
    engine.warn('${householder.name} 和 ${marrier.name} 已经有婚姻关系！本次操作将会被忽略！')
    return
  }

  // 如果此时尚未建立家族，会创建新的家族数据
  let familyMemberData = tryGetFamilyMemberData(householder)
  assert(householder.familyName != null)
  assert(!game.families[householder.familyName].containsKey(marrier.id))
  // 家族辈分会更新为最后一任配偶的辈分数字
  game.families[householder.familyName][marrier.id] = MemberRankData(
    characterId: marrier.id,
    rank: familyMemberData.rank,
    peer: 0,
  )
  _addSpouseRelationship(householder, marrier)
  _addSpouseRelationship(marrier, householder)

  // 一个人当前所属的家族只会有一个，以最后结婚的家主为准
  assert(householder.familyName != null)
  marrier.familyName = householder.familyName

  // 角色的结婚时间只保存在加入家族者的人身上，且以最后一次为准
  marrier.marriageTimestamp = game.timestamp
  
  let homeLocationId = householder.homeLocationId ?? marrier.homeLocationId
  let homeLocation
  if (homeLocationId != null) {
    homeLocation = game.locations[homeLocationId]
  } else {
    homeLocation = random.nextIterable(game.locations.values)
  }
  if (householder.homeLocationId != homeLocation.id) {
    setCharacterHome(householder, homeLocation)
  }
  if (marrier.homeLocationId != homeLocation.id) {
    setCharacterHome(marrier, homeLocation)
  }

  const incidentContent = engine.locale('characterMarriage', interpolations: [
    householder.name,
    marrier.name,
    homeLocation.name,
  ])
  if (incurIncident) {
    Incident(
      message: incidentContent,
      subjectId: householder.id,
      targetId: marrier.id,
      locationId: homeLocation.id,
      orderly: 1,
      idealistic: 1,
    )
  } else {
    engine.info(incidentContent)
  }
}

function divorceSpouse(householder, marrier) {
  throw 'divorceSpouse not implement yet'
}

/// 角色建立师徒关系
/// 注意，拜某个角色为师，和加入某个门派是两个不同的行为。这里并不处理门派的相关数据
/// 后者需要另外调用 addCharacterToOrganization api来创建
function createShitu(shifu, tudi, {incurIncident = true}) {
  
  final relationship = shifu.relationships.sect[tudi.id]
  if (relationship != null && relationship.kind == 'tudi') {
    engine.error('${shifu.name} 和 ${tudi.name} 已经有师徒关系，不能重复创建！')
    return
  }
  
  _addShituRelationship(shifu, tudi)

  // 徒弟所属的宗门是师父的当前宗门
  assert(shifu.sectName != null)
  tudi.sectName = shifu.sectName

  // 角色的拜师时间只保存在徒弟身上，且以最后一次为准
  // tudi.baishiTimestamp = game.timestamp
  
  const incidentContent = engine.locale('characterBaishi', interpolations: [
    shifu.name,
    tudi.name,
  ])
  if (incurIncident) {
    Incident(
      message: incidentContent,
      subjectId: shifu.id,
      targetId: tudi.id,
      orderly: 2,
    )
  } else {
    engine.info(incidentContent)
  }
}

function removeShituRelationship(shifu, tudi) {
  throw 'removeShituRelationship not implement yet'
}

/// 获取家族内部id，如果不存在会创建新的家族数据
/// TODO: 单独保存一个relationship图，值是一个包含角色ID，父母和子女的结构体
function tryGetFamilyMemberData(character) {
  let familyMemberData
  if (character.familyName == null) {
    final familyName = (character.surName ?? character.name) + engine.locale('familyName')
    character.familyName = familyName + '_${crypto.randomUID()}'
    assert(!game.families.containsKey(character.familyName))
    game.families[character.familyName] = {
      id: character.familyName,
      name: familyName,
      members: {},
    }
    game.families[character.familyName].members[character.id] = familyMemberData = MemberRankData(
      characterId: character.id,
      // 辈分决定了地位，数字越大，地位越低
      rank: 0,
      // 同辈中的地位，数字越大，地位越低
      peer: 0,
    )
  } else {
    final family = game.families[character.familyName]
    assert(family != null, 'family not exist: ${character.familyName}')
    familyMemberData = family.members[character.id]
  }
  assert(familyMemberData != null)
  return familyMemberData
}

/// 获取师徒传承的内部id，如果不存在会创建新的师徒传承数据
/// TODO: 单独保存一个relationship图，值是一个包含角色ID，师父和徒弟的结构体
function tryGetSectMemberData(character) {
  let sectMemberData
  if (character.sectName == null) {
    final sectName = (character.surName ?? character.name) + engine.locale('sectName')
    character.sectName = sectName + '_${crypto.randomUID()}'
    assert(!game.sects.containsKey(character.sectName))
    game.sects[character.sectName] = {
      id: character.sectName,
      name: sectName,
      members: {},
    }
    game.sects[character.sectName].members[character.id] = sectMemberData = MemberRankData(
      characterId: character.id,
      // 辈分决定了地位，数字越大，地位越低
      rank: 0,
      // 同辈中的地位，数字越大，地位越低
      peer: 0,
    )
  } else {
    sectMemberData = game.sects[character.sectName]
  }
  assert(sectMemberData != null)
  return sectMemberData
}

function _addChildRelationship(parent, child) {
  for (final relationship of parent.relationships.family) {
    if (relationship.characterId == child.id) {
      continue
    }
    final character = game.characters[relationship.characterId]
    assert(character != null)
    if (relationship.kind == 'spouse') {
      character.relationships.family[child.id] = Relationship(
        characterId: child.id,
        category: 'family',
        kind: 'child',
      )
      updateBond(character, child, score: kRelationshipScore.family.child, relationship: 'child')
      child.relationships.family[character.id] = Relationship(
        characterId: character.id,
        category: 'family',
        kind: 'parent',
      )
      updateBond(child, character, score: kRelationshipScore.family.parent, relationship: 'parent')
    } else if (relationship.kind == 'parent') {
      character.relationships.family[child.id] = Relationship(
        characterId: child.id,
        category: 'family',
        kind: kind1,
      )
      updateBond(character, child, score: kRelationshipScore.family.grandChild, relationship: 'grandChild')
      child.relationships.family[character.id] = Relationship(
        characterId: character.id,
        category: 'family',
        kind: 'grandParent',
      )
      updateBond(child, character, score: kRelationshipScore.family.grandParent, relationship: 'grandParent')
    } else {
      character.relationships.family[child.id] = Relationship(
        characterId: child.id,
        category: 'family',
        kind: 'farfamily',
      )
      updateBond(character, child, score: kRelationshipScore.family.farfamily, relationship: 'farfamily')
      child.relationships.family[character.id] = Relationship(
        characterId: character.id,
        category: 'family',
        kind: 'farfamily',
      )
      updateBond(child, character, score: kRelationshipScore.family.farfamily, relationship: 'farfamily')
    }
  }

  parent.relationships.family[child.id] = Relationship(
    characterId: child.id,
    category: 'family',
    kind: 'child',
  )

  updateBond(parent, child, score: kRelationshipScore.family.child, relationship: 'child')
}

function _addShituRelationship(shifu, tudi) {
  // 一个人在其所有的师父的师徒关系中都有自己的辈分
  // 如果此时尚未建立师徒传承数据，会创建新的数据
  let sectMemberData = tryGetSectMemberData(shifu)
  assert(!game.sects[shifu.sectName].containsKey(tudi.id))
  let peerNumber = game.sects[shifu.sectName].values.where((member) =>
    member.rank == sectMemberData.rank + 1).length
  // 辈分是师父的辈分数字 + 1
  game.sects[shifu.sectName][tudi.id] = MemberRankData(
    characterId: tudi.id,
    rank: sectMemberData.rank + 1,
    peer: peerNumber,
  )

  shifu.relationships.sect[tudi.id] = Relationship(
    characterId: tudi.id,
    category: 'sect',
    kind: 'tudi',
  )

  tudi.relationships.sect[shifu.id] = Relationship(
    characterId: shifu.id,
    category: 'sect',
    kind: 'shifu',
  )

  for (final relationship of shifu.relationships.sect) {
    final character = game.characters[relationship.characterId]
    let kind1 = relationship.kind == 'shifu' ? 'grandTudi' : 'tongmen'
    character.relationships.sect[tudi.id] = Relationship(
      characterId: tudi.id,
      category: 'sect',
      kind: kind1,
    )
    updateBond(character, tudi, score: kRelationshipScore.sect[kind1], relationship: kind1)
    let kind2 = relationship.kind == 'shifu' ? 'grandTudi' : 'tongmen'
    tudi.relationships.sect[character.id] = Relationship(
      characterId: character.id,
      category: 'sect',
      kind: kind2,
    )
    updateBond(tudi, character, score: kRelationshipScore.sect[kind2], relationship: kind2)
  }

  updateBond(shifu, tudi, score: kRelationshipScore.sect.tudi, relationship: 'tudi')
  updateBond(tudi, shifu, score: kRelationshipScore.sect.shifu, relationship: 'shifu')
}

/// 创建一个婴儿
/// 注意创建一个婴儿和创建浪漫、夫妻、师徒关系等不同，是通过一个构造函数来实现
/// 因为婴儿此时尚未有实体，而其他的关系则是建立一些已经存在的实体的关系
struct Baby {
  constructor ({
    id,
    father,
    mother,
    isFemale,
    generationName,
    shortName,
    incurIncident = true,
  }) {
    assert(father != null)
    assert(mother != null)
    this.entityType = kEntityTypeBaby

    mother.isPregnant = true

    this.fatherId = father.id
    this.motherId = mother.id
    this.conceptionTimestamp = game.timestamp
    this.pregnancyTime = Math.gaussianNoise(
      _kPregnancyTime,
      _kPregnancyTimeVariable, 
      randomGenerator: random,
    )
    this.isFemale = isFemale ?? random.nextBool()
    this.surName = father.surName
    this.generationName = generationName
    
    if (shortName) {
      this.shortName = (generationName ?? '') + shortName
    } else {
      let randomName
      let conflict = false
      do {
        randomName = generateCharacterName(
          isFemale: this.isFemale,
          surName: this.surName,
          middleName: generationName,
        )
        conflict = game.characters[randomName.fullName] != null
      } while (conflict)
      this.name = randomName.fullName
      this.surName = randomName.surName
      this.generationName = randomName.middleName
      this.shortName = randomName.shortName
    }
    this.id = id ?? this.name
    if (game.babies.containsKey(this.id)) {
      engine.warn('已经存在 id 为 ${this.id} 的婴儿。旧数据将会被覆盖。')
    }
    game.babies[this.id] = this
    const incidentContent = engine.locale('characterConception', interpolations: [
      mother.name,
      father.name,
      this.name,
    ])
    if (incurIncident) {
      Incident(
        message: incidentContent,
        subjectId: father.id,
        targetId: mother.id,
        idealistic: -2,
      )
    } else {
      engine.info(incidentContent)
    }
  }
}

/// 返回朋友的数量
function hasFriend(character) {
  return character.relationships.friendship.length
}

/// 检查 character 是否是 target 的朋友
function isFriend(character, target) {
  return character.relationships.friendship.containsKey(target.id)
}

/// 返回所有朋友
function getFriends(character) {
  return character.relationships.friendship.values
}

/// 返回恋爱对象的数量
function hasRomance(character) {
  return character.relationships.romance.length
}

/// 检查 character 是否是 target 的恋爱对象
function isRomance(character, target) {
  return character.relationships.romance.containsKey(target.id)
}

/// 返回所有恋爱对象
function getRomances(character) {
  return character.relationships.romance.values
}

/// 返回配偶的数量
function hasSpouse(character) {
  return character.relationships.family.values.where((d) => d.kind == 'spouse').length
}

/// 检查 character 是否是 spouse 的配偶
function isSpouse(character, spouse) {
  return character.relationships.family[spouse.id]?.kind == 'spouse'
}

/// 返回所有配偶
function getSpouses(character) {
  return character.relationships.family.values.where((d) => d.kind == 'spouse')
}

/// 返回孩子的数量
function hasChild(character) {
  return character.relationships.family.values.where((d) => d.kind == 'child').length
}

/// 检查 character 是否是 child 的父母, 注意这里包括继子和养子
function isChild(character, child) {
  return character.relationships.family[child.id]?.kind in kChildRelationships
}

/// 返回所有孩子
function getChildren(character) {
  return character.relationships.family.values.where((d) => d.kind == 'child')
}

/// 是否是同一个家族
function isFamily(character, target) {
  return character.relationships.family.containsKey(target.id)
}

/// 返回徒弟的数量
function hasTudi(character) {
  return character.relationships.sect.values.where((d) => d.kind == 'tudi').length
}

/// 检查 character 是否是 tudi 的 shifu
function isTudi(character, tudi) {
  return character.relationships.sect[tudi.id]?.kind == 'tudi'
}

/// 返回所有徒弟
function getTudis(character) {
  return character.relationships.sect.values.where((d) => d.kind == 'tudi')
}

/// 是否是同一个师承
function isSect(character, target) {
  return character.relationships.sect.containsKey(target.id)
}

function isOrganizationHead(character) {
  if (character.organizationId != null) {
    final organization = game.organizations[character.organizationId]
    assert(organization != null, 'organization not found: ${character.organizationId}')
    if (organization.headId == character.id) {
      return true
    }
  }
  return false
}

const basicLibrary = [
  'attack_normal',
]

struct Character {
  constructor ({
    id,
    isFemale,
    icon,
    illustration,
    skin,
    shipModel,
    name,
    surName, // 姓氏
    shortName,
    generationName,
    generateName = true,
    description,
    level,
    rank,
    attributes,
    stats,
    generateDeck = true,
    cultivationFavor,
    cultivationStyle,
    birthTimestamp,
    exp,
    skillPoints,
    worldId,
    worldPositionX,
    worldPositionY,
    locationId,
    isNewBorn = false,
    fatherId,
    motherId,
    relationships,
    bonds,
  }) {
    // 生成战斗单位相关数据，并写入当前对象
    // 不使用继承主要是因为这些数据经常会改动，直接写在这个对象上的话会更清晰
    const battleInfo = BattleEntity(
      id: id,
      isFemale: isFemale,
      icon: icon,
      illustration: illustration,
      skin: skin,
      name: name,
      shortName: shortName,
      surName: surName,
      generationName: generationName,
      generateName: generateName,
      description: description,
      level: level,
      rank: rank,
      attributes: attributes,
      stats: stats,
      generateDeck: generateDeck,
      cultivationFavor: cultivationFavor,
      cultivationStyle: cultivationStyle,
    )
    Object.assign(this, battleInfo)
    
    this.entityType = kEntityTypeCharacter

    if (game.characters.containsKey(this.id)) {
      engine.warn('已经存在 id 为 ${this.id} 的角色。旧数据将会被覆盖。')
    }
    game.characters[this.id] = this

    // this.entityType = 'character'
    // this.category = category ?? 'character'

    this.shipModel = shipModel ?? 'ship1'

    // 转换后的修为经验值，经验值达到下一等级需求后，自动扣除并提升修为能级
    this.exp = exp ?? 0
    this.expForLevel = expForLevel(this.level)
    // 未分配的修为点数，修为点数可以用来在天赋盘上升级天赋
    this.skillPoints = skillPoints ?? 0

    this.worldId = worldId ?? world?.id

    // let atWorld = universe[this.worldId]
    
    this.charismaFavor =  Math.gaussianNoise(
      kNonBattleAttributeValueAverage,
      kNonBattleAttributeValueDeviation,
      min: 1,
      max: kAttributeValueMax,
      randomGenerator: random,
    ).toInt()

    // 该人物的事件触发选项
    this.flags = {
      monthly: {},
    }

    // 该角色曾经拥有过的称号，只保存 id
    // this.titleIds = []
    // if (titleId != null) {
    //   this.titleIds.add(titleId)
    // }
    // this.titleId = titleId

    // this.fame = 0
    // // // 恶名，对此人差评的人的数量
    // this.infamy = 0

    // 该角色的人格纬度
    // 角色的人格是天生的，之后不会再发生改变
    // 人格决定了角色对人或者事物的看法
    // 人格一共包含18个层面，其中最重要的是三观，决定了最基础的羁绊评价系统
    // 其次是关于他人的5个，关于事物的5个，以及关于自己的5个层面
    // 人格数值最小 -50 最大 +50
    this.personality = {}
    for (final id in Constants.personalities) {
      this.personality[id] = (random.nextDouble() * 100.0 - 50.0).toInt()
    }

    // 动机列表
    // 动机决定了角色如何安排行动，以及角色对事物的看法
    // 和人格不同，动机是后天获得的
    // 主要动机会永久存在，次要动机可能持续多年存在
    // 动机没有程度的区分，只有有或者没有
    // 角色先天默认会有一个主要动机，就是动机列表的第一项
    // 先天动机只会是六种主要动机之一
    // 角色可能随着时间推移获得新的次要动机，但不会再获得其他主要动机
    this.motivations = []
    this.motivations.add(random.nextIterable(kMajorMotivations))

    // 情绪列表
    // 情绪决定了角色对别人行动的反应
    // 和人格不同，情绪是后天获得的
    // 相比思想和动机，情绪十分短暂，可能只是持续几个月或几天
    this.emotions = {}

    // 该角色当前的事项
    // 门派任务和悬赏任务同样以事项形式保存在这里
    this.journals = {}
    // 当前追踪的事项id列表
    // 追踪的事项会以漂浮文字显示在屏幕右上角
    this.activeJournalIds = []
    
    // 这些列表保存的是incident的index
    // 该角色经历过的事情
    this.experienced = []
    // 该对象听说的事情
    this.known = []

    // 该角色和角色的交互历史
    // key是角色id，value是一个bond data
    // bond数据结构
    this.bonds = bonds ?? {}

    // 角色的爱情、仇敌、朋友关系，直接保存的对方的角色id
    this.romanceIds = []
    this.enemyIds = []
    this.friendIds = []

    // 角色所属的家族和宗门，保存的是家族数据和宗门数据的id
    // 具体的宗门和家族保存在 game.sects 和 game.families 中
    this.familyIds = []
    this.sectIds = []
    
    // 关系数据，每种具体类型下以对方角色的id为key，value是一个relationship data
    // this.relationships = relationships ?? {
    //   family: [],
    //   sect: [],
    //   romance: [],
    //   friendship: [],
    // }
    
    assert(this.relationships.family != null)
    assert(this.relationships.sect != null)
    assert(this.relationships.romance != null)
    assert(this.relationships.friendship != null)

    this.organizationFavor = this.motivations.first
    
    /// 每个角色的家是一个单例对象。
    /// 尽管角色可以在多个地点拥有家，但指向的都是同一个场景
    /// 此处创建的家宅场景此时尚未绑定到任何据点
    final home = Location(
      id: '${kLocationKindHome}_${this.id}',
      category: 'site',
      kind: kLocationKindHome,
      name: engine.locale('characterHomeSite', interpolations: [this.name]),
      managerId: this.id,
      isAffiliate: true,
    )
    this.homeSiteId = home.id
    // 所有该角色拥有住所的据点的 id 列表
    this.homeLocations = []
    
    if (locationId) {
      const location = game.locations[locationId]

      this.worldPosition = {
        left: location.worldPosition?.left,
        top: location.worldPosition?.top,
      }

      if (isNewBorn) {
        assert(birthTimestamp != null, '新生儿必须指定出生时间')
        this.birthTimestamp = birthTimestamp
        final father = game.characters[fatherId]
        assert(father != null)
        // 如果此时尚未建立家族，会创建新的家族数据
        let familyMemberData = tryGetFamilyMemberData(father)
        assert(father.familyName != null)
        assert(!game.families[father.familyName].containsKey(this.id))
        let peerNumber = game.families[father.familyName].values.where((member) =>
          member.rank == familyMemberData.rank + 1).length
        // 辈分是父母的辈分数字 + 1
        game.families[father.familyName][this.id] = MemberRankData(
          characterId: this.id,
          rank: familyMemberData.rank + 1,
          peer: peerNumber,
        )
        _addChildRelationship(father, this)
        // _addChildRelationship(mother, this)

        // 孩子所属的家族是父亲的当前家族
        assert(father.familyName != null)
        this.familyName = father.familyName

        final mother = game.characters[motherId]
        assert(mother != null)
        this.birthLocationId = locationId
        // 出生事件会修改自身，需要放在最后处理
        const incidentContent = engine.locale('characterBorn',
          interpolations: [
            mother.name,
            location.name,
            this.name,
          ])
        Incident(
          message: incidentContent,
          subjectId: mother.id,
          targetId: this.id,
          locationId: locationId,
          orderly: 1,
          idealistic: -1,
        )
        characterMet(mother, this)
        this.locationId = this.homeSiteId = mother.homeSiteId
        this.homeLocationId = mother.homeLocationId
        final homeLocation = game.locations[this.homeLocationId]
        this.worldPosition = {
          left: homeLocation.worldPosition.left,
          top: homeLocation.worldPosition.top,
        }
      } else {
        // 设置居住地会触发事件从而修改自身，需要放在最后处理
        setCharacterHome(this, location)
      }
    } else {
      if (worldPositionX != null && worldPositionY != null) {
        this.worldPosition = {
          left: worldPositionX,
          top: worldPositionY,
        }
      }
    }
    
    // age 的格式是 timestamp, 精确到 tick. 
    if (this.birthTimestamp == null) {
      this.birthTimestamp = createBirthTimestamp()
    }

    /// 寿命必须在已知境界之后计算
    this.deathTimestamp = this.birthTimestamp + createLifespan(this.rank)
    
    // 随角色移动的孩童（Baby 对象），这里只保存id
    this.carrying = []

    this.updateDay = random.nextInt(30) + 1
  }
}

function getCharacterAge(character) {
  return (game.timestamp - character.birthTimestamp) ~/ Constants.ticksPerYear
}

function getCharacterAgeString(character) {
  return formatAgeString(game.timestamp - character.birthTimestamp)
}

function getCharacterRestLifespanString(character) {
  return formatAgeString(character.deathTimestamp - game.timestamp)
}

function getCharacterBirthDayString(character) {
  return formatDateTimeString(character.birthTimestamp, format: 'date.md')
}

function getCharacterBirthDateString(character) {
  return formatDateTimeString(character.birthTimestamp, format: 'date.ymd')
}

function haveMet(subject, target) {
  if (subject == target) return true
  if (target.entityType != 'character') return true

  assert(subject.entityType == 'character')

  const bond = subject.bonds[target.id]
  if (bond && bond.haveMet) {
    return true
  } else {
    // 这里必须传 null
    return null
  }
}

/// 计算第一印象分
function _characterMet(subject, target, { incurIncident }) {
  assert(subject != null && target != null)
  assert(subject.entityType == 'character')
  assert(target.entityType == 'character')
  let bond = subject.bonds[target.id] 
  if (bond != null) {
    if (bond.haveMet) {
      return bond
    } else {
      bond.haveMet = true
    }
  } else {
    bond = Bond(character: subject, target: target, haveMet: true)
  }

  final score = _calculateFirstImpression(subject, target)
  updateBond(subject, target, score: score)
  
  let incidentContent
  if (bond.score < -kCharacterImpressionCheck) {
    incidentContent = engine.locale('characterFirstMeetHate', interpolations: [
      subject.name,
      target.name,
    ])
  } else if (bond.score >= kCharacterImpressionCheck) {
    incidentContent = engine.locale('characterFirstMeetLike', interpolations: [
      subject.name,
      target.name,
    ])
  } else {
    incidentContent = engine.locale('characterFirstMeetNormal', interpolations: [
      subject.name,
      target.name,
    ])
  }
  if (incurIncident) {
    Incident(
      message: incidentContent,
      subjectId: subject.id, // 见面是一个单向事件
    )
  } else {
    engine.info(incidentContent)
  }
  return bond
}

function characterMet(subject, target, { incurIncident }) {
  if (subject == target) return null
  let bond = _characterMet(subject, target, incurIncident: incurIncident)
  _characterMet(target, subject, incurIncident: incurIncident)
  return bond
}

function getCharacterHomeSite(character, {worldId}) {
  if (character.homeSiteId == null) {
    engine.warn('角色 ${character.name} 目前没有住宅！')
    return
  }
  
  // let atWorld = worldId != null ? universe[worldId] : world
  assert(game.locations.containsKey(character.homeSiteId))
  return game.locations[character.homeSiteId]
}

function clearCharacterHomeLocations(character, {worldId}) {
  // let atWorld = worldId != null ? universe[worldId] : world
  for (final locId in character.homeLocations) {
    final location = game.locations[locId]
    removeCharacterHomeLocation(character, location)
  }
  character.homeLocations.clear()
}

function removeCharacterHomeLocation(character, location) {
  final result = location.residents.remove(character.id)
  if (result) {
    engine.warn('已移除角色 ${character.name} 在 ${location.name} 的住宅')
  }
}

function getCharacterHomeLocation(character) {
  return game.locations[character.homeLocationId]
}

function setCharacterHome(character, location, { moveToHome = true, incurIncident = true }) {
  if (character.homeLocationId == location.id) {
    engine.warn('角色 ${character.name} 已经定居在 ${location.name} 了！')
    return
  }
  let homeSiteId = '${kLocationKindHome}_${character.id}'
  let home = game.locations[homeSiteId]
  assert(home != null, 'home site is null, homeSiteId: ${homeSiteId}')
  final oldLocation = game.locations[home.atLocationId]
  if (oldLocation != null) {
    oldLocation.residents.remove(character.id)
  }
  if (!character.homeLocations.contains(location.id)) {
    assert(!location.residents.contains(character.id))
    location.residents.add(character.id)
    character.homeLocations.add(location.id)
  }
  character.homeLocationId = location.id
  if (moveToHome) {
    character.locationId = homeSiteId
    character.worldPosition = {
      left: location.worldPosition.left,
      top: location.worldPosition.top,
    }
  }
  character.worldPosition = {
    left: location.worldPosition.left,
    top: location.worldPosition.top,
  }
  let incidentContent
  incidentContent = engine.locale('characterSettle', interpolations: [
    character.name,
    location.name,
  ])
  if (incurIncident) {
    Incident(
      message: incidentContent,
      subjectId: character.id,
    )
  } else {
    engine.info(incidentContent)
  }
  
  return home
}

function getCharacterWorldPosition(character) {
  return character.worldPosition
}

// 赋值时位置可以是Null，但worldId为Null则会被忽略
function setCharacterWorldPosition(character, left, top, {worldId}) {
  if (left == null || top == null) {
    character.worldPosition = null
  } else {
    character.worldPosition = { left, top }
  }
  if (worldId != null) {
    character.worldId = worldId
  }
}

// function addCharacter(character) {
//   // assert(character != null)
//   // engine.debug('向当前世界添加新角色：${character.id}')
//   game.characters[character.id] = character
// }

// function addCharacters(chars: List) {
//   for (const char in chars) {
//     addCharacter(char)
//   }
// }

/// 如果不传 ids，就返回所有的角色
function getCharacters([ids]) {
  if (ids?.isNotEmpty) {
    return game.characters.values.where( (char) => char.id in ids)
  } else {
    return game.characters.values
  }
}

function getCharactersOnWorldMap([ worldId ]) {
  worldId ??= world.id
  return game.characters.values.where((char) {
    if (char.worldId != worldId) return false
    if (char.worldPosition == null) return false
    if (char.locationId != null) return false
    return true
  })
}

function getCharactersAtWorldMapPosition(left, top, [ worldId ]) {
  worldId ??= world?.id
  return game.characters.values.where((char) {
    if (char.worldId != worldId) return false
    if (char.worldPosition == null) return false
    if (char.worldPosition.left != left || char.worldPosition.top != top) return false
    if (char.locationId != null) return false
    return true
  })
}

function getCharactersAtLocation(location) {
  return game.characters.values.where((char) {
    if (char.locationId != location.id) return false
    return true
  })
}

function getResidingCharacters(location) {
  // let atWorld = universe[location.worldId]
  location.residents.map((id) {
    final homeSiteId = '${kLocationKindHome}_${id}'
    final homeSite = game.locations[homeSiteId]
    assert(homeSite != null, 'home is null, id: ${homeSiteId}')
    final character = game.characters[homeSite.managerId]
    assert(character != null, 'home owner is null, home id: ${homeSiteId}, owner id: ${homeSite.managerId}')
    return character
  }).toList()
}

// function getResidingCharactersIds(location) {
//   return location.residents
  // let atWorld = universe[location.worldId]
  // location.residents.map((id) {
  //   assert(game.locations.containsKey(id))
  //   final homeSite = game.locations[id]
  //   return homeSite.managerId
  // }).toList()
// }

// function getNpcs() {
//   return game.characters.values.where( (char) => (char.id != game.heroId))
// }

function getNpcsOnWorldMap([ worldId ]) {
  worldId ??= world?.id
  return game.characters.values.where((char) {
    if (char.id == game.heroId) return false
    if (char.worldId != worldId) return false
    if (char.worldPosition == null) return false
    if (char.locationId != null) return false
    return true
  })
}

function getNpcsAtWorldMapPosition(left, top, [ worldId ]) {
  worldId ??= world?.id
  return game.characters.values.where((char) {
    if (char.id == game.heroId) return false
    if (char.worldId != worldId) return false
    if (char.worldPosition == null) return false
    if (char.worldPosition.left != left || char.worldPosition.top != top) return false
    if (char.locationId != null) return false
    return true
  })
}

function removeCharacterById(id: string) {
  engine.warn('正在移除ID为 [${id}] 的角色。')
  // TODO: 角色相关的信息，例如门派首领，拥有的建筑等等需要一并清除才行
  delete game.characters[id]
}

/// 更新羁绊数据，如果之前不存在羁绊会创建新的羁绊数据
function updateBond(subject, target, {
  score,
  // relationship,
}) {
  assert(score != null, 'score cannot be null when updating bond!')
  let bond = subject.bonds[target.id]
  if (bond == null) {
    bond = Bond(character: subject, target: target)
  }
  score = score.toDouble().toFixed(2)
  bond.score += score
  // TODO: 朋友和仇敌的类型是根据当前好感度动态变化的
  // if (bond.score < 0) {
  //   if (!bond.relationships.contains('enemy')) {
  //     bond.relationships.add('enemy')
  //   }
  // }
  // else if (bond.score > 0 && bond.haveMet) {
  //   if (!bond.relationships.contains('friend')) {
  //     bond.relationships.add('friend')
  //   }
  // }
  // if (relationship != null) {
  //   if (!bond.relationships.contains(relationship)) {
  //     bond.relationships.add(relationship)
  //   }
  // }
  engine.warn('更新 ${subject.name} 对 ${target.name} 的羁绊，好感变动：${score}, 关系变动: ${relationship ?? '无'}')
}

function getBondScore(subject, target) {
  let bond = subject.bonds[target.id]
  if (bond != null) {
    return bond.score
  } else {
    return 0
  }
}

/// 提升NPC的修为等级，NPC不会有天赋盘，所以这里不处理经验值和天赋点数等问题
function characterCultivationLevelUp(character, {level = 1, incurIncident = true }) {
  assert(level > 0)
  final levelMax = maxLevelForRank(character.rank)
  if (character.level >= levelMax) {
    engine.warn('角色 ${character.name} 已经达到当前境界允许的最高等级，无法再提升。')
    return
  }

  let originalLevel = character.level

  character.level += level

  if (character.level > levelMax) {
    character.level = levelMax
  }

  if (character.level <= originalLevel) {
    engine.warn('角色 ${character.name} 已经达到当前境界允许的最高等级，无法再提升。')
    return
  }

  const incidentContent = engine.locale('characterCultivationLevelUp', interpolations: [
    character.name,
    character.level,
  ])
  if (incurIncident) {
    Incident(
      message: incidentContent,
      subjectId: character.id,
    )
  }
  engine.info(incidentContent)
  return character.level
}

/// 提升NPC的境界
/// 和玩家只能一级一级提升不同，NPC可以直接提升多个境界
function characterRankUp(character, {rank, incurIncident = true }) {
  if (character.rank >= kCultivationRankMax) {
    engine.warn('角色已经达到最高境界，无法再提升。')
    return character.rank
  }

  if (rank != null) {
    assert(rank > character.rank)
    character.rank += rank
  } else {
    ++character.rank
  }

  if (character.rank > kCultivationRankMax) {
    character.rank = kCultivationRankMax
  }

  const incidentContent = engine.locale('characterCultivationRankUp', interpolations: [
    character.name,
    getCultivationRankName(character),
  ])
  if (incurIncident) {
    Incident(
      message: incidentContent,
      subjectId: character.id,
    )
  }
  engine.info(incidentContent)

  return character.rank
}

function characterGainExp(character, value) {
  character.exp += value

  const incidentContent = engine.locale('characterExpGained', interpolations: [
    character.name, 
    value,
  ])
  Incident(
    message: incidentContent,
    subjectId: hero.id,
  )
}

function characterMakeContribution(character, data, { incurIncident = true }) {
  let contribution = data.stackSize ?? 0
  if (contribution <= 0) {
    engine.warn('contribution amount is less than or equal to 0, cannot collect!')
    return false
  }

  let contributionTarget
  if (data.organizationId) {
    // 如果是门派领地的任务
    const organization = game.organizations[data.organizationId]
    assert(organization != null,
      'organization not found in contribution pack: ${data.organizationId}')
    const memberData = organization.membersData[character.id]
    assert(memberData != null,
      'member data not found for character id: ${character.id} in organization: ${organization.id}')
    if (character.organizationId == data.organizationId) {
      // 如果主角是该门派成员
      assert(memberData != null,
          'Member data not found in organization [${organization.id}], member id: ${character.id}');
      memberData.contribution += contribution;
      // 记录门派成员当月贡献
      organization.flags.monthly.contributions[character.id] += contribution;
    } else {
      contribution = contribution ~/ 2
      // 非门派成员功勋减半
      if (memberData == null) {
        organization.membersData[character.id] = MemberData(
          id: character.id,
          rank: -1,
          contribution: contribution,
        )
      } else {
        memberData.contribution += contribution;
      }
    }
    contributionTarget = organization.name;
  } else {
    // 非门派领地任务，同样可以获得功勋，但直接保存在据点数据中
    const location = game.locations[data.locationId]
    assert(location != null,
      'location not found in contribution pack: ${data.locationId}')
    contributionTarget = location.name;
    location.contributions[character.id] += contribution;
  }
  
  let incidentContent = engine.locale('characterMakeContribution',
    interpolations: [
      character.name,
      contributionTarget,
      contribution,
    ])
  if (incurIncident) {
    Incident(
      message: incidentContent,
      subjectId: character.id,
      organizationId: data.organizationId,
      locationId: data.locationId,
      orderly: contribution,
    )
  } else {
    engine.info(incidentContent)
  }
  
  return;
}
