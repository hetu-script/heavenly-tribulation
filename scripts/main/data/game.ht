
let game
let universe
let world
let history
let hero

/// 仅在特定场景中会被赋值
let location
let terrain
let merchant
let enemy
let self
let opponent
let battleFlags

/// 玩家每个月的互动操作记录，月初会重置
struct HeroMonthly {
  constructor {
    this.updated = false
    // 本月鉴定敌人卡牌数量
    this.identifiedEnemyCards = 0
    // 本月是否已经参加过门派会议
    this.attendedMeeting = false

    // 这里保存了玩家在某地交易过的资源种类和数量
    // 对资源进行买卖会影响价格
    // 买入为正数，卖出为负数
    this.tradedMaterials = {}

    // 玩家捐献过的门派和城市，只保存id
    this.donated = []

    // 对其他角色操作
    this.asked = []
    this.gifted = []
    this.attacked = []
    this.stolen = []

    // 婚姻关系
    this.proposed = []

    // 拜师和收徒的尝试
    this.baishi = []
    this.shoutu = []

    // 师徒关系的传授功法
    this.consulted = []
    this.tutored = []

    // 组织的加入和招募
    this.enrolled = []
    this.recruited = []

    // 对某个建筑操作
    // 租用过的场地，在月底之前可以进行生产或使用
    this.rented = []
  }
}

struct CharacterMonthly {
  constructor {

  }
}

struct LocationMonthly {
  constructor {

  }
}

struct SectMonthly {
  constructor {
    // 本月新加入的成员
    this.recruited = []
    // 本月获得职位的成员
    this.promoted = []
    // 本月境界突破的成员
    this.breakthrough = []
    // key: characterId, value: contribution amount
    this.contributions = {}
  }
}

function addHeroMonthly(activity, targetId) {
  game.flags.monthly ??= HeroMonthly()
  game.flags.monthly[activity] ??= []
  game.flags.monthly[activity].add(targetId)
}

function addCharacterMonthly(character, activity, targetId) {
  character.flags.monthly ??= CharacterMonthly()
  character.flags.monthly[activity] ??= []
  character.flags.monthly[activity].add(targetId)
}

function addLocationMonthly(location, activity, targetId) {
  location.flags.monthly ??= LocationMonthly()
  location.flags.monthly[activity] ??= []
  location.flags.monthly[activity].add(targetId)
}

function addSectMonthly(sect, activity, targetId) {
  sect.flags.monthly ??= SectMonthly()
  sect.flags.monthly[activity] ??= []
  sect.flags.monthly[activity].add(targetId)
}

function resetHeroMonthly() {
  game.flags.monthly = HeroMonthly()
}

function resetCharacterMonthly(character) {
  character.flags.monthly = CharacterMonthly()
}

function resetLocationMonthly(location) {
  location.flags.monthly = LocationMonthly()
}

function resetSectMonthly(sect) {
  sect.flags.monthly = SectMonthly()
}

struct GameData {
  constructor ({
    saveName,
    mainWorldId,
    enableTutorial = true,
  }) {
    assert(saveName != null && saveName.isNotEmpty, '创建游戏时 saveName 不能为空!')
    this.saveName = saveName
    this.mainWorldId = mainWorldId
    this.enableTutorial = enableTutorial

    this.isNewGame = true
    this.currentWorldId = null
    this.heroId = null
    this.timestamp = 0

    // 游戏内的事件标记，
    this.flags = {
      tutorial: {}, // 新手教程
      // 试炼地牢的事件标记，每次进入地牢前会重置
      trial: {},
      // 秘境地牢的事件标记，每次进入地牢前会重置
      dungeon: {},
      // 门派行动的事件标记，加入新门派会重置
      sects: {},
      // 玩家每个月是否进行了某个动作
      monthly: HeroMonthly(),
    }

    this.npcs = {}
    this.deceased = {}
    this.babies = {}
    this.characters = {}

    // 地图上的城市、场景
    this.locations = {}

    // 家族信息，家族类似于门派
    // 也有自己的家族名字，成员数据表等等
    // 但没有自己的城市，要想拥有城市必须是一个门派
    this.families = {}
    
    this.sects = {}

    // 门派之间的外交关系
    // key 是外交关系的 id，值是 Diplomacy 数据
    // 在门派自己的数据中保存的则是对方门派和外交关系 id 的对应关系表
    // 可能存在多个门派组成的联盟之类，这样大家共享一个联盟 ID
    // 敌对势力同样会创建一个外交关系数据
    this.diplomacies = {}
    
    // 本次游戏加载的 module，这里是元数据和事件函数绑定的空间
    this.mods = {
      // meta: {} // 模组元数据
      // events: {} // 模组事件处理函数
    }
  }
}

/// 创建新游戏，重置所有状态，返回game
/// 注意调用此函数并不会创建世界数据
function createGame(saveName, {
  seed: integer,
  mainWorldId: string,
  enableTutorial = true
}) {
  engine.info('创建新游戏')
  game = GameData(
    saveName: saveName,
    mainWorldId: mainWorldId,
    enableTutorial: enableTutorial
  )
  setRandomSeed(seed ?? crypto.crcInt('heavenly_tribulation_2025'))
  universe = {}
  history = {}
  world = null
  hero = null
}

const kTimeOfDay = {
  '1': 'morning',
  '2': 'afternoon',
  '3': 'evening',
  '4': 'midnight',
}

/// 载入游戏数据，返回game
function loadGameFromJsonData({
  gameData,
  universeData,
  historyData,
  // isEditorMode,
}) -> List {
  game = Object.fromJSON(gameData)
  // game.isNewGame ??= true

  setRandomSeed(game.seed)

  universe = Object.create(universeData)
  history = Object.create(historyData)
  world = universe[game.currentWorldId]

  assert(world != null, 'world id null, currentWorldId: ${game.currentWorldId}')
  
  engine.info('当前世界: [${world.id}]')

  if (game.heroId != null) {
    assert(game.characters.containsKey(game.heroId))
    hero = game.characters[game.heroId]
    engine.info('设置当前玩家人物为 [${hero.name}]。')
  } else {
    hero = null
  }
}

function addWorld(newWorld) {
  world = universe[newWorld.id] = newWorld
  game.currentWorldId = newWorld.id
}

function getMapComponents() {
  return world.components
}

/// 为地图创建显示组件，注意这里仅限非角色类装饰性数据
function createMapComponent(componentData, left, top) {
  assert(componentData.entityType == null)
  final component = Object.fromJSON(componentData)
  engine.info('添加显示组件：[${component.id}]')
  component.worldPosition = { left, top }
  world.components.add(component)
  return component
}

function removeMapComponentByPosition(left, top) {
  engine.info('移除显示组件，位于: [${left},${top}]')
  world.components.removeWhere((c) => c.worldPosition.left == left && c.worldPosition.top == top)
}

function removeMapComponentById(id) {
  engine.info('移除显示组件，id: [${id}]')
  world.components.removeWhere((c) => c.id == id)
}

function setHero(id: string) {
  assert(game.characters.containsKey(id))

  game.heroId = id
  hero = game.characters[id]
  game.flags.monthly = HeroMonthly()
  engine.info('设置当前玩家人物为 [${hero.name}]。')

  if (game.enableTutorial) {
    /// 用于新手教程的系统角色
    if (game.npcs['xitong'] == null) {
      game.npcs['xitong'] = Npc(
        id: 'xitong',
        name: engine.locale('npc_xitong_name'),
        icon: 'story/illustration/sitone_head.png',
        illustration: 'story/illustration/sitone.png',
        useCustomLogic: true,
      )
    }
    final home = game.locations[hero.homeSiteId]
    home.npcId = 'xitong'
  }

  for (final card in hero.cardLibrary.values) {
    card.isIdentified = true
  }

  Game.updateUI()
}

function randomizeHeroWorldPosition() {
  hero.locationId = null
  final location = game.locations[hero.homeLocationId]
  final availableTiles = location.territoryIndexes.where((index) {
    final tile = world.terrains[index]
    return !tile.isWater
  })
  if (availableTiles.isEmpty) {
    hero.worldPosition = {
      left: location.worldPosition.left,
      top: location.worldPosition.top,
    }
  } else {
    final randomTileIndex = random.nextIterable(availableTiles)
    final randomTile = world.terrains[randomTileIndex]
    hero.worldPosition = {
      left: randomTile.left,
      top: randomTile.top,
    }
  }
}

function setHeroWorldId(worldId) {
  hero.worldId = worldId
}

function getHeroHomeLocation({worldId}) {
  // let atWorld = worldId != null ? universe[worldId] : world
  if (hero.homeLocationId) {
    assert(game.locations.containsKey(hero.homeLocationId))
    return game.locations[hero.homeLocationId]
  }
}

function getHeroHomeSite({worldId}) {
  // let atWorld = worldId != null ? universe[worldId] : world
  if (hero.homeSiteId) {
    assert(game.locations.containsKey(hero.homeSiteId))
    return game.locations[hero.homeSiteId]
  }
}

function getHeroSect {
  if (hero.sectId) {
    return game.sects[hero.sectId]
  } else {
    return null
  }
}

function getHeroLightedArea {
  return hero.stats.lightRadius
}

// function getHeroCultivationGenre {
//   return hero.cultivationGenre
// }

function getTerrainByIndex(index, {worldId}) {
  let atWorld = worldId != null ? universe[worldId] : world
  return world.terrains[index]
}

function getTerrainByWorldPosition(left, top, {worldId}) {
  let atWorld = worldId != null ? universe[worldId] : world
  return world.terrains[tilePos2Index(left, top, world.width)]
}

function setCurrentWorld(id) {
  assert(universe.containsKey(id), '无法切换到不存在的世界: [${id}], 当前世界列表: [${universe.keys}]')
  world = universe[id]
  game.currentWorldId = id
  engine.info('设置当前世界为: [${id}]')

  return world
}

function deleteWorldById(id) {
  assert(world.id != id)
  engine.warn('删除世界数据: [${id}]')
  universe.remove(id)
}

function getWorldSize({worldId}) {
  let atWorld = worldId != null ? universe[worldId] : world
  return {
    width: atWorld.width,
    height: atWorld.height,
  }
}

function getZones({worldId}) {
  let atWorld = worldId != null ? universe[worldId] : world
  return atWorld.zones.values
}

function getZoneById(id: string, {worldId}) {
  let atWorld = worldId != null ? universe[worldId] : world
  return atWorld.zones[id]
}

function addObject(object, {worldId}) {
  let atWorld = worldId != null ? universe[worldId] : world
  atWorld.objects[object.id] = object
}

function removeObjectById(id, {worldId}) {
  let atWorld = worldId != null ? universe[worldId] : world
  delete atWorld.objects[id]
}

function getObjects({worldId}) {
  let atWorld = worldId != null ? universe[worldId] : world
  return atWorld.objects.values
}

function getObjectById(id: string, {worldId}) {
  let atWorld = worldId != null ? universe[worldId] : world
  return atWorld.objects[id]
}

function hasObject(id: string, {worldId}) {
  let atWorld = worldId != null ? universe[worldId] : world
  return atWorld.objects[id] != null
}

function getNameFromId(id, [orElse = 'null']) {
  if (id != null) {
    return id.split('.').last
  } else {
    return engine.locale(orElse)
  }
}

async function onNewGame() {
  game.isNewGame = false
  await onWorldEvent('onNewGame')
}
