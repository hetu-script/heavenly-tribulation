const kLocationDevelopmentMax = 5

const kLocationKindInlandCity = 'inland'
const kLocationKindHarborCity = 'harbor'
const kLocationKindIslandCity = 'island'
const kLocationKindMountainCity = 'mountain'

// 住宅列表，每个城市默认建筑
const kLocationKindResidence = 'residence'

// 主角设置宅家宅后的默认场景
const kLocationKindHome = 'home'
// 门派总堂，每个门派在总部的默认建筑，用来管理门派
const kLocationKindHeadquarters = 'headquarters'
// 城市总堂，每个城市默认建筑，用来管理城市
const kLocationKindCityhall = 'cityhall'
// 交易所，每个城市默认建筑，用来进行材料的交易
const kLocationKindTradingHouse = 'tradinghouse'
// 无为：问道碑，可以打坐获取功法
const kLocationKindDaoStele = 'daostele'
// 长生：聚灵阵，可以打坐获取经验值
const kLocationKindExpArray = 'exparray'
// 修真：藏书阁
const kLocationKindLibrary = 'library'
// 任侠：斗技场
const kLocationKindArena = 'arena'
// 权霸：哨所
const kLocationKindMilitaryPost = 'militarypost'
// 财富：拍卖行
const kLocationKindAuctionHouse = 'auctionhouse'
// 欢愉：酒楼
const kLocationKindHotel = 'hotel'
 
// 下面这些建筑是副职业，每种流派有两个
// 炼器工坊
const kLocationKindWorkshop = 'workshop'
// 灌灵池
const kLocationKindEnchantShop = 'enchantshop'
// 丹炉
const kLocationKindAlchemyLab = 'alchemylab'
// 纹身工坊
const kLocationKindTattooShop = 'tattooshop'
// 符法所
const kLocationKindRunelab = 'runelab'
// 阵法所
const kLocationKindArrayLab = 'arraylab'
// 幻术祭坛
const kLocationKindIllusionAltar= 'illusionaltar'
// 通灵居
const kLocationKindPsychicTemple = 'psychictemple'
// 观星台
const kLocationKindDivinationAltar = 'divinationaltar'
// 显圣殿
const kLocationKindTheurgyTemple = 'theurgytemple'

// 下面这些属于对应材料的产地
// 农场
const kLocationKindFarmland = 'farmland'
// 农场
const kLocationKindFishery = 'fishery'
// 林场
const kLocationKindTimberland = 'timberland'
// 猎场
const kLocationKindHuntingground = 'huntingground'
// 矿场
const kLocationKindMine = 'mine'

// 副本入口
const kLocationDungeonEntrance = 'dungeon'

// number of plain city background count
const _kCityPlainBackgroundCount = {
  '0': 3,
  '1': 3,
  '2': 3,
  '3': 4,
}

const _kCityMountainBackgroundCount = {
  '0': 3,
  '1': 3,
  '2': 3,
  '3': 3,
}

const _kCityShoreBackgroundCount = {
  '0': 3,
  '1': 3,
  '2': 3,
  '3': 3,
}

const _kBaseStoreMoneyAmount = 250000
const _kBaseStoreMaterialAmount = 100
const _kBaseItemReplenishAmount = 3
const _kBaseCollectableLightReplenishAmount = 10

const _kProductionSiteResourceGeneration = 10

const _kAlchemyCraftmaterialProbability = 0.35
const _kAlchemyCraftmaterialProbabilityReplaceAffix = 0.4
const _kAlchemyCraftmaterialProbabilityRerollAffix = 0.25
const _kAlchemyCraftmaterialProbabilityUpgradeRank = 0.1

/// 城市、场景、建筑等
/// 某些可能在地图上直接进入，某些则是其他场景的子场景
/// [category]: 'city', 'site'
/// [kind]: 'inland' | 'island'；'home', 'cityhall'
/// [isAffiliate] 表示这个建筑是某种不出现在城市场景列表中的场景，比如生产建筑的交易所 或者角色的住宅等
struct Location {
  constructor ({
    id,
    category,
    kind,
    isAffiliate,
    worldId,
    atTerrain,
    atCity,
    sectId,
    name,
    background,
    image,
    isHidden = false,
    isDiscovered = false,
    updateWorldMap = false,
    development,
    isCapitalCity = false,
    tradinghouseDevelopment,
    managerId,
    npcId,
    priority,
  }) {
    assert(category != null && kind != null)

    this.entityType = kEntityTypeLocation
    this.category = category
    this.kind = kind
    this.isAffiliate = isAffiliate ?? false

    this.createdTimestamp = game.timestamp

    // 这个城市的子场景，这里只保存id
    this.siteIds = []
    
    // 城市和场所的规模需要花费钱币、矿石和木材来升级
    this.development = development ?? 0
    this.isCapitalCity = isCapitalCity ?? false
    
    if (category == 'city') {
      if (name) {
        this.name = name
      } else {
        let randomName
        let conflict = false
        do {
          randomName = generateCityName(category: this.kind)
          conflict = game.locations[randomName] != null
        } while (conflict)
        this.name = randomName
      }
      
      this.id = id ?? this.name
      this.color = random.nextBrightColorHex()
      // 定居在这个城市的角色，这里只保存id
      this.residents = []
      
      // 城市的最大建筑数量
      this.maxSiteCount = calculateMaxSiteCountForCity(this)

      if (background != null) {
        this.background = background
      } else {
        switch (kind) {
          kLocationKindIslandCity, kLocationKindHarborCity : {
            const index = random.nextInt(_kCityShoreBackgroundCount[this.development])
            this.background = 'location/city/city_water_${this.development}_${index}.png'
          }
          kLocationKindMountainCity : {
            const index = random.nextInt(_kCityMountainBackgroundCount[this.development])
            this.background = 'location/city/city_mountain_${this.development}_${index}.png'
          }
          kLocationKindInlandCity: {
            const index = random.nextInt(_kCityPlainBackgroundCount[this.development])
            this.background = 'location/city/city_plain_${this.development}_${index}.png'
          }
        }
      }
    } else if (category == 'site') {
      this.name = name ?? engine.locale(kind)

      if (kind == kLocationKindHome) {
        assert(managerId != null, '住宅的 managerId 不能为空')
        this.id = '${managerId}_${kLocationKindHome}'
      } else {
        if (atCity != null) {
          this.id = atCity.id + '_' + this.name + '_' + crypto.randomUID();
        } else {
          this.id = id ?? (this.name + crypto.randomUID(withTime: true))
        }
      }

      this.image = image ?? 'location/card/${kind}.png'
      if (background != null) {
        this.background = background
      } else if (Constants.locationSiteKinds.contains(kind)) {
        this.background = 'location/site/${kind}.png'
      }

      if (priority == null) {
        assert(Constants.sitePriority.containsKey(this.kind), this.kind)
        this.priority = Constants.sitePriority[this.kind]
      } else {
        this.priority = priority
      }
      
      this.updateStatus = {}
      
      if (Constants.siteKindsManagable.containsKey(this.kind)) {
        resetLocationUpdateStatus(this)
      }
    } else {
      throw 'Invalid location category: [${category}]'
    }

    assert(this.id != null)
    if (game.locations.containsKey(this.id)) {
      engine.warn('已存在 id 为 ${this.id} 的场景，数据将被覆盖')
    }
    game.locations[this.id] = this

    this.isHidden = isHidden ?? false
    this.isDiscovered = !isHidden
    
    // 建筑的拥有者
    // 住所的 manager 就是这个住所的主人
    // city 的 manager 就是城主
    // 功能性建筑的owner就是总管
    // 如果同时有 managerId 和 sectID，意味着这个建筑为非私有
    // 住所的 manager 就是这个住所的主人
    this.managerId = managerId
    // 该城市的NPC，会显示在左侧列表中
    this.npcId = npcId
    if (this.kind == kLocationKindHome) {
      assert(this.managerId != null)
    }
    // 拥有建筑的门派
    this.sectId = sectId
    if (sectId != null) {
      final sect = game.sects[sectId]
      assert(sect != null, '组织不存在，id: ${sectId}')
      if (!sect.locationIds.contains(this.id)) {
        sect.locationIds.add(this.id)
      }
    }

    // 该城市的事件触发选项
    this.flags = {
      monthly: {},
    }

    // 大牢中的角色
    // 如果主角自己进入了监牢，则要通过监牢副本才能离开，并且离开后会进入本城市的敌对名单。
    // 另外两种选择是通过说服，或者贿赂离开
    // this.jailedCharacterIds = []

    // 城市的历史
    this.experienced = []

    // 和人物类似，也具有物品栏
    this.inventory = {}
    this.materials = {}

    // 仓库物资和materials分开
    // 仓库和materials都用来保存物资，但前者用于建筑维护和扩建
    // 后者则用于玩家和商店进行交易，后者的资金独立于前者，且无法直接取出，必须通过交易才可以获得
    this.storage = {}

    // 当此城市未被任何门派控制时=
    // 城市自身记录角色在此城市的功勋
    // key: characterId, value: contribution amount
    this.contributions = {}

    if (atTerrain != null) {
      engine.info('在${world.name} [${atTerrain.left},${atTerrain.top}] 建立了${this.name}')
      
      atTerrain.locationId = this.id
      
      this.worldId = worldId ?? world?.id
      this.worldPosition = {
        left: atTerrain.left,
        top: atTerrain.top,
      }
      this.terrainIndex = atTerrain.index

      if (this.category == 'city') {
        // 这个城市周围所控制的地块
        this.territoryIndexes = []
        // 保存了城市领地范围外可以扩张到的地块
        this.borderIndexes = []
        
        // atTerrain.kind = 'city'
        if (!this.isHidden) {
          atTerrain.overlaySprite = { sprite: kSpriteCity }
          if (updateWorldMap) {
            World.setTerrainCaption(atTerrain.left, atTerrain.top, this.name)
            World.updateTerrainOverlaySprite(atTerrain.left, atTerrain.top)
          }
        }
        
        /// 默认添加一个总堂建筑和一个交易所
        const cityhall = Location(
          id: this.id + '_cityhall',
          name: this.name + engine.locale('cityhall'),
          category: 'site',
          kind: kLocationKindCityhall,
          atCity: this,
          sectId: sectId,
          npcId: Constants.siteKindToNpcId[kLocationKindCityhall]
          development: this.development,
        )
        
        const tradinghouse = Location(
          id: this.id + '_tradinghouse',
          name: engine.locale('tradinghouse'),
          category: 'site',
          kind: kLocationKindTradingHouse,
          atCity: this,
          sectId: sectId,
          development: tradinghouseDevelopment ?? 0,
          npcId: Constants.siteKindToNpcId[kLocationKindTradingHouse]
        )
      } else {
        // 在大地图上的建筑也有 atCityId 方便查询
        this.atCityId = atCity?.id
      }
      engine.info('在 [${atTerrain.left},${atTerrain.top}] 建立了${this.name}')
    } else if (atCity != null) {
      engine.info('在${atCity.name}建立了${this.name}')
      this.atCityId = atCity.id
      atCity.siteIds.add(this.id)
    } else {
      if (kind != kLocationKindHome) {
        engine.warn('场景 ${this.name} 没有指定 atTerrain 或 atCity')
      }
    }
    
    if (this.kind == kLocationKindCityhall) {
      this.updateDay = 6
    } else {
      this.updateDay = random.nextInt(30) + 1
    }
  }
}

function resetLocationUpdateStatus(location) {
  assert(Constants.siteKindsManagable.containsKey(location.kind))
  final updateStatus = {}
  final maintainanceCost = Constants.siteKindsManagable[location.kind].maintainanceCost;
  if (maintainanceCost != null) {
    updateStatus.cost = {}
    for (final materialId in maintainanceCost.keys) {
      updateStatus.cost[materialId] =
        maintainanceCost[materialId] * (location.development + 1)
    }
  }
  location.updateStatus = updateStatus
}

// function addLocations(loca tions: List, {worldId, atTerrain, atCity, updateWorldMap = false }) {
//   engine.debug('载入地点数据')
//   for (const location in locations) {
//     if (location.nameId) {
//       location.name = engine.locale(location.nameId)
//     }
//     let atWorld = worldId != null ? universe[worldId] : world
//     let atTerrain
//     let atCity
//     if (location.terrainIndex) {
//       atTerrain = atWorld.terrains[location.terrainIndex]
//     }
//     if (location.atCityId) {
//       atCity = atWorld.locations[location.atCityId]
//     }
//     addLocation(location, worldId: worldId, atTerrain: atTerrain, atCity: atCity, updateWorldMap: updateWorldMap)
//   }
// }

function removeLocation(location, { updateWorldMap = false }) {
  assert(location.kind != kLocationKindHome, '住宅场景不能被移除！')
  engine.warn('正在移除场景 [${location.name}]！')
  for (final siteId in location.siteIds) {
    removeLocation(siteId)
  }
  if (location.npcId) {
    game.npcs.remove(location.npcId)
  }
  if (location.sectId) {
    const sect = game.sects[location.sectId]
    assert(sect != null, '组织不存在，id: ${location.sectId}')
    if (sect.locationIds.contains(location.id)) {
      sect.locationIds.remove(location.id)
    }
  }
  if (location.terrainIndex != null) {
    let atWorld = universe[location.worldId]
    const terrain = atWorld.terrains[location.terrainIndex]
    delete terrain.locationId
    delete terrain.overlaySprite
    if (updateWorldMap) {
      World.setTerrainCaption(terrain.left, terrain.top, null)
      World.updateTerrainOverlaySprite(terrain.left, terrain.top)
    }
  } else if (location.atCityId != null) {
    const atCity = game.locations[location.atCityId]
    assert(atCity != null, '场景不存在，id: ${location.atCityId}')
    if (atCity.siteIds.contains(location.id)) {
      atCity.siteIds.remove(location.id)
    }
  }
  delete game.locations[location.id]
}

function getLocationDistance(loc1, loc2) {
  return getTileDistance(loc1.tilePosition, loc2.tilePosition)
}

// 每个城市规模对应的居民上限
// 居民可以用于充当城市的仆役
// function maxPopulationOfLocationDevelopment(n: integer) {
//   return  (n - 1) * (n - 1) * (n - 1) * 50 + 100
// }

// function maxSiteNumberOfCityDevelopment(n: integer) {
//   return n * n + 1
// }

// 每个城市，每个月会自然增加人口，直到达到上限
// 人口上限会受到掌门的技能，门派的规模和价值观，以及城市的规模和建筑所影响
function increaseLocationPopulationPerMonth(location) {

}

function setCharacterLocationId(character, locationId: string) {
  character.locationId = locationId
}

// function getLocationById(id: string, {worldId}) {
//   // let atWorld = worldId != null ? universe[worldId] : world
//   return game.locations[id]
// }

function getLocations([ids]) {
  if (ids?.isNotEmpty) {
    return game.locations.values.where( (value) => value.id in ids )
  } else {
    return game.locations.values
  }
}

function getLocationByWorldPosition(left, top, {worldId}) {
  let atWorld = worldId != null ? universe[worldId] : world
  const tile = atWorld.terrains[tilePos2Index(left, top, atWorld.width)]
  if (tile.locationId) {
    return game.locations[tile.locationId]
  }
}

async function discoverLocation(location, { updateWorldMap = false }) {
  if (location.isDiscovered) return
  // engine.debug('发现新城市：${location.name}')
  location.isDiscovered = true
  assert(universe.containsKey(location.worldId), location.worldId)
  let atWorld = universe[location.worldId]
  if (updateWorldMap) {
    World.setTerrainCaption(location.worldPosition.left, location.worldPosition.top, location.name)
  }
  if (location.isHidden) {
    engine.warn('城市 ${location.name} 被发现，刷新大地图显示。')
    const tile = atWorld.terrains[location.terrainIndex]
    // tile.spriteIndex = kSpriteLand
    tile.overlaySprite = { sprite: kSpriteCity }
    if (updateWorldMap) {
      // World.setWorldMapSprite(location.worldPosition.left, location.worldPosition.top, kSpriteLand)
      await World.updateTerrainOverlaySprite(location.worldPosition.left, location.worldPosition.top)
    }
  }
}

function increaseLocationDevelopment(location) {
  if (location.development < kLocationDevelopmentMax) {
    ++location.development
  } else {
    engine.warn('城市 ${location.name} 的规模（${location.development}）已达到或超过最大值。')
  }
}

function setLocationWorldPosition(location, left, top, {worldId}) {
  if (left == null || top == null) {
    location.worldPosition = null
  } else {
    location.worldPosition = { left, top }
  }
  if (worldId != null) {
    location.worldId = worldId
  }
}

function replenishStorage(location) {
  assert(Constants.siteKindsManagable.containsKey(location.kind))

  final maintainanceCost = Constants.siteKindsManagable[location.kind].maintainanceCost
  if (!maintainanceCost) return

  for (final materialId in maintainanceCost.keys) {
    final amount = maintainanceCost[materialId] * (location.development + 1) * Constants.daysPerMonth
    location.storage[materialId] = amount
  }
}

function replenishTradingMoney(location) {
  location.materials = {}
  // 商店的可用货币应该与门派货币挂钩
  location.materials.money =
    _kBaseStoreMoneyAmount * (random.nearInt(location.development + 1) + 1)
  location.materials.shard =
    (_kBaseStoreMoneyAmount * (random.nearInt(location.development + 1) + 1))
      ~/ Constants.materialBasePrice.shard
}

function replenishTradingMaterials(location) {
  assert(location.kind == 'tradinghouse')

  final atCity = game.locations[location.atCityId]
  assert(atCity != null, 'location not found, id: ${location.atCityId}')
  assert(atCity.category == 'city')

  // 刷新交易所材料
  let price = {}
  for (final materialId in Constants.nonCurrencyMaterialKinds) {
    price[materialId] = 1.0
  }
  // 根据城市的纬度、季节和城市类型，决定材料的价格
  // 所有的变量的范围在 -0.25 ~ +0.25 之间

  // 纬度变量
  let latitudeFactor = 0.25 - (atCity.worldPosition.top / world.height) * 0.5

  // 纬度越高，劳工价格越高
  price.worker += latitudeFactor
  // 纬度越高，水资源价格越高
  price.water += latitudeFactor
  // 纬度越高，粮食价格越高
  price.grain += latitudeFactor
  // 纬度越高，生肉价格越低
  price.meat += -latitudeFactor
  // 纬度越高，皮革价格越低
  price.leather += -latitudeFactor
  // 纬度越高，药材价格越低
  price.herb += -latitudeFactor
  // 纬度越高，木材价格越低
  price.timber += -latitudeFactor
  // 纬度越高，石料价格越高
  price.stone += latitudeFactor
  // 纬度越高，矿物价格越高
  price.ore += latitudeFactor
  
  // 季节变量
  let seasonFactor
  final dt = Game.datetime()
  seasonFactor = switch (dt.month) {
    1 => 0.25
    2 => 0.167
    3 => 0.083
    4 => 0.0
    5 => -0.083
    6 => -0.167
    7 => -0.25
    8 => -0.167
    9 => -0.083
    10 => 0.0
    11 => 0.083
    12 => 0.167
  }

  // 夏秋劳工价格低，冬春劳工价格高
  price.worker += seasonFactor
  // 夏秋清水价格低，冬春清水价格高
  price.water += seasonFactor
  // 夏秋粮食价格低，冬春粮食价格高
  price.grain += seasonFactor
  // 夏秋生肉价格低，冬春生肉价格高
  price.meat += seasonFactor
  // 夏秋皮革价格高，冬春皮革价格低
  price.leather += -seasonFactor
  // 夏秋药材价格低，冬春药材价格高
  price.herb += seasonFactor
  // 夏秋木材价格高，冬春木材价格低
  price.timber += -seasonFactor
  // 夏秋石料价格高，冬春石料价格低
  price.stone += -seasonFactor
  // 夏秋矿物价格高，冬春矿物价格低
  price.ore += -seasonFactor

  let cityFactor
  if (atCity.kind == 'mountain') {
    // 山地
    cityFactor = 0.25
  } else if (atCity.kind == 'inland') {
    // 内陆
    cityFactor = 0.083
  } else if (atCity.kind == 'island') {
    // 岛屿
    cityFactor = -0.083
  } else if (atCity.kind == 'harbor') {
    // 港口
    cityFactor = -0.25
  }

  // 港口岛屿劳工价格低
  price.worker += cityFactor
  // 港口岛屿清水价格低
  price.water += cityFactor
  // 港口岛屿粮食价格低
  price.grain += cityFactor
  // 港口岛屿生肉价格低
  price.meat += cityFactor
  // 港口岛屿皮革价格低
  price.leather += cityFactor
  // 港口岛屿药材价格高
  price.herb += -cityFactor
  // 港口岛屿木材价格高
  price.timber += -cityFactor
  // 港口岛屿石料价格高
  price.stone += -cityFactor
  // 港口岛屿矿物价格高
  price.ore += -cityFactor

  // engine.log('latitude', atCity.worldPosition.top, atCity.id, 'latitude factor:', latitudeFactor)
  // engine.log('season', dt.month, atCity.id, 'season factor:', seasonFactor)
  // engine.log('city', atCity.category, atCity.id, 'city factor:', cityFactor)

  for (final key in price.keys) {
    let v = price[key].toDouble().toFixed(2)
    if (v < Constants.minSellRate) v = Constants.minSellRate
    price[key] = v
  }

  // 根据城市和其下属的生产场所的规模，决定材料的刷新数量

  let developmentFactor = {
    worker: atCity.development + 1,
    grain: 1,
    meat: 1,
    water: 1,
    leather: 1,
    herb: 1,
    timber: 1,
    stone: 1,
    ore: 1,
  }
  
  for (final terrainIndex in atCity.territoryIndexes) {
    final atWorld = universe[atCity.worldId]
    final terrain = atWorld.terrains[terrainIndex]
    if (terrain.locationId == null) continue
    final site = game.locations[terrain.locationId]
    switch (site.kind) {
      kLocationKindFarmland: {
        price.grain -= -0.125
        price.herb -= -0.125
        developmentFactor.grain += site.development + 1
        developmentFactor.herb += site.development + 1
      }
      kLocationKindFishery: {
        price.water -= -0.125
        price.meat -= -0.125
        developmentFactor.water += site.development + 1
        developmentFactor.meat += site.development + 1
      }
      kLocationKindHuntingground: {
        price.leather -= -0.125
        price.meat -= -0.125
        developmentFactor.leather += site.development + 1
        developmentFactor.meat += site.development + 1
      }
      kLocationKindTimberland: {
        price.timber -= -0.125
        price.herb -= -0.125
        developmentFactor.timber += site.development + 1
        developmentFactor.herb += site.development + 1
      }
      kLocationKindMine: {
        price.stone -= -0.125
        price.ore -= -0.125
        developmentFactor.stone += site.development + 1
        developmentFactor.ore += site.development + 1
      }
    }
  }

  location.priceFactor = { kind: price }

  for (final materialId in Constants.nonCurrencyMaterialKinds) {
    assert(developmentFactor.containsKey(materialId))
    final factor = developmentFactor[materialId]
    final amount = random.nextInt(_kBaseStoreMaterialAmount * factor)
    // engine.log(location.id, materialId, 'factor:', factor, 'amount:', amount)
    location.materials[materialId] = amount
  }
}

function replenishProductionMaterials(location) {
  assert(Constants.productionSiteKinds.contains(location.kind));
  
  let price

  switch (location.kind) {
    'farmland': {
      price = {
        'grain': 0.45,
        'herb': 0.75,
      }
    }
    'fishery': {
      price = {
        'water': 0.55,
        'meat': 0.65,
      }
    }
    'huntingground': {
      price = {
        'meat': 0.6,
        'leather': 0.7,
      }
    }
    'timberland': {
      price = {
        'herb': 0.6,
        'timber': 0.75,
      }
    }
    'mine': {
      price = {
        'stone': 0.65,
        'ore': 0.85,
      }
    }
  }

  location.priceFactor = { kind: price }

  let atWorld = universe[location.worldId]
  let terrain = atWorld.terrains[location.terrainIndex]
  
  for (final materialId in price.keys) {
    final amount = terrain.resources[materialId] * (location.development + 1) * _kProductionSiteResourceGeneration
    location.materials[materialId] = amount
  }
}

/// 刷新交易类场景的物品
function replenishTradingItem(location) {
  if (location?.entityType != kEntityTypeLocation) {
    engine.warn('replenishTradingItem 只能对 location 对象使用')
    return
  }
  if (!Constants.siteKindsTradable.contains(location.kind)) {
    engine.warn('场所 ${location.name} 不支持物品交易刷新')
    return
  }
  location.inventory = {}
  let amount = _kBaseItemReplenishAmount + location.development
  final atCity = game.locations[location.atCityId]
  assert(atCity != null, 'location not found, id: ${location.atCityId}')
  assert(atCity.category == 'city')
  final rank = location.development + 1
  switch (location.kind) {
    'tradinghouse': {
      // 根据地形，决定商店里是否有船只和靴子
      let hasMountainNeighbor = false
      let hasWaterNeighbor = false
      final neighbors = getTileNeighbors(atCity.worldPosition.left, atCity.worldPosition.top)
      for (final neighbor in neighbors.values) {
        if (neighbor.kind == 'mountain') {
          hasMountainNeighbor = true
        } else if (kWaterTerrainKinds.contains(neighbor.kind)) {
          hasWaterNeighbor = true
        }
      }
      if (hasMountainNeighbor) {
        let item = Equipment(kind: 'boots', rank: 0)
        entityAcquire(location, item)
      }
      if (hasWaterNeighbor) {
        let item = Equipment(kind: 'ship', rank: 0)
        entityAcquire(location, item)
      }
      for (var i in range(amount)) {
        final rankRoll = random.nextInt(location.development + 1)
        final typeRoll = random.nextDouble()
        let item
        if (typeRoll < 0.5) {
          item = Equipment(rank: rankRoll)
        } else if (typeRoll < 0.7) {
          item = Potion(rank: rankRoll)
        } else if (typeRoll < 0.9) {
          item = Cardpack(rank: rankRoll)
        } else {
          item = createItemById('identify_scroll')
        }
        entityAcquire(location, item)
      }
    }
    'auctionhouse': {
      for (final siteId in atCity.siteIds) {
        final site = game.locations[siteId]
        assert(site != null, 'location not found, id: ${siteId}')
        if (site.kind == kLocationKindWorkshop) {
          amount += site.development + 3
        }
      }

      for (var i in range(amount)) {
        let item = Equipment(rank: random.nextInt(kCultivationRankMax + 1), isIdentified: false)
        entityAcquire(location, item)
      }
    }
    'library': {
      final sect = game.sects[location.sectId]
      for (var i in range(amount)) {
        let genre = sect?.genre
        final genreRoll = random.nextDouble()
        if (genreRoll < 0.3) {
          genre = random.nextIterable(Constants.cultivationGenres)
        }
        let item = Cardpack(
          rank: random.nearInt(rank),
          genre: genre,
        )
        entityAcquire(location, item)
      }
    }
    'alchemylab': {
      // TODO: 丹房销售的丹药数量和苗圃数量有关
      for (var i in range(amount)) {
        let craftMaterialRoll = random.nextDouble()
        let craftMaterial
        final itemRank = random.nearInt(rank)
        if (craftMaterialRoll < _kAlchemyCraftmaterialProbability) {
          final typeRoll = random.nextDouble()
          if (typeRoll < _kAlchemyCraftmaterialProbabilityUpgradeRank) {
            craftMaterial = createItemById('craftmaterial_upgrade', rank: itemRank)
          } else if (typeRoll < _kAlchemyCraftmaterialProbabilityRerollAffix) {
            craftMaterial = createItemById('craftmaterial_rerollAffix', rank: itemRank)
          } else if (typeRoll < _kAlchemyCraftmaterialProbabilityReplaceAffix) {
            craftMaterial = createItemById('craftmaterial_replaceAffix', rank: itemRank)
          } else {
            craftMaterial = createItemById('craftmaterial_addAffix', rank: itemRank)
          }
          entityAcquire(location, craftMaterial)
        } else {
          final item = Potion(rank: random.nearInt(location.development + 1))
          entityAcquire(location, item)
        }
      }
    }
    'runelab': {
      for (var i in range(amount)) {
        final item = createItemById('identify_scroll')
        entityAcquire(location, item)
      }
      for (var i in range(rank)) {
        for (var j in range(amount)) {
          final paper = createItemById('scroll_paper', rank: i + 1)
          entityAcquire(location, paper)
        }
      }
    }
    else: {
      engine.error('场所 ${location.name} 不支持物品交易刷新')
    }
  }
}

/// 刷新聚灵阵中的可用灵气
function replenishCollectableLight(location) {
  assert(location.kind == 'exparray')
  // final atCity = game.locations[location.atCityId]
  // assert(atCity != null, 'location not found, id: ${location.atCityId}')
  // assert(atCity.category == 'city')

  final replenishAmount = Math.pow(_kBaseCollectableLightReplenishAmount, location.development) * 3
  location.collectableLight = random.nearInt(replenishAmount + 10) + 10
}
