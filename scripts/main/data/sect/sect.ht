import '../achievements.ht'

const _kNeighborIndex = [1, 2, 3, 4, 5, 6]

const _kMinJobRankForGlobalIncident = 3

/// 门派外交关系数据
/// 外交关系必然会在双方的数据中同时创建
/// score 和 type 都反映了外交关系
/// type 代表了关系的大方向，有三种取值： 'neutral' || 'ally' || 'enemy',
/// score 代表了关系的具体数值，score 可以正负变化
/// 盟友门派的成员可以共享各自领地上的设施
/// 宣战门派的成员则无法进入对方领地
/// 需要满足一定的 score 条件才能宣战和结盟
/// 修改 type 为 enemy，意味着宣战，ally 则意味着结盟
/// 但无论 score 如何变化，并不会自动变成 enemy 或 ally
/// 要提升 score，可以通过向其他门派赠送礼物、完成对方的帮助请求等方式
/// 要降低 score，可以通过
struct Diplomacy {
  constructor ({
    sect1Id,
    sect2Id,
    type = 'neutral',
    score = 0,
    timespanByMonth = 0, // 表示外交关系持续的时间，0 表示永久
  }) {
    assert(['neutral', 'ally', 'enemy'].contains(type))

    this.id = crypto.randomUID(withTime: true)
    this.sect1Id = sect1Id
    this.sect2Id = sect2Id
    this.timestamp = game.timestamp
    this.type = type;
    this.score = score
    this.timespanByMonth = timespanByMonth
    
    game.diplomacies[this.id] = this
  }
}

function updateTerritoryBorders(tile) {
  if (tile.nationId == null) return
  tile.borders ??= {}
  final neighbors = getTileNeighbors(tile.left, tile.top)
  for (final index in _kNeighborIndex) {
    final neighbor = neighbors[index]
    if (neighbor == null) continue
    if (neighbor.nationId != tile.nationId) {
      tile.borders[index] = true
    } else {
      delete tile.borders[index]
    }
  }
}

/// 创建一个门派
/// [category] 决定了经营类型
/// category 包含: 'cultivation' | 'religion' | 'business'
/// [genre] 决定了修炼类型，对应于角色的 cultivationFavor
/// genre 包含: 'spellcraft' | 'swordcraft' | 'bodyforge' | 'avatar' | 'vitality'
struct Sect {
  constructor ({
    id,
    name,
    category,
    genre,
    headquarters,
    headId,
    incurIncident = true,
  }) {
    assert(headquarters != null && headId != null)

    this.entityType = kEntityTypeSect

    this.createdTimestamp = game.timestamp
    // 该组织的事件触发选项
    this.flags = {
      monthly: {},
    }

    // 该组织解锁的科技
    // this.techs = {}

    // 该组织每年刷新时间的时间，一般都为 X 月 1 日
    // 例如招募大比时间等等，都发生在这个日期
    const randomMonth = random.nextInt(Constants.monthsPerYear)
    this.yearlyUpdateTime = randomMonth * Constants.ticksPerMonth + random.nextInt(Constants.ticksPerMonth)
    this.recruitMonth = randomMonth + 1

    this.headId = headId
    const head = game.characters[headId]
    assert(head != null, 'head character not found for id: ${headId}')
    assert(head.sectId == null, 'character ${head.name} already belongs to sect: ${head.sectId}, cannot be head of new sect!')
    
    // TODO: category 和 genre 应该和掌门人的属性相关联
    this.category = category ?? random.nextIterable(Constants.sectCategories)
    this.genre = genre
    if (this.genre == null) {
      this.genre = head.cultivationFavor ?? random.nextIterable(Constants.cultivationGenres)
    }
    
    assert(Constants.sectCategories.contains(this.category))
    assert(Constants.cultivationGenres.contains(this.genre))

    this.index = game.sects.length
    if (name) {
      this.name = name
    } else {
      let randomName
      let conflict = false
      do {
        randomName = generateOrganizationName(category: this.category)
        conflict = game.sects[randomName] != null
      } while (conflict)
      this.name = randomName
    }
    // this.id = '${this.entityType}.${this.index}.${this.id}'
    this.id = id ?? this.name
    
    if (game.sects.containsKey(this.id)) {
      engine.warning('已经存在 id 为 ${this.id} 的组织。旧数据将会被覆盖。')
    }
    game.sects[this.id] = this
    
    // 本门派统治的城市 id 列表
    this.locationIds = []
    // 曾经加入过的成员的职级等数据，key 是 角色的 id，value 是角色的 MemberData
    // memberData.isAbsent = true 表示该成员目前不在门派中
    this.membersData = {}

    // 门派的历史
    this.experienced = []

    // 门派政策
    // key 是 城市 id，值是 政策 id
    this.policies = {}
    
    // 门派牵涉到的外交关系数据 id 列表
    // 完整的外交关系数据保存在 game.diplomacies 中
    this.diplomacyIds = []

    // 国家区块颜色
    this.color = random.nextBrightColorHex()
    // // 本国统治的区块
    // this.territoryIndexes = []
    // // 与本国国界线相邻的外国区块
    // this.borderIndexes = []

    stationSect(this, headquarters)
    
    const incidentContent = engine.locale('sectBuild', interpolations: [
      head.name,
      headquarters.name,
      this.name,
    ])
    if (incurIncident) {
      // 触发创派事件，创派事件和成为掌门是两个事件
      Incident(
        subjectId: head.id,
        sectId: this.id,
        message: incidentContent,
        orderly: 2,
        isGlobal: true,
      )
    } else {
      engine.info(incidentContent)
    }
    addCharacterToSect(head, this, titleId: 'head', incurIncident: incurIncident)
    
    // 和人物类似，也具有物品栏
    this.inventory = {}
    this.materials = {}
  }
}

// TODO: 添加incident
function stationSect(sect, city, { incurIncident: bool }) {
  // TODO: 允许迁都
  assert(sect.headquartersLocationId == null,
    'sect already has headquarters location, cannot station again!')
  assert(city.sectId == null || city.sectId == sect.id,
    'headquarters location must be unowned or owned by the sect itself!')
  assert(city.category == 'city',
    'headquarters location must be a city!')
  if (city.sectId == null) {
    addLocationToSect(city, sect, incurIncident: incurIncident)
  }
  const headquarters = Location(
    name: sect.name,
    category: 'site',
    kind: kLocationKindHeadquarters,
    atCity: city,
    image: 'location/card/${sect.genre}.png'
    background: 'location/site/${sect.genre}.png'
    sectId: sect.id,
    npcId: Constants.siteKindToNpcId[kLocationKindHeadquarters]
    managerId: sect.headId,
    development: city.development,
  )
  sect.headquartersSiteId = headquarters.id
  sect.headquartersLocationId = city.id
  // TODO: 如果是迁都，需要检查原城市的规模是否大于新城市的规模
  sect.development = city.development
  sect.maxCityCount = maxCityCountForSectDevelopment(sect.development)
  city.isCapitalCity = true
  city.maxSiteCount = calculateMaxSiteCountForCity(city)
}

/// 查找某个组织中比指定职级高的成员数据列表
/// 返回的列表已经按职级从低到高排序
/// 输入的 rank 如果已经最高，会导致返回一个空数组
function getHigherRankMembersOfSect(sect, rank) {
  assert(rank >= 0 && rank <= kSectJobRankMax)
  let members = []
  let currentRank = rank + 1
  while (members.isEmpty && currentRank <= kSectJobRankMax) {
    members = sect.membersData.values.where(
      (m) => !m.isAbsent && m.rank == currentRank
    ).toList()
    currentRank += 1
  }
  members.shuffle()
  return members
}

/// 角色加入组织
/// 注意，这里并不处理师徒关系，可以理解为这里处理的是雇佣性质的工作岗位
/// 师徒关系需要另外调用 createShitu api 来创建
/// 角色可以加入多个组织，但只会保留最后一次加入时组织的 id
/// 只有角色最后一次加入的组织不是当前组织，才可以调用这个 api
/// 这个 api 不会检查角色的境界和贡献是否达到职位要求
function addCharacterToSect(character, sect, {
    titleId,
    assignManagingSite = true,
    moveToManagingSite = true,
    moveHome = true,
    assignSuperior = true,
    incurIncident = true,
  }) {
  assert(character.sectId == null, 'character already belongs to sect: ${sect.id}, cannot add to sect!')
  
  character.sectId = sect.id
  let memberData = sect.membersData[character.id]
  if (memberData == null) {
    sect.membersData[character.id] = memberData = MemberData(
      id: character.id,
      peer: sect.membersData.length,
    )
  }
  if (titleId != null) {
    assert(Constants.titleToJobRank.containsKey(titleId),
      'unknown sect title: ${titleId}')
    memberData.titleId = titleId
    memberData.rank = Constants.titleToJobRank[titleId]
  }
  
  addSectMonthly(sect, 'recruited', character.id)

  const incidentContent = engine.locale('characterEnlist', interpolations: [
    character.name,
    sect.name,
  ])
  if (incurIncident) {
    Incident(
      subjectId: character.id,
      sectId: sect.id,
      message: incidentContent,
      orderly: 1,
    )
  } else {
    engine.info(incidentContent)
  }

  titleId = checkCharacterTitle(character, setAsManger: true)
  if (titleId != null && titleId != memberData.titleId) {
    memberData.titleId = titleId
    memberData.rank = Constants.titleToJobRank[titleId]
  }
  setCharacterTitle(
    character,
    titleId,
    sect: sect,
    assignManagingSite: assignManagingSite,
    moveToManagingSite: moveToManagingSite,
    moveHome: moveHome,
    incurIncident: incurIncident,
  )
  
  if (titleId != 'head' && assignSuperior) {
    assignCharacterSuperior(character, sect)
  }
  
  return titleId
}

function removeCharacterFromSect(character, { incurIncident = true }) {
  assert(character.sectId != null,
    'character does not belong to any sect, cannot remove!')
  const sect = game.sects[character.sectId]
  assert(sect != null,
    'sect not found for id: ${character.sectId}')
  sect.membersData[character.id].isAbsent = true

  const title = engine.locale(character.titleId)
  character.titleId = null
  character.sectIds.add(character.sectId)
  character.sectId = null

  for (final locationId in character.managingLocationIds) {
    final location = game.locations[locationId]
    location.managerId = null
  }
  character.managingLocationIds.clear()
  
  const incidentContent = engine.locale('characterLeave', interpolations: [
    character.name,
    sect.name,
    title,
  ])
  if (incurIncident) {
    Incident(
      subjectId: character.id,
      sectId: sect.id,
      message: incidentContent,
      orderly: -2,
    )
  } else {
    engine.info(incidentContent)
  }
  return
}

/// 为角色分配合适的上级，注意上下级关系并非师徒关系
/// 因为上级涉及到角色家宅位置，所以和 addCharacterToSect api 分开
/// 这里也会同时保存向上级报告时的位置
/// 对于 rank 小于 3 (总管或以下) 的成员，报告位置在角色所在城市的会堂场景
/// 对于 rank 大于等于 3 (堂主) 的成员，报告位置在门派总堂所在城市的门派场景
function assignCharacterSuperior(character, sect) {
  assert(character.sectId == sect.id)
  const memberData = sect.membersData[character.id]
  assert(memberData != null && memberData.isAbsent == false,
    'character is not a member of sect: ${sect.name}, cannot assign superior!')
  // 分配前会清空原有的上级
  memberData.superiorId = null

  // 找到比自己职级高一级的成员
  let superiorsData = getHigherRankMembersOfSect(sect, memberData.rank)

  let memberAtCharacterHome
  for (final memberData in superiorsData) {
    final member = game.characters[memberData.id]
    assert(member != null, 'character not found for id: ${memberData.id}')
    if (character.homeLocationId == member.homeLocationId) {
      memberAtCharacterHome = memberData
      break
    }
  }
  assert(superiorsData.isNotEmpty,
    'no superior found for character: ${character.name} in sect, this should not happen because at least the head would be chosen. sect name: ${sect.name}!')

  if (memberAtCharacterHome == null) {
    // 没有找到在同一城市的上级，就近分配
    memberData.superiorId = superiorsData.first.id
  } else {
    memberData.superiorId = memberAtCharacterHome.id
  }
  
  if (memberData.rank < 3) {
    // 总管或以下，报告位置在角色所在城市的会堂场景
    const location = game.locations[character.homeLocationId]
    assert(location != null, 'location not found for id: ${character.homeLocationId}')
    let cityhallId = '${location['id']}_${location['id']}${engine.locale('cityhall')}'
    const cityhall = game.locations[cityhallId]
    assert(cityhall != null, 'cityhall not found for city: ${location.name}, cityhall id: ${cityhallId}')
    memberData.reportSiteId = cityhallId
    memberData.reportCityId = location.id
  } else {
    // 堂主，报告位置在门派总堂所在城市的门派场景
    const headquartersSiteId = '${sect.headquartersLocationId}_${sect.id}'
    const headquartersSite = game.locations[headquartersSiteId]
    assert(headquartersSite != null, 'headquarters not found for city: ${headquartersSite.name}, headquarters id: ${headquartersSiteId}')
    memberData.reportSiteId = headquartersSiteId
    memberData.reportCityId = sect.headquartersLocationId
  }

  engine.info('${character.id}在${sect.id}的上级是${memberData.superiorId}')
  return memberData.superiorId
}

/// 检查适合角色，且不同于角色当前称号的称号
/// setAsManger 表示是否立即分配到驻地
function checkCharacterTitle(character, { setAsManger = false}) {
  assert(character.sectId != null,
    'character does not belong to any sect, cannot check contribution!')
  const sect = game.sects[character.sectId]
  assert(sect != null,
    'sect not found for id: ${character.sectId}')
  // 这里成员数据可能是 null
  const memberData = sect.membersData[character.id]
  const currentContribution = memberData?.contribution ?? 0

  let titleId
  let managingSite
  let currentJobRank
  if (memberData.titleId != null) {
    titleId = memberData.titleId
    currentJobRank = memberData.rank ?? 0
  } else {
    let prevRank = character.rank - 1
    if (prevRank < 0) prevRank = 0
    titleId = Constants.cultivationRankToTitle[prevRank]
    currentJobRank = prevRank
  }
  if (currentJobRank >= kJobRankMax - 1) {
    // 门派掌门的职位不会通过晋升而得到，因此这里 rank 4 已经是最高了
    engine.warning('${character.name} 已经是最大职级，没有下一级职位了！')
  } else {
    const nextJobRank = currentJobRank + 1
    final requiredContributionForNextRank = contributionForJobRank(nextJobRank)
    if (currentContribution >= requiredContributionForNextRank && character.rank >= nextJobRank) {
      const nextJobRankTitle = Constants.cultivationRankToTitle[nextJobRank];
      assert(nextJobRankTitle != null,
        'job rank title not found for job rank: ${nextJobRank}');
      titleId = nextJobRankTitle
    }
  }

  if (titleId == character.titleId) {
    engine.info('${character.name} 当前职位是 ${titleId} 不需要变更')
    return null
  } else {
    return titleId
  }
}

/// 给一个角色设置称号或职位
/// 此函数不会检查职位本身的功勋需求和境界需求
/// 如果设置的职位高于杂役，还会直接赋予职位对应的功勋，以及为其分配适合的辖地
/// 如果没有辖地可供分配，会将职位改为同级别的替代职位
function setCharacterTitle(
  character,
  titleId, {
  sect,
  assignManagingSite = true,
  moveToManagingSite = true,
  moveHome = true,
  incurIncident = true,
}) {
  character.titleId = titleId

  if (sect != null) {
    let memberData = sect.membersData[character.id]
    assert(memberData != null,
        'character [${character.name}] is not a member of sect: ${sect.name}!')
    assert(Constants.titleToJobRank.containsKey(titleId),
        'unknown sect title: ${titleId}')
    if (memberData.title == titleId) {
      engine.error('character already has title: ${titleId} in sect: ${sect.id}, cannot set again!')
    }

    let managingSite
    switch (titleId) {
      case 'manager': {
        final sites = sect.locationIds
          .map((id) => game.locations[id])
          .where((loc) =>
            loc.category == 'site' &&
            Constants.siteKindsManagable.containsKey(loc.kind) &&
            loc.kind != kLocationKindHeadquarters &&
            loc.kind != kLocationKindCityhall &&
            loc.managerId == null
          )
        if (sites.isEmpty) {
          titleId = kTitleToAlternativeTitle[titleId]
          if (memberData.title == titleId) {
            engine.error('character already has title: ${titleId} in sect: ${sect.id}, cannot set again!')
          }
        } else {
          if (assignManagingSite) {
            managingSite = random.nextIterable(sites)
            managingSite.managerId = character.id
            if (!character.managingLocationIds.contains(managingSite.id)) {
              character.managingLocationIds.add(managingSite.id)
            }
            if (moveToManagingSite) {
              character.locationId = managingSite.id
            }
            if (moveHome) {
              final atCityId = managingSite.atCityId
              final atCity = game.locations[atCityId]
              assert(atCity != null, 'atCity not found for location: ${managingSite.id}')
              setCharacterHome(character, atCity, moveToHome: !moveToManagingSite)
            }
          }
        }
      }
      case 'mayor': {
        final cities = sect.locationIds
          .map((id) => game.locations[id])
          .where((loc) =>
            loc.category == 'city' &&
            loc.managerId == null
          )
        if (cities.isEmpty) {
          titleId = kTitleToAlternativeTitle[titleId]
          if (memberData.title == titleId) {
            engine.error('character already has title: ${titleId} in sect: ${sect.id}, cannot set again!')
          }
        } else {
          if (assignManagingSite) {
            managingCity = random.nextIterable(cities)
            managingCity.managerId = character.id
            character.managingLocationIds.clear()
            character.managingLocationIds.add(managingSite.id)
            if (moveToManagingSite) {
              let cityhallId = '${managingCity['id']}_${managingCity['id']}${engine.locale('cityhall')}'
              const cityhall = game.locations[cityhallId]
              assert(cityhall != null, 'cityhall not found for city: ${managingCity.name}, cityhall id: ${cityhallId}')
              character.locationId = cityhallId
            }
            if (moveHome) {
              setCharacterHome(character, managingCity, moveToHome: !moveToManagingSite)
            }
          }
        }
      }
      case 'governor': {
        final cities = sect.locationIds
          .map((id) => game.locations[id])
          .where((loc) =>
            loc.category == 'city' &&
            loc.managerId == null
          )
        if (cities.isEmpty) {
          titleId = kTitleToAlternativeTitle[titleId]
        } else {
          if (assignManagingSite) {
            managingCity = random.nextIterable(cities)
            managingCity.managerId = character.id
            if (!character.managingLocationIds.contains(managingSite.id)) {
              character.managingLocationIds.add(managingSite.id)
            }
            if (moveToManagingSite) {
              let cityhallId = '${managingCity['id']}_${managingCity['id']}${engine.locale('cityhall')}'
              const cityhall = game.locations[cityhallId]
              assert(cityhall != null, 'cityhall not found for city: ${managingCity.name}, cityhall id: ${cityhallId}')
              character.locationId = cityhallId
            }
            if (moveHome) {
              setCharacterHome(character, managingCity, moveToHome: !moveToManagingSite)
            }
          }
        }
      }
      case 'head': {
        if (moveToManagingSite) {
          const headquartersSiteId = '${sect.headquartersLocationId}_${sect.id}'
          const headquartersSite = game.locations[headquartersSiteId]
          assert(headquartersSite != null, 'headquarters not found for city: ${headquartersSite.name}, headquarters id: ${headquartersSiteId}')
          character.locationId = headquartersSiteId
          if (moveHome) {
            const headquartersLocation = game.locations[sect.headquartersLocationId]
            setCharacterHome(character, headquartersLocation, moveToHome: !moveToManagingSite)
          }
        }
      }
      else : {
        // 执事或以下
        if (moveHome) {
          final cities = sect.locationIds.map((id) => game.locations[id])
            .where((loc) => loc.category == 'city')
          const city = random.nextIterable(cities)
          if (moveToManagingSite) {
            character.locationId = '${character.id}_${kLocationKindHome}'
          }
          setCharacterHome(character, city, moveToHome: !moveToManagingSite)
        }
      }
    }

    let jobRank = Constants.titleToJobRank[titleId]
    let jobRankContribution = contributionForJobRank(jobRank)
    if (memberData.contribution < jobRankContribution) {
      memberData.contribution = jobRankContribution
    }
    if (memberData.rank < jobRank) {
      addSectMonthly(sect, 'promoted', character.id)
    }
    memberData.titleId = titleId
    memberData.rank = jobRank
    
    let incidentContent
    if (managingSite == null) {
      incidentContent = engine.locale('characterAcquireSectTitle', interpolations: [
        character.name,
        sect.name,
        engine.locale(titleId),
      ])
    } else {
      incidentContent = engine.locale('characterAcquireSectTitleWithManagingSite', interpolations: [
        character.name,
        sect.name,
        engine.locale(titleId),
        managingSite.name,
      ])
    }
    if (incurIncident) {
      Incident(
        subjectId: character.id,
        sectId: sect.id,
        locationId: sect.headquartersLocationId,
        message: incidentContent,
        orderly: jobRank,
        isGlobal: jobRank > _kMinJobRankForGlobalIncident,
      )
    } else {
      engine.info(incidentContent)
    }
  } else {
    const incidentContent = engine.locale('characterAcquireTitle', interpolations: [
      character.name,
      engine.locale(titleId),
    ])
    if (incurIncident) {
      // TODO: 非门派称号拥有各自不同的三观值
      Incident(
        subjectId: character.id,
        locationId: character.locationId,
      )
    } else {
      engine.info(incidentContent)
    }
  }
}

function addSects(orgs: List) {
  for (const org in orgs) {
    addSect(arg)
  }
}

function addSect(org) {
  assert(org.id != null)
  game.sects[org.id] = org
}

function getSectById(id: string) {
  return game.sects[id]
}

function getSects([ids]) {
  if (ids?.isNotEmpty) {
    return game.sects.values.where( (value) => value.id in ids )
  } else {
    return game.sects.values
  }
}

function removeLocationFromSect(location, sect) {
  if (location.sectId == null) return

  assert(location.sectId == sect.id)

  sect ??= game.sects[location.sectId]
  sect.locationIds.remove(location.id)
  location.sectId = null

  for (let siteId in location.siteIds) {
    const site = game.locations[siteId]
    removeLocationFromSect(site, sect)
  }

  if (location.terrainIndex == null) return;

  if (location.category == 'city') {
    for (final tileIndex in location.territoryIndexes) {
      final terrain = world.terrains[tileIndex]
      terrain.nationId = null
    }

    for (let siteId in location.siteIds) {
      const site = game.locations[siteId]
      if (site.kind == kLocationKindHeadquarters) {
        engine.warning('${sect.id} 失去了总堂所在地块！')
        delete game.locations[siteId]
        break
      }
    }
  }

  const incidentContent = engine.locale('entityLose', interpolations: [
    sect.name,
    location.name,
  ])
  if (incurIncident) {
    Incident(
      message: incidentContent,
      sectId: sect.id,
      locationId: location.id,
    )
  } else {
    engine.info(incidentContent)
  }

  return
}

function addLocationToSect(location, sect, { incurIncident = true }) {
  if (location.sectId == sect.id || sect.locationIds.contains(location.id)) {
    engine.warning('[${sect.name}] 已经拥有 [${location.name}]，不能再次添加！')
    return
  }
  if (location.sectId != null) {
    engine.error('[${location.name}] 已经被 [${location.sectId}] 占领，无法添加到组织 [${sect.name}]')
    return
  }

  sect.locationIds.add(location.id)
  location.sectId = sect.id
  location.managerId = sect.headId
  
  for (let siteId in location.siteIds) {
    const site = game.locations[siteId]
    site.sectId = sect.id
    sect.locationIds.add(site.id)
  }

  if (location.terrainIndex == null) return;

  if (location.category == 'city') {
    for (final tileIndex in location.territoryIndexes) {
      final terrain = world.terrains[tileIndex]
      terrain.nationId = sect.id
      if (tileIndex != location.terrainIndex && terrain.locationId != null) {
        final worldMapSite = game.locations[terrain.locationId]
        if (worldMapSite.sectId == sect.id) continue
        addLocationToSect(worldMapSite, sect, incurIncident: incurIncident)
      }
    }
  }

  const incidentContent = engine.locale('entityAcquire', interpolations: [
    sect.name,
    location.name,
  ])
  if (incurIncident) {
    Incident(
      message: incidentContent,
      sectId: sect.id,
      locationId: location.id,
    )
  } else {
    engine.info(incidentContent)
  }

  return
}

function createDiplomacy(sects: List, {
  type = 'neutral',
  score = kDiplomacyDefaultScore,
  timespanByMonth = 0, // 表示外交关系持续的时间，0 表示永久, > 0 表示持续多少个月
}) {
  assert(sect1.id != sect2.id)
  assert(!sect1.diplomacies.containsKey(sect2.id))
  assert(!sect2.diplomacies.containsKey(sect1.id))

  final diplomacyData = Diplomacy(
    sect1Id: sect1.id,
    sect2Id: sect2.id,
    type: type,
    score: score,
    timespanByMonth: timespanByMonth,
  )

  sect1.diplomacies[sect2.id] = diplomacyData.id
  sect2.diplomacies[sect1.id] = diplomacyData.id

  engine.info('${sect1.id}和${sect2.id}建立了外交关系，初始好感度为 ${score}，关系类型为 ${type}')
}
