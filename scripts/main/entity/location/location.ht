import '../../game/data.ht'
import '../character/character.ht'
import '../../game/dialog.ht'
import '../../name/location.ht'
import '../entity.ht'
import '../../world/tile/hexagonal_tile.ht'
import '../../world/tile/common.ht'
import '../item/material.ht'
import '../item/item.ht'
import '../../datetime.ht'
import '../entity.ht'
import '../organization/organization.ht'
import '../achievements.ht'

const _kLocationInitialStabilityMax = 50
const kLocationDevelopmentMax = 5

const kLocationKindInlandCity = 'inland'
const kLocationKindHarborCity = 'harbor'
const kLocationKindIslandCity = 'island'
const kLocationKindMountainCity = 'mountain'

// 住宅列表，每个城市默认建筑
const kLocationKindResidence = 'residence'

// 主角设置宅家宅后的默认场景
const kLocationKindHome = 'home'
// 集会所，每个城市默认建筑
const kLocationKindCityHall = 'cityhall'
// 藏书阁，交易所，拍卖行这三种建筑可以分别进行功法秘籍，材料和法宝的交易
// 他们可能属于某个组织，也可能没有组织。
// 交易所产生的物品、金钱等，存储于建筑本身，但可以由所有者提取。
// 藏书阁
const kLocationKindLibrary = 'library'
// 交易所
const kLocationKindTradingHouse = 'tradinghouse'
// 拍卖行
const kLocationKindAuctionHouse = 'auctionhouse'

// 演武场
const kLocationKindArena = 'arena'

// 下面这些属于对应材料的产地
// 矿场
const kLocationKindMine = 'mine'
// 林场
const kLocationKindTimberland = 'timberland'
// 农场
const kLocationKindFarmland = 'farmland'
// 猎场
const kLocationKindHuntingground = 'huntingground'
// 渔场
const kLocationKindFishery = 'fishery'
 
// 下面这些建筑对应于每种副职业
// 工坊
// 可以将谷物禽肉、兽肉、鱼肉加工成普通食物（材料）或者料理（单独的可使用物品）
// 可以将原木加工成木材或纸张，石料加工成石材或矿石
const kLocationKindWorkshop = 'workshop'
// 兽园
const kLocationKindZoo = 'zoo'
// 苗圃
const kLocationKindNursery = 'nursery'
// 阵法工坊
const kLocationKindArrayLab = 'arraylab'
// 符箓工坊
const kLocationKindRuneLab = 'scrolllab'
// 丹药工坊
const kLocationKindAcademyLab = 'academylab'
// 幻术祭坛
const kLocationKindIllusionAltar= 'illusionaltar'
// 炼魂祭坛
const kLocationKindPsychicAltar = 'psychicaltar'
// 卜卦祭坛
const kLocationKindDivinationAltar = 'divinationaltar'
// 显圣祭坛
const kLocationKindTheurgyAltar = 'theurgyaltar'

// number of plain city background count
const _kCityPlainDevelopment1BackgroundCount = 3
const _kCityPlainDevelopment2BackgroundCount = 8
const _kCityMountainDevelopment1BackgroundCount = 3
const _kCityMountainDevelopment2BackgroundCount = 4
const _kCityShoreDevelopment1BackgroundCount = 3
const _kCityShoreDevelopment2BackgroundCount = 4

/// 据点、场景、建筑等
/// 某些可能在地图上直接进入，某些则是其他场景的子场景
/// [category]: 'city', 'site'
/// [kind]: 'inland' | 'island'；'home', 'cityhall'
struct Location {
  constructor ({
    id,
    category,
    kind,
    worldId,
    atTerrain,
    atLocation,
    ownerId,
    organizationId,
    name,
    background,
    image,
    isDiscovered = true,
    isHidden = false,
    updateWorldMap = false,
  }) {
    assert(category != null && kind != null)

    this.entityType = kEntityTypeLocation
    this.category = category
    this.kind = kind
    this.id = id ?? crypto.randomUID(withTime: true)

    this.createdTimestamp = game.timestamp

    // 这个据点的子场景，这里只保存id
    this.sites = []
    
    if (category == 'city') {
      // this.addDefaultSites = addDefaultSites

      this.worldId = worldId ?? world.id
      let atWorld = worldId != null ? universe[worldId] : world
      
      // 定居在这个据点的角色的家，这里只保存id
      this.homes = []

      if (name) {
        this.name = name
      } else {
        let conflict = false
        do {
          const randomName = generateLocationName(category: this.category)
          this.name = randomName.name
          conflict = atWorld.locations.values.where((element) =>
            element.name == this.name).isNotEmpty
        } while (conflict)
      }
      
      // 据点发展度，最高5，初始0
      // 发展度决定了据点所能拥有的普通居民人口上限，所能拥有建筑的数量，以及能产生的悬赏任务上限等
      // 发展度需要花费钱币、矿石和木材来升级
      this.development = 0
      this.pupulation = random.nextInt(maxPopulationOfLocationDevelopment(0) / 5)
      
      if (background != null) {
        this.background = background
      } else {
        switch (kind) {
          kLocationKindIslandCity, kLocationKindHarborCity : {
            const index = random.nextInt(_kCityShoreDevelopment1BackgroundCount)
            this.background = 'location/city/city_water_${this.development}_${index}.png'
          }
          kLocationKindMountainCity : {
            const index = random.nextInt(_kCityMountainDevelopment1BackgroundCount)
            this.background = 'location/city/city_mountain_${this.development}_${index}.png'
          }
          kLocationKindInlandCity: {
            const index = random.nextInt(_kCityPlainDevelopment1BackgroundCount)
            this.background = 'location/city/city_plain_${this.development}_${index}.png'
          }
        }
      }
    } else if (category == 'site') {
      if (atLocation != null) {
        if (kind == kLocationKindHome) {
          atLocation.homes.add(this.id)
        } else {
          atLocation.sites.add(this.id)
        }
      }
      this.name = name ?? engine.locale(kind)
      this.image = image ?? 'location/card/${kind}.png'
      if (background != null) {
        this.background = background
      } else if (kLocationSiteKinds.contains(kind)) {
        this.background = 'location/site/${kind}.png'
      }
    } else {
      throw 'Invalid location category: [${category}]'
    }

    this.isDiscovered = isDiscovered
    this.isHidden = isHidden
    
    // 建筑的拥有者
    // 住所的owner就是这个住所的主人
    // 如果同时有 ownerId 和 organizationID，意味着这个建筑为非私有
    this.ownerId = ownerId
    // 住所的owner就是这个住所的主人
    if (this.kind == kLocationKindHome) {
      assert(this.ownerId != null)
    }
    // 拥有建筑的门派
    this.organizationId = organizationId
    // 该据点的事件触发选项
    this.flags = {}

    // 大牢中的角色
    // 如果主角自己进入了监牢，则要通过监牢副本才能离开，并且离开后会进入本据点的敌对名单。
    // 另外两种选择是通过说服，或者贿赂离开
    // this.jailedCharacterIds = []

    // 据点的历史
    this.experienced = []

    // 和人物类似，也具有物品栏
    this.inventory = {}
    this.materials = MaterialStorage()
    this.achievements = Achievements()

    // 为了兼容性，地块的门派没有用organizationId而是用了nationId
    // this.nationId
    
    // 普通居民决定了税收收入，以及外门弟子的数量
    // const minP = maxPopulationOfLocationDevelopment(this.development - 1)
    // const maxP = maxPopulationOfLocationDevelopment(this.development)
    // this.population = random.nextInt(maxP - minP) + minP

    // 被禁止进入的名单，名单可能重叠
    // 一个人本身在名单上，但他的国家也可能在名单上，并且互相独立
    // this.banLists = {
    //   characterIds: [],
    //   organizationIds: [],
    //   // nationIds: [],
    // }
    
    // 该对象知道的事情
    // 保存的是incident的index
    this.known = []

    // isMain == true 时自动添加到当前世界
    // this.isMain = isMain
    // if (this.isMain) {
    //   addLocation(this, atTerrain: atTerrain, atLocation: atLocation, updateWorldMap: updateWorldMap)
    // }

    let atWorld = worldId != null ? universe[worldId] : world
    if (atWorld.locations.containsKey(this.id)) {
      engine.warn('世界 [${atWorld.name}] 上已经添加过场景(id [${this.id}])，数据将会被覆盖')
    }

    atWorld.locations[this.id] = this

    if (atLocation == null) {
      assert(atTerrain != null)

      atTerrain.locationId = this.id
      
      this.terrainIndex = atTerrain.index
      this.worldPosition = {
        left: atTerrain.left,
        top: atTerrain.top,
      }

      if (this.category == 'city') {
        if (!this.isHidden) {
          atTerrain.overlaySprite = { sprite: kSpriteCity }
          if (updateWorldMap) {
            World.setTerrainCaption(atTerrain.left, atTerrain.top, this.name)
            World.updateTerrainOverlaySprite(atTerrain.left, atTerrain.top)
          }
        }
        // Location(category: 'site', kind: kLocationKindCityHall, atLocation: this)
        // 城市据点默认会添加一个住所入口
        Location(category: 'site', kind: kLocationKindResidence, atLocation: this)
      }

      engine.debug('在 ${atWorld.name} [${atTerrain.left}, ${atTerrain.top}] 建立了 ${this.name}')
    } else {
      this.atLocationId = atLocation.id

      engine.debug('在 ${atLocation.name} 建立了 ${this.name}')
    }
  }
}

// function addLocations(loca tions: List, {worldId, atTerrain, atLocation, updateWorldMap = false }) {
//   engine.debug('载入地点数据')
//   for (const location in locations) {
//     if (location.nameId) {
//       location.name = engine.locale(location.nameId)
//     }
//     let atWorld = worldId != null ? universe[worldId] : world
//     let atTerrain
//     let atLocation
//     if (location.terrainIndex) {
//       atTerrain = atWorld.terrains[location.terrainIndex]
//     }
//     if (location.atLocationId) {
//       atLocation = atWorld.locations[location.atLocationId]
//     }
//     addLocation(location, worldId: worldId, atTerrain: atTerrain, atLocation: atLocation, updateWorldMap: updateWorldMap)
//   }
// }

function removeLocationById(locationId: string) {
  let location = getLocationById(locationId)
  if (location != null) {
    for (final siteId in location.sites) {
      removeLocationById(siteId)
    }
    assert(univers.containsKey(location.worldId))
    let atWorld = universe[location.worldId]
    engine.warn('正在从世界 [${atWorld.name}] 移除场景 [${location.name}]！')
    if (location.category == 'city' && location.isDiscovered) {
      assert(location.terrainIndex != null)
      const terrain = atWorld.terrains[location.terrainIndex]
      delete terrain.locationId
      World.setTerrainCaption(terrain.left, terrain.top, null)
      delete terrain.overlaySprite
      World.updateTerrainOverlaySprite(terrain.left, terrain.top)
    }
    delete atWorld.locations[locationId]
  }
}

function getLocationDistance(loc1, loc2) {
  return getTileDistance(loc1.tilePosition, loc2.tilePosition)
}

// 每个城市发展度对应的居民上限
// 居民可以用于充当据点的仆役
function maxPopulationOfLocationDevelopment(n: integer) {
  return  (n - 1) * (n - 1) * (n - 1) * 50 + 100
}

function maxSiteNumberOfLocationDevelopment(n: integer) {
  return (n + 1) * n ~/ 2 + 1
}

// 每个据点，每个月会自然增加人口，直到达到上限
// 人口上限会受到掌门的技能，门派的发展度和价值观，以及据点的发展度和建筑所影响
function increaseLocationPopulationPerMonth(location) {

}

function setCharacterLocationId(character, locationId: string) {
  character.locationId = locationId
}

function getLocationById(id: string, {worldId}) {
  let atWorld = worldId != null ? universe[worldId] : world
  return atWorld.locations[id]
}

function getLocations({ids, worldId}) {
  let atWorld = worldId != null ? universe[worldId] : world
  if (ids != null) {
    assert(ids.isNotEmpty)
    return atWorld.locations.values.where( (value) => value.id in ids )
  } else {
    return atWorld.locations.values
  }
}

function getLocationByWorldPosition(left, top, {worldId}) {
  let atWorld = worldId != null ? universe[worldId] : world
  const tile = atWorld.terrains[tilePos2Index(left, top, atWorld.width)]
  if (tile.locationId)
  return atWorld.locations[tile.locationId]
}

function discoverLocation(location) {
  if (location.isDiscovered) return
  engine.debug('发现新据点：${location.name}')
  location.isDiscovered = true
  assert(location.worldId != null)
  assert(universe.containsKey(location.worldId))
  let atWorld = universe[location.worldId]
  World.setTerrainCaption(location.worldPosition.left, location.worldPosition.top, location.name)
  if (location.isHidden) {
    const tile = atWorld.terrains[location.terrainIndex]
    // tile.spriteIndex = kSpriteLand
    tile.overlaySprite = { sprite: kSpriteCity }
    // World.setWorldMapSprite(location.worldPosition.left, location.worldPosition.top, kSpriteLand)
    World.updateTerrainOverlaySprite(location.worldPosition.left, location.worldPosition.top)
  }
}

function increaseLocationDevelopment(location) {
  if (location.development < kLocationDevelopmentMax) {
    ++location.development
  } else {
    engine.warn('据点 ${location.name} 的发展度（${location.development}）已达到或超过最大值。')
  }
}
