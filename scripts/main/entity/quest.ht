const kQuestDifficultyEasy = 'easy'
const kQuestDifficultyNormal = 'normal'
const kQuestDifficultyChallenging = 'challenging'
const kQuestDifficultyHard = 'hard'
const kQuestDifficultyTough = 'tough'
const kQuestDifficultyBrutal = 'brutal'

const kQuestDifficultyMax = 5

const kBaseBountyReplenishAmount = 1

const kBaseAmountForDeliveryMaterial = 100
const kTimeLimitDaysBase = 5
const kTimeLimitDaysVariation1 = 10
const kTimeLimitDaysVariation2 = 45

const kHiddenCityShardReward = 2

const kBaseReward = 500
const kBaseRewardForEscort = 500
const kBaseRewardForDiscoverLocation = 1000

const kBudgetFactorForPurchaseMaterial = 0.8

function _createTimeLimit(difficulty) {
  return (kTimeLimitDaysBase
          + random.nextInt(kTimeLimitDaysVariation1)
          + (kTimeLimitDaysVariation2 * (1 - difficulty / kQuestDifficultyMax)).round()) * kTicksPerDay
}

struct Quest {
  // 运送材料
  // 报酬是材料基础价值的 1/5
  // 运送时可能遇到其他修士抢劫，几率与材料数量和价值成正比
  function deliver_material(organization, cityhall, difficulty) {
    final sites = game.locations.values
      .where((loc) {
        if (loc.atLocationId != null) {
          final atLocation = game.locations[loc.atLocationId]
          if (!atLocation.isDiscovered) return false
        }
        return loc.category == 'site' && loc.atLocationId != cityhall.atLocationId && !loc.isAffiliate
      })
    if (sites.isEmpty) return
    final endSite = random.nextIterable(sites)
    final endLocation = game.locations[endSite.atLocationId]

    final characters = organization.membersData.values
      .map((data) => game.characters[data.id])
    let receiver
    if (characters.isNotEmpty) {
      receiver = random.nextIterable((characters))
    }

    final material = random.nextIterable(Constants.nonCurrencyMaterialKinds)
    final amount = kBaseAmountForDeliveryMaterial + random.nextInt(kBaseAmountForDeliveryMaterial * difficulty + 1)
    
    final moneyRewardAmount = kBaseReward * (difficulty + 1) + Constants.materialBasePrice[material] * amount ~/ 5
    final shardRewardAmount = convertMoneyToShard(moneyRewardAmount)

    final endLocationDesc
    if (endLocation != null) {
      endLocationDesc = endLocation.name
    } else {
      assert(endSite.worldPosition != null)
      endLocationDesc = '${engine.locale('worldMap')}[${endSite.worldPosition.left}, ${endSite.worldPosition.top}]';
    }

    final interpolations = [
      amount,
      engine.locale(material),
      endLocationDesc,
      endSite.name,
    ]

    return {
      'kind': 'deliver_material',
      'difficulty': difficulty,
      'timeLimit': _createTimeLimit(difficulty),
      'acquiredFromSiteId': cityhall.id,
      'receiverId': receiver?.id,
      'package': {
        'type': 'material',
        'material': material,
        'amount': amount,
      },
      'reward': [
        {
          type: 'material',
          kind: difficulty == 0 ? 'money' : 'shard',
          amount: difficulty == 0 ? moneyRewardAmount : shardRewardAmount,
        }
      ],
      'reportSiteId': endSite.id,
      interpolations: interpolations,
    }
  }

  // 运送物品
  // 报酬是物品基础价值的 1/5
  // 运送时可能遇到其他修士抢劫，几率与材料数量和价值成正比
  function deliver_item(organization, cityhall, difficulty) {
    final sites = game.locations.values
      .where((loc)  {
        if (loc.atLocationId != null) {
          final atLocation = game.locations[loc.atLocationId]
          if (!atLocation.isDiscovered) return false
        }
        return loc.category == 'site' && loc.atLocationId != cityhall.atLocationId && !loc.isAffiliate
      })
    if (sites.isEmpty) return
    final endSite = random.nextIterable(sites)
    final endLocation = game.locations[endSite.atLocationId]

    final characters = organization.membersData.values
      .map((data) => game.characters[data.id])
    let receiver
    if (characters.isNotEmpty) {
      receiver = random.nextIterable(characters)
    }

    let item
    final typeRoll = random.nextDouble()
    if (typeRoll < 0.33) {
      item = Equipment(rank: difficulty)
    } else if (typeRoll < 0.66) {
      item = Potion(rank: difficulty)
    } else {
      item = Cardpack(rank: difficulty)
    }

    final moneyRewardAmount = kBaseReward * (difficulty + 1) + item.basePrice ~/ 5
    final shardRewardAmount = convertMoneyToShard(moneyRewardAmount)

    final endLocationDesc
    if (endLocation != null) {
      endLocationDesc = endLocation.name
    } else {
      if (endSite.worldPosition == null) {
        engine.warn('endSite worldPosition is null, id: ${endSite.id}, name: ${endSite.name}, kind: ${endSite.kind}')
      }
      assert(endSite.worldPosition != null)
      endLocationDesc = '${engine.locale('worldMap')}[${endSite.worldPosition.left}, ${endSite.worldPosition.top}]';
    }

    final interpolations = [
      item.name,
      endLocationDesc,
      endSite.name,
    ]

    return {
      'kind': 'deliver_item',
      'difficulty': difficulty,
      'timeLimit': _createTimeLimit(difficulty),
      'acquiredFromSiteId': cityhall.id,
      'receiverId': receiver?.id,
      'package': {
        'type': 'item',
        'item': item,
      },
      'reward': [
        {
          type: 'material',
          kind: difficulty == 0 ? 'money' : 'shard',
          amount: difficulty == 0 ? moneyRewardAmount : shardRewardAmount,
        }
      ],
      'reportSiteId': endSite.id,
      interpolations: interpolations,
    }
  }

  // 护送角色
  // 陪同某个人从一个据点的某个场景到另一个据点的某个场景
  function escort(organization, cityhall, difficulty) {
    final sites = game.locations.values
      .where((loc)  {
        if (loc.atLocationId != null) {
          final atLocation = game.locations[loc.atLocationId]
          if (!atLocation.isDiscovered) return false
        }
        return loc.category == 'site' && loc.atLocationId != cityhall.atLocationId && !loc.isAffiliate
      })
    if (sites.isEmpty) return
    final endSite = random.nextIterable(sites)
    final endLocation = game.locations[endSite.atLocationId]

    final characterIds = organization.membersData.values
      .map((data) => data.id)
    let escortee
    if (characterIds.isNotEmpty) {
      escortee = game.characters[random.nextIterable(characterIds)]
    }

    final moneyRewardAmount = kBaseRewardForEscort * (difficulty + 1)
    final shardRewardAmount = convertMoneyToShard(moneyRewardAmount)

    final endLocationDesc
    if (endLocation != null) {
      endLocationDesc = endLocation.name
    } else {
      assert(endSite.worldPosition != null)
      endLocationDesc = '${engine.locale('worldMap')}[${endSite.worldPosition.left}, ${endSite.worldPosition.top}]';
    }
    
    final interpolations = [
      escortee.name,
      endLocationDesc,
      endSite.name,
    ]

    return {
      'kind': 'escort',
      'difficulty': difficulty,
      'timeLimit': _createTimeLimit(difficulty),
      'acquiredFromSiteId': cityhall.id,
      'package': {
        'type': 'character',
        'characterId': escortee.id,
      },
      'reward': [
        {
          type: 'material',
          kind: difficulty == 0 ? 'money' : 'shard',
          amount: difficulty == 0 ? moneyRewardAmount : shardRewardAmount,
        }
      ],
      'reportSiteId': endSite.id,
      interpolations: interpolations,
    }
  }

  // 购买任务，材料，获取某种数量的指定材料
  // 报酬是剩余的预算
  function purchase_material(organization, cityhall, difficulty) {
    final atLocation = game.locations[cityhall.atLocationId]
    assert(atLocation != null, 'location not found, id: ${cityhall.atLocationId}')
    assert(atLocation.category == 'city')

    final material = random.nextIterable(Constants.nonCurrencyMaterialKinds)
    final amount = kBaseAmountForDeliveryMaterial + random.nextInt(kBaseAmountForDeliveryMaterial) * (difficulty + 1)

    final moneyBudget = kBaseReward * (difficulty + 1) +
            (Constants.materialBasePrice[material] * amount * kBudgetFactorForPurchaseMaterial).round()

    final interpolations = [
      amount,
      engine.locale(material),
      atLocation.name,
      cityhall.name,
    ]

    return {
      'kind': 'purchase_material',
      'difficulty': difficulty,
      'timeLimit': _createTimeLimit(difficulty),
      'acquiredFromSiteId': cityhall.id,
      'requirement': {
        type: 'material',
        material: material,
        amount: amount,
      },
      'budget': {
        type: 'material',
        kind: 'money',
        amount: moneyBudget,
      },
      'reportSiteId': cityhall.id,
      'interpolations': interpolations,
    }
  }

  // 购买任务，获取某种指定的装备、丹药或者秘籍
  // 报酬是剩余的预算
  function purchase_item(organization, cityhall, difficulty) {
    final atLocation = game.locations[cityhall.atLocationId]
    assert(atLocation != null, 'location not found, id: ${cityhall.atLocationId}')
    assert(atLocation.category == 'city')

    let requirement
    let itemDesc
    final rarity = Constants.rankToRarity[difficulty]
    final typeRoll = random.nextDouble()
    if (typeRoll < 0.33) {
      final randomEquipmentCategory = random.nextIterable(Constants.equipmentCategoryKinds.keys)
      final randomEquipmentKind = random.nextIterable(Constants.equipmentCategoryKinds[randomEquipmentCategory])
      requirement = {
        'type': 'equipment',
        category: randomEquipmentCategory,
        kind: randomEquipmentKind,
        rank: difficulty,
        rarity: rarity,
      }
      itemDesc = engine.locale(rarity) + engine.locale(randomEquipmentKind)
    } else if (typeRoll < 0.66) {
      requirement = {
        'type': 'potion',
        category: 'potion',
        rank: difficulty,
        rarity: rarity,
      }
      itemDesc = engine.locale(rarity) + engine.locale('potion')
    } else {
      requirement = {
        'type': 'cardpack',
        category: 'cardpack',
        genre: difficulty == 0 ? 'none' : random.nextIterable(Constants.cultivationGenres),
        rank: difficulty,
      }
      itemDesc = engine.locale('cultivationRank_${difficulty}') + engine.locale('rank2') + engine.locale('cardpack')
    }

    final budget = kBaseReward * (difficulty + 1) +
          (estimatePrice(requirement.category, requirement.rank) * kEstimatePriceFactor).round()
    final shardRewardAmount = convertMoneyToShard(budget)

    final interpolations = [
      itemDesc,
      atLocation.name,
      cityhall.name,
    ]

    return {
      'kind': 'purchase_item',
      'difficulty': difficulty,
      'timeLimit': _createTimeLimit(difficulty),
      'acquiredFromSiteId': cityhall.id,
      'requirement': requirement,
      'budget': {
        type: 'material',
        kind: difficulty == 0 ? 'money' : 'shard',
        amount: difficulty == 0 ? budget : shardRewardAmount,
      },
      'reportSiteId': cityhall.id,
      interpolations: interpolations,
    }
  }

  // 探索某个隐藏据点
  function discover_location(organization, cityhall, difficulty) {
    final atLocation = game.locations[cityhall.atLocationId]
    assert(atLocation != null, 'location not found, id: ${cityhall.atLocationId}')
    assert(atLocation.category == 'city')

    final sites = game.locations.values
      .where((loc) => loc.category == 'city' && loc.isHidden == true && loc.isDiscovered == false)
    if (sites.isEmpty) return
    final targetLocation = random.nextIterable(sites)

    final targetLeft = targetLocation.worldPosition.left
    final targetTop = targetLocation.worldPosition.top

    final deviationLeft = targetLeft + (random.nextBool() ? difficulty : -difficulty)
    final deviationTop = targetTop + (random.nextBool() ? difficulty : -difficulty)
    
    let moneyRewardAmount = kBaseRewardForDiscoverLocation * (difficulty + 1)
    if (targetLocation.kind == 'island') {
      moneyRewardAmount *= difficulty + 1
    } 
    final shardRewardAmount = convertMoneyToShard(moneyRewardAmount)

    final interpolations = [
      '[${deviationLeft}, ${deviationTop}]',
      targetLocation.name,
    ]

    return {
      'kind': 'discover_location',
      'difficulty': difficulty,
      'timeLimit': _createTimeLimit(difficulty),
      'acquiredFromSiteId': cityhall.id,
      'targetLocationId': targetLocation.id,
      'reward': [
        {
          type: 'material',
          kind: difficulty == 0 ? 'money' : 'shard',
          amount: difficulty == 0 ? moneyRewardAmount : shardRewardAmount,
        }
      ],
      'reportSiteId': cityhall.id,
      interpolations: interpolations,
    }
  }
}


function initEscort(quest) {
  assert(quest.kind == 'escort', 'quest kind is not escort, kind: ${quest.kind}')
  final escorteeId = quest.package.characterId;
  final escortee = game.characters[escorteeId];

  let escortType = 'stranger'
  final bond = haveMet(escortee, hero)
  if (bond?.score > 0) {
    escortType = 'acquintance'
  }

  if (escortee.organizationId && escortee.organizationId == hero.organizationId) {
    final escorteeMemberData = organization.membersData[escortee.id]
    final heroMemberData = organization.membersData[hero.id]
    if (escorteeMemberData.rank > heroMemberData.rank) {
      escortType = 'superior'
    } else if (escorteeMemberData.rank < heroMemberData.rank) {
      escortType = 'respectful'
    }
  } else {
    if (escortee.rank > hero.rank) {
      escortType = 'intimidate'
    } else if (escortee.rank < hero.rank) {
      escortType = 'respectful'
    }
  }

  quest.escortType = escortType

  characterMet(escortee, hero)

  return escortType
}

function createBounty(organization, cityhall, { maxDifficulty: integer }) {
  let bounty
  // 因为任务可能会因为一些原因生成失败导致返回 null，这里需要循环尝试
  while(bounty == null) {
    final kind = random.nextIterable(game.quests.keys)
    final difficulty = random.nextInt(maxDifficulty + 1)
    final ctor = Quest[kind]
    assert(ctor != null, 'quest generator function not found: ${kind}')
    bounty = ctor(organization, cityhall, difficulty)
  }

  return bounty
}

/// 刷新悬赏任务，这里不检查据点类型
function replenishBounty(location) {
  final organization = game.organizations[location.organizationId]
  if (organization == null) {
    engine.warn('location ${location.name} has no organization, skip replenish bounty')
    return
  }
  
  // 清空现有悬赏任务
  location.bounties = []
  
  final amount = kBaseBountyReplenishAmount + location.development

  for (var i in range(amount)) {
    final bounty = createBounty(organization, location, maxDifficulty: location.development)
    location.bounties.add(bounty)
  }
}
