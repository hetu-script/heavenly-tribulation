import '../world/tile/common.ht'


external function minLevelForRank(rank) -> integer

external function maxLevelForRank(rank) -> integer

external function fameForRank(rank) -> integer

external function expForLevel(level: integer) -> integer

external function contributionForJobRank(jobRank) -> integer

external function buildingCountForDevelopment(development) -> integer

external function getMinMaxExtraAffixCount(rank) -> Map

external function getTribulationCountForRank(rank) -> integer

external function getCardCraftMaterial(operationId, card) -> integer 

external function getDeckLimitForRank(rank) -> Map

// external function calculateItemPrice(item, {priceFactor, isSell = true}) -> integer

external function estimateItemPrice(category, rank, {range = 'normal'}) -> integer

external function generateCityTerritory(world)

external function generateZone(world)

const _kMoneyRewardRate = 0.4
const kRewardProbabilityExppack = 1.0
const kRewardProbabilityMoney = 1.0
const kRewardProbabilityShard = 0.4
const kRewardProbabilityEquipment = 0.3
const kRewardProbabilityPotion = 0.2
const kRewardProbabilityCardpack = 0.2
const kRewardProbabilityScrollPaper = 0.1
const kRewardProbabilityCraftMaterial = 0.1
const kRewardProbabilityDungeonTicket = 0.02
const _kRewardProbabilityDungeonTicketNextLevel = 0.4

const _kRewardProbabilityCraftMaterialReplaceAffix = 0.45
const _kRewardProbabilityCraftMaterialRerollAffix = 0.25
const _kRewardProbabilityCraftMaterialUpgradeRank = 0.1

const _kSpiritWellProbabilityCraftMaterial = 0.5

/// 根据一个概率表生成战斗奖励
/// entity: 游戏对象，通常是敌人
/// details: {
///  exp: 0.8,
///  money: 0.7,
///  shard: 0.5,
///  equipment: 0.3,
///  cardpack: 0.2,
///  potion: 0.2,
///  scrollPaper: 0.1,
///  craftMaterial: 0.1,
///  dungeonTicket: 0.02, 
///  // 只有当生成了 dungeonTicket 时才会生效
///  dungeonTicketNextLevel: 0.4,
/// }
function createReward({entity, details: {}}) {
  let rewardExp
  if (entity == null || (hero.rank - entity.rank) > 2) {
    rewardExp = 0
  } else {
    rewardExp = random.nextDouble() < (details?.exp.probability ?? kRewardProbabilityExppack)
  }

  entity ??= hero
  let rewardMoney
  let rewardShard
  if (entity.rank <= 0) {
    rewardShard = false
    rewardMoney = random.nextDouble() < (details?.money.probability ?? kRewardProbabilityMoney)
  } else {
    rewardMoney = false
    rewardShard = random.nextDouble() < (details?.shard.probability ?? kRewardProbabilityShard)
  }
  let rewardEquipment = random.nextDouble() <
          (details?.equipment.probability ?? kRewardProbabilityEquipment)
  let rewardCardpack = random.nextDouble() <
          (details?.cardpack.probability ?? kRewardProbabilityCardpack)
  let rewardPotion = random.nextDouble() <
          (details?.potion.probability ?? kRewardProbabilityPotion)
  let rewardCraftMaterial = random.nextDouble() <
          (details?.craftMaterial.probability ?? kRewardProbabilityCraftMaterial)
  let rewardDungeonTicket
  let rewardScrollPaper
  if (entity.rank > 0) {
    rewardScrollPaper = random.nextDouble() <
          (details?.scrollPaper.probability ?? kRewardProbabilityScrollPaper)
    rewardDungeonTicket = random.nextDouble() <
          (details?.dungeonTicket.probability ?? kRewardProbabilityDungeonTicket)
  }

  final rewards = []
  final refQuantity = expForLevel(entity.level ?? 0)
  if (rewardExp) {
    let amount = details?.exp.amount
    if (amount == null) {
      final rankRate = (entity.rank + 1) / (hero.rank + 1);
      amount = ((rankRate * expForLevel(hero.level)) /
              (Math.sqrt(hero.level + 1) * 4.5) + 40).round()
    }
    final expPack = createItemById('exp_pack', amount: amount)
    rewards.add(expPack)
  }
  if (rewardMoney) {
    let amount = details?.money.amount
    if (amount == null) {
      amount = random.nextInt(refQuantity * _kMoneyRewardRate) + 50
    }
    final moneyPack = Materialpack(kind: 'money', amount: amount)
    rewards.add(moneyPack)
  }
  if (rewardShard) {
    let amount = details?.shard.amount
    if (amount == null) {
      amount = random.nextInt((entity.level) + 1) + 1
    }
    final shardPack = Materialpack(kind: 'shard', amount: amount)
    rewards.add(shardPack)
  }
  if (rewardEquipment) {
    let amount = details?.equipment.amount ?? 1
    for (var i in range(amount)) {
      final equipment = Equipment(rank: entity.rank, isIdentified: entity.rank < 1)
      rewards.add(equipment)
    }
  }
  if (rewardCardpack) {
    let amount = details?.cardpack.amount ?? 1
    for (var i in range(amount)) {
      final cardpack = Cardpack(rank: entity.rank, genre: entity.cultivationFavor)
      rewards.add(cardpack)
    }
  }
  if (rewardPotion) {
    let amount = details?.potion.amount ?? 1
    for (var i in range(amount)) {
      final potion = Potion(rank: entity.rank)
      rewards.add(potion)
    }
  }
  if (rewardCraftMaterial) {
    let amount = details?.craftMaterial.amount ?? 1
    for (var i in range(amount)) {
      let craftMaterialTypeRoll = random.nextDouble()
      let craftMaterial
      final itemRank = random.nearInt(entity.rank) + 1
      if (craftMaterialTypeRoll < _kRewardProbabilityCraftMaterialUpgradeRank) {
        craftMaterial = createItemById('craftmaterial_upgrade', rank: itemRank)
      } else if (craftMaterialTypeRoll < _kRewardProbabilityCraftMaterialRerollAffix) {
        craftMaterial = createItemById('craftmaterial_rerollAffix', rank: itemRank)
      } else if (craftMaterialTypeRoll < _kRewardProbabilityCraftMaterialReplaceAffix) {
        craftMaterial = createItemById('craftmaterial_replaceAffix', rank: itemRank)
      } else {
        craftMaterial = createItemById('craftmaterial_addAffix', rank: itemRank)
      }
      rewards.add(craftMaterial)
    }
  }
  if (entity.rank > 0) {
    if (rewardScrollPaper) {
      let amount = details?.scrollPaper.amount ?? 1
      for (var i in range(amount)) {
        final scrollPaper = createItemById('scroll_paper', rank: entity.rank)
        rewards.add(scrollPaper)
      }
    }
    if (rewardDungeonTicket) {
      let amount = details?.dungeonTicket.amount ?? 1
      for (var i in range(amount)) {
        let ticketRank = entity.rank
        if (ticketRank < kCultivationRankMax) {
          if (random.nextDouble() <
            (details?.dungeonTicketNextLevel ?? _kRewardProbabilityDungeonTicketNextLevel)) {
            ticketRank += 1
          }
        }
        final dungeonTicket = createItemById('dungeon_ticket', rank: ticketRank)
        rewards.add(dungeonTicket)
      }
    }
  }

  if (rewards.isEmpty) {
    engine.warn('生成的战利品列表为空！')
  }
  return rewards
}

/// 进行打坐、探索、工作时，时间不能跨过一个月，因为每月底会刷新和结算
/// 取本月剩余的天数和英雄剩余的体力的最小值
/// 消耗体力为每天4点（每个tick 1点）。
function getHeroAvaialbeDays() {
  let maxAvailableDays = 29 - day
  if (maxAvailableDays < 1) {
    dialog.localeLines(['cannotInteractAtEndOfMonth'], isHero: true)
    return 0
  }

  const staminaAvailableDays = hero.life ~/ Constants.ticksPerDay
  if (staminaAvailableDays < 1) {
    dialog.localeLines(['notEnoughStaminaMonologue'], isHero: true)
    return 0
  }

  const availableDays = Math.min(maxAvailableDays, staminaAvailableDays)
}

async function selectHeroAttribute() {
  final selections = {};
  for (final key in Constants.battleAttributes) {
    final attrName = engine.locale(key)
    final attrDescription = engine.locale('${key}_description')
    selections[key] = {
      'text': attrName,
      'description':
          '${attrDescription}\n${engine.locale('current')}${attrName}: ${hero.stats[key]}',
    }
  }
  selections['cancel'] = engine.locale('cancel')

  dialog.pushSelectionRaw({
    id: 'selectedAttribute',
    selections: selections,
  })
  await dialog.execute()
  final selected = dialog.checkSelected('selectedAttribute')
  return selected
}

/// 这个函数时异步的
/// 但一般不要 await 这个函数，因为有可能卡在打开物品展示对话框的地方
/// 直到关闭对话框才会返回并继续执行
async function onInteractMapObject(object, terrain) {
  engine.info('正在和 Object [${object.id}] (${object.category}) 互动。')
  if (object.useCustomLogic) {
    engine.info('Object [${object.id}] 使用自定义交互逻辑')
    await onWorldEvent('onInteractMapObject', object, terrain)
    return
  }

  if (!object.isDiscovered) {
    discoverObject(object, terrain)
    dialog.pushDialog('firstDiscover', interpolations: [object.name])
    await dialog.execute()
  }
  switch (object.category) {
    kObjectCategoryPortal: {
      onInteractPortal(object)
    }
    kObjectCategoryWorldPortal: {
      onInteractWorldPortal(object)
    }
    kObjectCategoryTreasureBox: {
      onInteractTreasureBox(object, terrain)
    }
    kObjectCategorySwitch: {
      onInteractSwitch(object, terrain)
    }
    kObjectCategoryBed: {
      onInteractBed(object)
    }
    kObjectCategoryCharacter: {
      final character = game.characters[object.characterId]
      assert(character != null)
      onInteractCharacter(character)
    }
    kObjectCategoryEnemy: {
      assert(object.battleEntity != null)
      onInteractEnemy(object.battleEntity)
    }
    kObjectCategoryExpArray: {
      Game.showCultivation(location: object, enableCultivate: true)
    }
    kObjectCategoryCardLibrary: {
      Game.showLibrary(enableCardCraft: true, enableScrollCraft: true)
    }
    kObjectCategoryMerchant: {
      Game.showMerchant(
        object.merchant,
        materialMode: object.materialMode,
        useShard: object.useShard,
        priceFactor: object.priceFactor,
        filter: object.filter,
      )
    }
    kObjectCategorySpiritWell: {
      onInteractSpiritWell(object)
    }
    kObjectCategoryWorkbench: {
      Game.showWorkbench()
    }
    kObjectCategoryAlchemyFurnace: {
      Game.showAlchemy()
    }
    default: {
      engine.error('不支持的地图交互物品类型: ${object.category}')
    }
  }
}

async function onInteractEnemy(battleEntity) {
  Game.showBattle(
    hero: hero,
    enemy: battleEntity,
  )
}

async function onInteractPortal(object) {
  if (object.targetTilePosition == null || object.targetTilePosition.left == null || object.targetTilePosition.top == null) {
    engine.error('传送点 ${object.id} 的目标位置未定义！')
    return
  }
  World.moveCameraToTilePosition(object.targetTilePosition.left, object.targetTilePosition.top, animated: false)
  engine.play('magic-smite-6012.mp3')
  await Future.delayed(0.5)
  if (object.darkenBeforeMove) {
    World.darkenAllTiles()
  }
  Player.setTo(object.targetTilePosition.left, object.targetTilePosition.top)
}

async function onInteractWorldPortal(object) {
  assert(universe.containsKey(object.worldId), object.worldId)
  // dialog.pushBackground('black.png', fadeIn: true)
  engine.play('magic-smite-6012.mp3')
  Player.setTo(object.targetTilePosition.left, object.targetTilePosition.top, worldId: object.worldId, direction: 'south')
  await Future.delayed(0.5)
  Game.loadWorld(object.worldId)
  // await dialog.execute()
}

async function onInteractTreasureBox(object, terrain) {
  if (object.isOpened) return

  object.isOpened = true
  engine.play('dooropened-103851.mp3')
  terrain.overlaySprite ??= {}
  Object.assign(terrain.overlaySprite, {sprite: kSpriteTreasureBoxOpened})
  World.updateTerrainOverlaySprite(terrain.left, terrain.top)
  // await Future.delayed(0.5)
  final items = createLoot(object.items)
  for (final item in items) {
    await Player.acquire(item)
  }
  engine.play('pickup_item-64282.mp3')
  Game.promptItems(items)
}

async function onInteractSwitch(object, terrain) {
  if (object.isOn) {
    dialog.pushDialog('hint_switch_alreadyOn', isHero: true)
    dialog.execute()
    return
  }

  object.isOn = true
  engine.play('stone-push-37412.mp3')
  dialog.pushDialog('hint_switch', isHero: true)
  dialog.execute()
  terrain.overlaySprite = {sprite: kSpriteSwitchOn} 
  World.updateTerrainOverlaySprite(terrain.left, terrain.top)
  
  // final openedRoadTile = getTerrainByWorldPosition(targetTilePosition.left, targetTilePosition.top)
  // openedRoadTile.spriteIndex = kSpriteDungeonStonePavedTile
  // World.updateTerrainSprite(targetTilePosition.left, targetTilePosition.top)
}

async function onInteractBed(object) {
  if (hero.life >= hero.stats.lifeMax) {
    dialog.pushDialog('hint_fullHPRest')
    await dialog.execute()
    return
  }

  if (object.isUsed) {
    dialog.pushDialog('hint_usedObject')
    await dialog.execute()
  } else {
    object.isUsed = true
    dialog.pushBackground('black.png', isFadeIn: true)
    dialog.pushTask(async () {
      await Future.delayed(0.8)
    })
    dialog.popBackground(isFadeOut: true)

    let life = hero.life
    let newLife = life + (hero.stats.lifeMax * 0.5).round()
    if (newLife > hero.stats.lifeMax) {
      newLife = hero.stats.lifeMax
    }
    hero.life = newLife
    engine.info('休息恢复了 ${newLife - life} 生命值')
    Game.updateUI()

    await dialog.execute()
  }
}

async function onInteractSpiritWell(object) {
  if (object.isUsed) {
    dialog.pushDialog('hint_dungeon_spiritWell_description2')
    await dialog.execute()
    return
  }

  // let hasVacancy = false
  // for (final itemId in hero.equipments.keys) {
  //   if (hero.equipments[itemId] == null) {
  //     hasVacancy = true
  //     break
  //   }
  // }

  final items = []
  final spiritWellDropRoll = random.nextDouble()
  // if (hasVacancy && spiritWellDropRoll < kSpiritWellProbabilitySpirit) {
  //   final spirit = StatusSpirit(rank: object.rank)
  //   await Player.acquire(spirit)
  //   Player.equip(spirit)
  //   engine.play('spell-of-healing-876.mp3')
  //   dialog.pushDialog('hint_dungeon_spiritWell_use')
  //   await dialog.execute()
  //   items.add(spirit)
  // } else
  if (spiritWellDropRoll < _kSpiritWellProbabilityCraftMaterial) {
    for (var i in range(3)) {
      let craftMaterialTypeRoll = random.nextDouble()
      let craftMaterial
      final itemRank = random.nearInt(object.rank) + 1
      if (craftMaterialTypeRoll < _kRewardProbabilityCraftMaterialUpgradeRank) {
        craftMaterial = createItemById('craftmaterial_upgrade', rank: itemRank)
      } else if (craftMaterialTypeRoll < _kRewardProbabilityCraftMaterialRerollAffix) {
        craftMaterial = createItemById('craftmaterial_rerollAffix', rank: itemRank)
      } else if (craftMaterialTypeRoll < _kRewardProbabilityCraftMaterialReplaceAffix) {
        craftMaterial = createItemById('craftmaterial_replaceAffix', rank: itemRank)
      } else {
        craftMaterial = createItemById('craftmaterial_addAffix', rank: itemRank)
      }
      items.add(craftMaterial)
    }
  } else {
    final shard = random.nextInt(hero.level + 1) + 1
    final shardPack = Materialpack(kind: 'shard', amount: shard)
    items.add(shardPack)
  }

  Game.promptItems(items)
  
  object.isUsed = true
}

const _kMinSizeforStormTile = 80
const _kMinSizeforSpiritTile = 120

function setStormTile(terrain) {
  engine.info('风暴正在 [${terrain.left},${terrain.top}] 活跃。')
  terrain.flags.isInStorm = true
  terrain.overlaySprite ??= {}
  Object.assign(terrain.overlaySprite, {animation: {path: 'object/animation/stormZone.png'}})
  World.updateTerrainOverlaySprite(terrain.left, terrain.top)
  world.stormTileIndexes.add(terrain.index)
}

function setSpiritTile(terrain) {
  engine.info('灵气正在 [${terrain.left},${terrain.top}] 喷涌。')
  terrain.flags.isSpiritSurging = true
  terrain.overlaySprite ??= {}
  Object.assign(terrain.overlaySprite, {animation: {path: 'object/animation/spirit.png'}})
  World.updateTerrainOverlaySprite(terrain.left, terrain.top)
  game.spiritTileIndexes.add(terrain.index)
}

// 每个tick检查一次当前是否有婴儿出生
function handleBabies {
  const pendingRemovedIds = Set()
  for (const baby of game.babies) {
    final babyTime = game.timestamp - baby.conceptionTimestamp
    if (babyTime < baby.pregnancyTime) continue
    const mother = game.characters[baby.motherId]
    if (mother.isPregnant) {
      mother.isPregnant = false
      mother.carrying.add(baby.id)
    }
    if (babyTime > baby.pregnancyTime + kChildTime) {
      mother.carrying.remove(baby.id)
      assert(mother.homeLocationId != null)
      const location = game.locations[mother.homeLocationId]
      const character = Character(
        surName: baby.surName,
        generateName: baby.generateName,
        shorname: baby.shorname,
        isFemale: baby.isFemale,
        birthTimestamp: baby.conceptionTimestamp + baby.pregnancyTime,
        locationId: location.id,
        isNewBorn: true,
        motherId: baby.motherId,
        fatherId: baby.fatherId,
        relationships: baby.relationships,
        bonds: baby.bonds,
      )
      pendingRemovedIds.add(baby.id)
    }
  }
  for (const id in pendingRemovedIds) {
    delete game.babies[id]
  }
}

/// 动态计算角色声名：对此人的评价大于等于零的人数(n)除以世界总人口(p)。
function calculateFame(character) {
  let n = 0
  for (final otherChar of game.characters) {
    if (otherChar.id == character.id) {
      continue
    }
    let bond = otherChar.bonds[character.id]
    if (bond && bond.score >= 0) {
      n += 1
    }
  }
  character.fame = (n / game.characters.length * 100).truncate()
}

/// 动态计算角色恶名：对此人的评价小于零的人数(n)除以世界总人口(p)。
function calculateInfamy(character) {
  let n = 0
  for (final otherChar of game.characters) {
    if (otherChar.id == character.id) {
      continue
    }
    let bond = otherChar.bonds[character.id]
    if (bond && bond.score < 0) {
      n += 1
    }
  }
  character.infamy = (n / game.characters.length * 100).truncate()
}
