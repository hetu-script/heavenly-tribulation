import 'entity/character/character.ht'
import 'util.ht'
import 'game.ht'

/// 加载到本次游戏的对话资源
let gDialogs = {}

struct DialogContentData {
  constructor({
    character,
    characterId,
    displayNameId,
    displayName,
    icon,
    isHero: bool,
    hideName: bool,
    hideIcon: bool,
    localeKeys,
    lines,
    interpolations,
  }) {
    if (characterId || character) {
      assert(hero != null)
      character ??= game.characters[characterId]
      let heroHaveMetChar = false
      if (character != null) {
        heroHaveMetChar = haveMet(hero, character)
      }
      
      if (hideName) {
        this.displayName = '???'
      } else {
        if (displayNameId != null) {
          this.displayName = engine.locale(displayNameId)
        } else if (displayName != null) {
          this.displayName = displayName
        } else if (heroHaveMetChar) {
          if (character.titleId != null) {
            this.displayName = engine.locale(character.titleId)
          } else {
            this.displayName = character.name
          }
        }
      }
      
      this.icon = hideIcon ? null : (icon ?? character?.icon)
    }
    else if (isHero) {
      assert(hero != null)
      this.characterId = hero.id
      this.displayName = hideName ? '???' :
        (displayNameId ? engine.locale(displayNameId) :
        (displayName ?? engine.locale('me')))
      this.icon = hideIcon ? null : icon ?? hero.icon
    } else {
      this.displayName = displayNameId ? engine.locale(displayNameId) : displayName
      this.icon = icon
    }
    
    let strings
    if (localeKeys is List) {
      assert(localeKeys.isNotEmpty)
      strings = localeKeys.map( (key) => engine.locale(key, interpolations: interpolations) ).toList()
    } else if (localeKeys is string) {
      strings = [engine.locale(localeKeys, interpolations: interpolations)]
    } else if (lines is List) {
      assert(lines is List && lines.isNotEmpty)
      strings = lines.map( (line) => interpolate(line, interpolations) ).toList()
    } else {
      assert(lines is string)
      strings = [interpolate(line, interpolations)]
    }
    this.lines = []
    for (const message in strings) {
      const splits = message.split('\n')
      for (final split in splits) {
        final trim = split.trim()
        if (trim.isNotEmpty) {
          this.lines.add(trim)
        }
      }
    }
  }
}

namespace Dialog {

  // 对应 GameDialogContent 的接口，这种对话框会以模态的形式显示在游戏界面上

  

  // 对应 GameDialogState 的接口，不会阻断浮窗和装备栏等其他UI
  
  /// 执行对话，当执行结束时，所有场景、角色和对话数据都会被清理
  external async function execute()
  
  external function _pushDialog(data)

  external function pushImage(image: string, { offsetX: float = 0.0, offsetY: float = 0.0})

  external function popImage({image: string})

  external function pushBackground(image: string, {isFadeIn: bool = false})

  external function popBackground({isFadeOut: bool = false})

  external function pushTask(task: function, {flagId: string})

  function pushLocales(localeKeys, {
    character,
    characterId,
    displayNameId,
    displayName,
    icon,
    isHero: bool,
    hideName: bool,
    hideIcon: bool,
    interpolations,
    returnValue,
  }) -> Future {
    return _pushDialog(DialogContentData(
      localeKeys: localeKeys,
      character: character,
      characterId: characterId,
      displayNameId: displayNameId,
      displayName: displayName,
      icon: icon,
      isHero: isHero,
      hideName: hideName,
      hideIcon: hideIcon,
      interpolations: interpolations,
    ))
  }

  // function pushLines(lines, {
  //   isHero,
  //   character,
  //   characterId,
  //   displayNameId,
  //   displayName,
  //   icon,
  //   hideName,
  //   hideIcon,
  //   interpolations,
  //   returnValue,
  // }) -> Future {
  //   return _pushDialog(DialogContentData(
  //     lines: lines,
  //     isHero: isHero,
  //     character: character,
  //     characterId: characterId,
  //     displayNameId: displayNameId,
  //     displayName: displayName,
  //     icon: icon,
  //     hideName: hideName,
  //     hideIcon: hideIcon,
  //     interpolations: interpolations,
  //   ))
  // }

  /// selection 对话框的 data 数据结构：
  /// {
  ///   id: 'taskId',
  ///   selections: {
  ///     selectKey1: 'localedText1',
  ///     selectKey2: 'localedText3',
  ///     ...
  ///   } 
  /// }
  external function pushSelection(data)

  // 虽然返回值是future，但这个函数不能设为 async，否则会打乱Dialog的执行顺序
  function pushLocalesSelection(id, locales: List) {
    final selections = {}
    selections
    for (final key in locales) {
      selections[key] = engine.locale(key)
    }
    return pushSelection({ id: id, selections: selections })
  }

  external function checkSelected(data)

  external function _selectCharacter(context, title, ids, showCloseButton)

  external function _selectResidence(context, idList, { hideHero: bool })

  external function _merchant(context, merchant, priceFactor, allowSell, sellableCategory, sellableKind)

  external function _quests(context, site)

  external function _maze(context, maze)

  external function _progress(context, titletitle, checkProgress)

  external function _inputInteger(context, title, min, max)

  function selectCharacter({title, ids, showCloseButton = true}) -> Future {
    return _selectCharacter(ctx, title, ids, showCloseButton)
  }

  function selectResidence(idList) -> Future {
    return _selectResidence(ctx, idList)
  }

  function merchant(merchant, {
    priceFactor = 2.0,
    allowSell = true,
    sellableCategory = [],
    sellableKind = [],
  }) -> Future {
    return _merchant(
      buildContext,
      merchant,
      priceFactor,
      allowSell,
      sellableCategory,
      sellableKind,
    )
  }

  function quests(site) -> Future {
    return _quests(ctx, site)
  }

  // 显示一个进度窗口，以天为单位显示动画，每天会调用传入的 checkProgress 函数的返回值来判断是否继续下一天
  function progress(title, { checkProgress: function }) {
    return _progress(ctx, title, checkProgress)
  }

  function inputInteger(title, minOrMax, [max]) {
    let min = 1
    if (max == null) {
      max = minOrMax
    } else {
      min = minOrMax
    }
    assert(min <= max)
    return _inputInteger(ctx, title, min, max)
  }
}
