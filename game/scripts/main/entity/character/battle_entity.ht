/// battle entity 指一个可以参与战斗的对象。
/// 此对象拥有一个牌库和一个卡组。
/// 卡组是战斗中使用的。而牌库可以用来交换卡牌收藏（偷取、学习或者交换）。

import '../entity.ht'
import '../item/material.ht'

const _kAttributeSum = 50
const _kMajorAttributeFactor = 0.55

const kEquipmentMax = 7

const _kBaseStaminaCostForMoveOnWater = 12
const _kBaseStaminaCostForMoveOnHill = 12

const kBasicLife = 25
const kBasicStamina = 10
const kBasicManaMax = 1
const kBasicLightedArea = 3

const kCharacterAttributeNames = [
  'spirituality',
  'dexterity',
  'strength',
  'willpower',
  'perception',
]

// 某些时候，只需要生成一个用于战斗的实体，此时不需要年龄、魅力等属性
struct BattleEntity {
  construct ({
    attributes,
    attributeSum,
    majorAttributes: List = [],
    baseStats,
    // cultivationGenre,
    cardLibrary,
    battleDecks,
  }) {
    // 身上携带的材料，材料本身没有特殊属性，多个材料只是堆叠数字增加
    // 材料单独显示在物品栏上方，没有携带的材料不会显示
    // 金钱也是一种材料，其他材料包括可以用来建筑的木材、石料等
    this.materials = MaterialStorage()

    // 身上携带的普通物品，每一个都是单独生成，无法堆叠
    this.inventory = {}

    // 装备栏的位置是固定的 8 个
    // 装备栏只能装备法宝，获得其佩戴效果
    // 装备数据的 key 是 1-8 的数字，代表第几栏，
    // value 是 物品的 id
    this.equipments = {}

    // 随主角移动的其他角色
    this.companions = {}

    // 角色当前卡牌库，关于战斗卡牌的具体信息另行参阅文档
    // 卡牌库是一个 map，key 是卡牌的 id，value 是卡牌数据
    this.cardLibrary = cardLibrary ?? {}
    // 战斗卡组的数组，数组的值是一个结构体，包含卡组的命名（可修改）和卡组内容
    // [
    //   {
    //     title: 'deck name',
    //     isBattleDeck: false, // 是否是当前使用的战斗卡组
    //     cards: [
    //       'card id 1', // 卡组中只保存卡牌id，实际数据在角色的library中
    //       'card id 2',
    //     ]
    //   }
    // ]
    this.battleDecks = battleDecks ?? []
    // 当前使用的战斗卡组，记录的是战斗卡组数组的index
    this.battleDeckIndex = this.battleDecks.isNotEmpty ? 0 : null

    // 角色的属性
    // 包括：灵力、身法、体魄、念力、神识
    this.attributes = attributes ?? {}
    let generated = generateCharacterAttributes(
      attributesSum: attributeSum ?? _kAttributeSum,
      majorAttributes: majorAttributes,
    )
    Object.assign(this.attributes, generated)

    // 当前状态，包括增益和减益等等。
    this.statusEffects = {}

    // 天赋，天赋本身的数据另外保存，这里只保存了天赋的id和天赋等级
    this.talents = {}

    // 角色的数值
    // 包括经过物品、天赋和状态加成的基本属性值
    // 通过属性还会计算出：攻击、防御、体力、生命、灵气
    this.stats = {
      life: 0,
      stamina: 0,
      mana: 0,
    }

    calculateCharacterStats(this, baseStats: baseStats)
    rejuvenate(this)

    // 主流派：御剑、道术、锻体、炼魂、法身
    // 副流派：炼丹、炼器、阵法、符法、灵植、灵兽、幻术、卜术、通灵、通神
    // this.cultivationGenre = cultivationGenre
  }
}

function generateCharacterAttributes({
    attributesSum,
    minValue = 0,
    majorAttributes: List = [],
  }) {
  assert(attributesSum > 0)
  assert(minValue >= 0)

  const attributes = {}

  let maxV = attributesSum
  let residue = (attributesSum * _kMajorAttributeFactor).toInt()
  if (majorAttributes) {
    maxV = attributesSum - residue
  }
  
  let rest = maxV
  let attrList = random.shuffle(kCharacterAttributeNames).toList()
  for (var i = 0; i < attrList.length - 1; ++i) {
    const value = Random().nextInt(rest)
    attributes[attrList[i]] = value + minValue
    rest -= value
  }
  attributes[attrList.last] = rest

  if (majorAttributes) {
    let majorAttrList = random.shuffle(majorAttributes).toList()
    for (var i = 0; i < majorAttrList.length - 1; ++i) {
      const value = Random().nextInt(residue)
      attributes[majorAttrList[i]] += value
      residue -= value
    }
    attributes[majorAttrList.last] += residue
  }
  
  return attributes
}

/// 当前状态数值，由特性、属性、物品、天赋、技能、增益减损等计算得来
/// 状态包括：生命、伤害、防御等。
function calculateCharacterStats(character, { baseStats = {}, rejuvenate = false }) {
  
  // 基础属性，在此基础上还要加上物品和状态的加成
  // baseStas可能是从Dart传过来的map，所以这里用了特殊写法取属性
  let spirituality = baseStats['spirituality'] + character.attributes.spirituality
  let dexterity = baseStats['dexterity'] + character.attributes.dexterity
  let strength = baseStats['strength'] + character.attributes.strength
  let willpower = baseStats['willpower'] + character.attributes.willpower
  let perception = baseStats['perception'] + character.attributes.perception

  // for (const equipData of character.equipments) {
  //   const item = getEquipped(equipData, character)
  //   for (const effect of item.stats.effects) {
  //     if (effect.handlerType == kEffectCategoryCharacter) {
  //       switch (effect.id) {
  //         'addStamina' : {
  //           baseStamina += effect.values[0].value
  //         }
  //         'addLife' : {
  //           baseLife += effect.values[0].value
  //         }
  //         'addMana' : {
  //           baseMana += effect.values[0].value
  //         }
  //         'addSpirituality' : {
  //           baseSpirituality += effect.values[0].value
  //         }
  //         'addDexterity' : {
  //           baseDexterity += effect.values[0].value
  //         }
  //         'addStrength' : {
  //           baseStrength += effect.values[0].value
  //         }
  //         'addWillpower' : {
  //           baseWillpower += effect.values[0].value
  //         }
  //         'addPerception' : {
  //           basePerception += effect.values[0].value
  //         }
  //       }
  //     }
  //   }
  // }
  
  let stamina = (strength + dexterity) ~/ 4 + kBasicStamina
  let life = baseStats['life'] + strength ~/ 2 + kBasicLife
  let mana = baseStats['mana'] + spirituality ~/ 25 + kBasicManaMax
  let lightRadius = perception ~/ 25 + kBasicLightedArea

  character.stats.spirituality = spirituality
  character.stats.dexterity = dexterity
  character.stats.strength = strength
  character.stats.willpower = willpower
  character.stats.perception = perception

  character.stats.staminaMax = stamina
  character.stats.lifeMax = life
  character.stats.manaMax = mana

  character.stats.block = baseStats['block'] ?? 0
  
  character.stats.physicalDamage = baseStats['physicalDamage'] ?? 0
  character.stats.elementDamage = baseStats['elementDamage'] ?? 0
  character.stats.spellDamage = baseStats['spellDamage'] ?? 0
  character.stats.spiritDamage = baseStats['spiritDamage'] ?? 0

  character.stats.lightRadius ??= lightRadius
}

function rejuvenate(character) {
  character.stats.life = character.stats.lifeMax
  character.stats.stamina = character.stats.staminaMax
}

function getCharacterStats(character) {
  const stats = character.stats.clone()
  return stats
}

function getCharacterMovableTerrainKinds(character) {
  let kinds = ['plain', 'forest']
  let movableOnWater = getCharacterMoveCostOnWater(character)
  if (movableOnWater) kinds.addAll(['sea', 'lake'])
  let movableOnHill = getCharacterMoveCostOnHill(character)
  if (movableOnHill) kinds.addAll(['mountain'])
  return kinds
}

/// 获取角色水上移动体力消耗，如果返回null表示不可水上移动
/// 消耗以tick为单位，在角色进入该地块之后扣减相应数值
function getCharacterMoveCostOnWater(character) {
  // TODO: 结丹境可以直接飞行，因此无需船只
  for (let i = 1; i < kEquipmentMax; ++i) {
    let itemId = character.equipments[i]
    let item = character.inventory[itemId]
    if (item != null && item.equipType == kEquipTypeShip) {
      return _kBaseStaminaCostForMoveOnWater
    }
  }
  return null
}

/// 获取角色山地移动体力消耗，如果返回null表示不可山上移动
/// 消耗以tick为单位，在角色进入该地块之后扣减相应数值
function getCharacterMoveCostOnHill(character) {
  for (let i = 1; i < kEquipmentMax; ++i) {
    let itemId = character.equipments[i]
    let item = character.inventory[itemId]
    if (item != null && item.equipType == kEquipTypeBoots) {
      return _kBaseStaminaCostForMoveOnHill
    }
  }
  return null
}
