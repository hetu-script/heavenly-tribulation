/// battle entity 指一个可以参与战斗的对象。
/// 此对象拥有一个牌库和一个卡组。
/// 卡组是战斗中使用的。而牌库可以用来交换卡牌收藏（偷取、学习或者交换）。

import '../entity.ht'
import '../item/material.ht'

const _kAttributesBase = 50

const _kEquipmentMax = 7

const kBaseStaminaCostForMoveOnWater = 12
const kBaseStaminaCostForMoveOnHill = 12

const kBaseLife = 75
const kBaseStamina = 10
const kBaseMana = 1
const kBaseLightedArea = 3

const kAttributeNames = [
  'spirituality',
  'dexterity',
  'strength',
  'willpower',
  'perception',
]

// 某些时候，只需要生成一个用于战斗的实体，此时不需要年龄、魅力等属性
struct BattleEntity {
  construct ({
    attributes,
    attributeSum,
    baseAttribute,
    majorAttribute,
    baseStats,
    // cultivationGenre,
    cardLibrary,
    battleDecks,
  }) {
    // 身上携带的材料，材料本身没有特殊属性，多个材料只是堆叠数字增加
    // 材料单独显示在物品栏上方，没有携带的材料不会显示
    // 金钱也是一种材料，其他材料包括可以用来建筑的木材、石料等
    this.materials = MaterialStorage()

    // 身上携带的普通物品，每一个都是单独生成，无法堆叠
    this.inventory = {}

    // 装备栏的位置是固定的 8 个
    // 装备栏只能装备法宝，获得其佩戴效果
    // 装备数据的 key 是 1-8 的数字，代表第几栏，
    // value 是 物品的 id
    this.equipments = {}

    // 随主角移动的其他角色
    this.companions = {}

    // 角色当前卡牌库，关于战斗卡牌的具体信息另行参阅文档
    // 卡牌库是一个 map，key 是卡牌的 id，value 是卡牌数据
    this.cardLibrary = cardLibrary ?? {}
    // 战斗卡组的数组，数组的值是一个结构体，包含卡组的命名（可修改）和卡组内容
    // [
    //   {
    //     title: 'deck name',
    //     isBattleDeck: false, // 是否是当前使用的战斗卡组
    //     cards: [
    //       'card id 1', // 卡组中只保存卡牌id，实际数据在角色的library中
    //       'card id 2',
    //     ]
    //   }
    // ]
    this.battleDecks = battleDecks ?? []
    // 当前使用的战斗卡组，记录的是战斗卡组数组的index
    this.battleDeckIndex = this.battleDecks.isNotEmpty ? 0 : -1

    // 角色的属性
    // 包括：灵力、身法、体魄、念力、神识
    this.attributes = attributes ?? {}
    let generated = generateCharacterAttributes(base: baseAttribute, major: majorAttribute)
    Object.assign(this.attributes, generated)

    // 当前状态，包括增益和减益等等。
    this.statusEffects = {}

    // 天赋，天赋本身的数据另外保存，这里只保存了天赋的id和天赋等级
    this.talents = {}

    // 角色的数值
    // 包括经过物品、天赋和状态加成的基本属性值
    // 通过属性还会计算出：攻击、防御、体力、生命、灵气
    this.stats = {
      life: 0,
      stamina: 0,
      mana: 0,
    }

    calculateCharacterStats(this, baseStats: baseStats)
    rejuvenate(this)

    // 主流派：御剑、道术、锻体、炼魂、法身
    // 副流派：炼丹、炼器、阵法、符法、灵植、灵兽、幻术、卜术、通灵、通神
    // this.cultivationGenre = cultivationGenre
  }
}

// function generateCharacterAttributes({
//     sum,
//     base,
//     major,
//     // majorAttributes: List = [],
//   }) {
//   if (sum != null) {
//     assert(sum > 0)
//   } else {
//     sum = _kAttributesSum + random.distantInt(_kAttributesSumExtra - _kAttributesSum)
//   }
//   if (base != null) {
//     assert(base >= 0 && base * kAttributeNames.length <= sum)
//   } else {
//     base = _kAttributesBase + random.distantInt(_kAttributesBaseExtra - _kAttributesBase)
//   }
//   if (major != null) {
//     assert(kAttributeNames.contains(major))
//   }

//   sum = sum - base * kAttributeNames.length

//   const attributes = {}

//   let reserved = (sum * _kMajorAttributeFactor).toInt()
//   let rest = major ? sum - reserved : sum
  
//   let attrList = random.shuffle(kAttributeNames).toList()
//   for (var i = 0; i < attrList.length - 1; ++i) {
//     let value = 0
//     if (rest > 0) {
//       value = random.nextInt(rest)
//       rest -= value
//     }
//     attributes[attrList[i]] = base + value
//   }
//   attributes[attrList.last] = rest

//   if (major) {
//     attributes[major] +=reserved

    // let majorAttrList = random.shuffle(major).toList()
    // for (var i = 0; i < majorAttrList.length - 1; ++i) {
    //   const value = random.nextInt(reserved)
    //   attributes[majorAttrList[i]] += value
    //   reserved -= value
    // }
    // attributes[majorAttrList.last] += reserved
//   }
  
//   return attributes
// }

function generateCharacterAttributes({base, major}) {
  base ??= _kAttributesBase
  let attributes = {}
  for (var i = 0; i < kAttributeNames.length; ++i) {
    final attrName = kAttributeNames[i]
    if (attrName == major) {
      attributes[attrName] = random.nearInt(base)
    } else {
      attributes[attrName] = random.distantInt(base)
    }
  }
  return attributes
}

/// 当前状态数值，由特性、属性、物品、天赋、技能、增益减损等计算得来
/// 状态包括：生命、伤害、防御等。
function calculateCharacterStats(character, { baseStats = {}, rejuvenate = false }) {
  
  // 基础属性，在此基础上还要加上物品和状态的加成
  // baseStas可能是从Dart传过来的map，所以这里用了特殊写法取属性
  let spirituality = baseStats['spirituality'] + character.attributes.spirituality
  let dexterity = baseStats['dexterity'] + character.attributes.dexterity
  let strength = baseStats['strength'] + character.attributes.strength
  let willpower = baseStats['willpower'] + character.attributes.willpower
  let perception = baseStats['perception'] + character.attributes.perception

  // for (const equipData of character.equipments) {
  //   const item = getEquipped(equipData, character)
  //   for (const effect of item.stats.effects) {
  //     if (effect.handlerType == kEffectCategoryCharacter) {
  //       switch (effect.id) {
  //         'addStamina' : {
  //           baseStamina += effect.values[0].value
  //         }
  //         'addLife' : {
  //           baseLife += effect.values[0].value
  //         }
  //         'addMana' : {
  //           baseMana += effect.values[0].value
  //         }
  //         'addSpirituality' : {
  //           baseSpirituality += effect.values[0].value
  //         }
  //         'addDexterity' : {
  //           baseDexterity += effect.values[0].value
  //         }
  //         'addStrength' : {
  //           baseStrength += effect.values[0].value
  //         }
  //         'addWillpower' : {
  //           baseWillpower += effect.values[0].value
  //         }
  //         'addPerception' : {
  //           basePerception += effect.values[0].value
  //         }
  //       }
  //     }
  //   }
  // }
  
  let stamina = (strength + dexterity) ~/ 4 + kBaseStamina
  let life = baseStats['life'] + strength ~/ 2 + kBaseLife
  // let mana = baseStats['mana'] + spirituality ~/ 25 + kBaseMana
  let lightRadius = perception ~/ 25 + kBaseLightedArea

  character.stats.spirituality = spirituality
  character.stats.dexterity = dexterity
  character.stats.strength = strength
  character.stats.willpower = willpower
  character.stats.perception = perception

  character.stats.staminaMax = stamina
  character.stats.lifeMax = life
  // character.stats.manaMax = mana
  
  character.stats.unarmedAttack = baseStats['unarmedAttack'] ?? 0
  character.stats.weaponAttack = baseStats['weaponAttack'] ?? 0
  character.stats.spellAttack = baseStats['spellAttack'] ?? 0
  character.stats.curseAttack = baseStats['curseAttack'] ?? 0
  character.stats.poisonAttack = baseStats['poisonAttack'] ?? 0
  
  character.stats.physicalDefense = baseStats['physicalDefense'] ?? 0
  character.stats.chiDefense = baseStats['chiDefense'] ?? 0
  character.stats.elementalDefense = baseStats['elementalDefense'] ?? 0
  character.stats.psychicDefense = baseStats['psychicDefense'] ?? 0

  character.stats.quickThreshold = baseStats['quickThreshold'] ?? 10
  character.stats.slowThreshold = baseStats['slowThreshold'] ?? 10
  character.stats.nimbleThreshold = baseStats['nimbleThreshold'] ?? 10
  character.stats.clumnsyThreshold = baseStats['clumnsyThreshold'] ?? 10

  character.stats.lightRadius ??= lightRadius
}

function rejuvenate(character) {
  character.stats.life = character.stats.lifeMax
  character.stats.stamina = character.stats.staminaMax
}

function getCharacterStats(character) {
  const stats = character.stats.clone()
  return stats
}

function getCharacterMovableTerrainKinds(character) {
  let kinds = ['plain', 'forest']
  let movableOnWater = getCharacterMoveCostOnWater(character)
  if (movableOnWater) kinds.addAll(['sea', 'lake'])
  let movableOnHill = getCharacterMoveCostOnHill(character)
  if (movableOnHill) kinds.addAll(['mountain'])
  return kinds
}

/// 获取角色水上移动体力消耗，如果返回null表示不可水上移动
/// 消耗以tick为单位，在角色进入该地块之后扣减相应数值
function getCharacterMoveCostOnWater(character) {
  // TODO: 结丹境可以直接飞行，因此无需船只
  for (let i = 1; i < _kEquipmentMax; ++i) {
    let itemId = character.equipments[i]
    let item = character.inventory[itemId]
    if (item != null && item.equipType == kEquipTypeShip) {
      return kBaseStaminaCostForMoveOnWater
    }
  }
  return null
}

/// 获取角色山地移动体力消耗，如果返回null表示不可山上移动
/// 消耗以tick为单位，在角色进入该地块之后扣减相应数值
function getCharacterMoveCostOnHill(character) {
  for (let i = 1; i < _kEquipmentMax; ++i) {
    let itemId = character.equipments[i]
    let item = character.inventory[itemId]
    if (item != null && item.equipType == kEquipTypeBoots) {
      return kBaseStaminaCostForMoveOnHill
    }
  }
  return null
}
