import '../tile/tilemap.ht'
import '../tile/hexagonal_tile.ht'
import '../game.ht'
import '../tile/common.ht'

/// 以一个种子地块出发，逐渐生长出一块大陆的算法
function generateContinent1({width, height, landProportion, landZone}) {
  // 当前地域的边缘格子坐标
  const shelf = Set()

  // 刷新当前地域的边缘格子坐标
  function updateShelf(left, top) {
    shelf.remove(tilePos2Index(left, top, width))
    const neighbors = getMapTileNeighbors(left, top, currentWorld)
    for (const tile in neighbors) {
      if (tile.spriteIndex == kSpriteWater) {
        shelf.add(tile.index)
      }
    }
  }

  const landArea = (width * height * landProportion).floor()

  const minLeft = width ~/ 3
  const minTop = height ~/ 3
  const maxLeft = width ~/ 3 * 2
  const maxTop = height ~/ 3 * 2

  const startLeft = random.nextInt(maxLeft - minLeft) + minLeft
  const startTop = random.nextInt(maxTop - minTop) + minTop
  // engine.info('start: ${startLeft},${startTop}')
  const startIndex = tilePos2Index(startLeft, startTop, width)
  const firstTile = currentWorld.terrains[startIndex]
  firstTile.spriteIndex = kSpriteLand
  addTerrainToZone(firstTile, landZone.index, currentWorld)
  updateShelf(startLeft, startTop)

  let currentLandSize = 1
  while (currentLandSize < landArea) {
    // engine.info('expanding land')
    ++currentLandSize
    const tile = currentWorld.terrains[random.nextIterable(shelf)]
    updateShelf(tile.left, tile.top)
    tile.spriteIndex = kSpriteLand
    addTerrainToZone(tile, landZone.index, currentWorld)
  }

  // 根据相邻的格子的地域，分配地域索引
  function updateZone(tile, [spriteIndex, unzonedNeighbors]) {
    assert(tile.zoneIndex == null)
    let willCreateZone = true
    if (spriteIndex != null) {
      willCreateZone = false
    } else {
      spriteIndex = tile.spriteIndex
    }
    unzonedNeighbors ??= {}
    // engine.info('processing: ${tile.left},${tile.top}, spriteIndex: ${tile.spriteIndex}')
    tile.zoneIndex = -1 // mark this tile is being processed, will skip it when process others
    const neighbors = getMapTileNeighbors(tile.left, tile.top, currentWorld)
    let foundAdjacentZone = false
    for (const neighbor in neighbors) {
      // skip tiles that has diffrent spriteIndex and those still being processed
      if (neighbor.spriteIndex != spriteIndex) continue
      if (neighbor.zoneIndex == null) {
        updateZone(neighbor, spriteIndex, unzonedNeighbors)
      }
      if (neighbor.zoneIndex == -1) {
        unzonedNeighbors[neighbor.index] = neighbor
        continue
      }
      addTerrainToZone(tile, neighbor.zoneIndex, currentWorld)
      foundAdjacentZone = true
      // engine.info('Found neighbor: ${neighbor.left},${neighbor.top}, zoneIndex: ${neighbor.zoneIndex}')
      break
    }
    if (!foundAdjacentZone && willCreateZone) {
      let category = tile.spriteIndex == kSpriteLand ? kZoneLand : kZoneWater
      const zone = Zone(index: currentWorld.zones.length, category: category)
      currentWorld.zones.add(zone)
      // engine.info('Created zone! left: ${tile.left}, top: ${tile.top} spriteIndex: ${tile.spriteIndex}, zoneIndex: ${zone.index}')
      addTerrainToZone(tile, zone.index, currentWorld)
      // engine.info('processing previoused stored unzoned tiles: ${unzonedNeighbors}')
      for (const unzonedTile of unzonedNeighbors) {
        if (unzonedTile.zoneIndex == -1) {
          addTerrainToZone(unzonedTile, zone.index, currentWorld)
        }
      }
    }
  }

  let unzonedTile
  engine.info('开始生成地域')
  while (
    unzonedTile = currentWorld.terrains.firstWhere((tile) => tile.zoneIndex == null)
  ) {
    // engine.info('updating unzoned tile')
    updateZone(unzonedTile)
  }
  
  // 将大陆和海洋接触的地方填充为大陆架
  engine.info('将大陆和海洋接触的地方填充为大陆架')
  for (const index in shelf) {
    const tile = currentWorld.terrains[index]
    tile.spriteIndex = kSpriteShelf
  }
}

const kMapStyles = Set(
  'islands',
  'coast',
  'inland',
)

/// 利用 noise 函数生成大陆和海洋的算法
function generateContinent({seed, size, style}) {
  let noiseData
  let threshold
  assert(style in kMapStyles)
  switch (style) {
    'islands' => {
      threshold = 0.55
      noiseData = Math.noise2d(
        size,
        seed: seed,
        noiseType: 'perlinFractal',
        frequency: 6 / size,
      )
    }
    'coast' => {
      threshold = 0.48
      noiseData = Math.noise2d(
        size,
        seed: seed,
        noiseType: 'cubicFractal',
        frequency: 3.5 / size,
      )
    }
    'inland' => {
      threshold = 0.35
      noiseData = Math.noise2d(
        size,
        seed: seed,
        noiseType: 'cubicFractal',
        frequency: 6 / size,
      )
    }
  }
  for (const x in range(size)) {
    for (const y in range(size)) {
      const index = tilePos2Index(x + 1, y + 1, size)
      const noise = noiseData[x][y]
      const normalize = (noise + 1) / 2;
      if (normalize > threshold) {
        const tile = currentWorld.terrains[index]
        tile.spriteIndex = kSpriteLand
      }
    }
  }
}
