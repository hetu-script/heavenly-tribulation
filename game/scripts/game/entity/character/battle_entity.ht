/// battle entity 指一个可以参与战斗的对象。
/// 此对象拥有一个牌库和一个卡组。
/// 卡组是战斗中使用的。而牌库可以用来交换卡牌收藏（偷取、学习或者交换）。

import '../common.ht'
import '../material.ht'
// import 'status_effect/world_map_status_effect.ht'

const _kAttributeSum = 50
const _kMajorAttributeFactor = 0.5

const kCharacterAttributeNames = [
  'spirituality',
  'dexterity',
  'strength',
  'willpower',
  'perception',
]

const kBasicLife = 25
const kBasicStamina = 10
const kBasicManaMax = 1
const kBasicLightedArea = 1

function getMajorAttributes(character) {
  let attr = character.attributes
  assert(attr != null)
  let major = attr.spirituality
  let majorName = 'spirituality'

  if (attr.dexterity > major) {
    major = attr.dexterity
    majorName = 'dexterity'
  }
  if (attr.strength > major) {
    major = attr.strength
    majorName = 'strength'
  }
  if (attr.willpower > major) {
    major = attr.willpower
    majorName = 'willpower'
  }
  if (attr.perception > major) {
    majorName = 'perception'
  }

  return majorName
}

// 某些时候，只需要生成一个用于战斗的实体，此时不需要年龄、魅力等属性
struct BattleEntity {
  construct ({
    attributes,
    attributeSum,
    majorAttributes: List = [],
    baseStats,
  }) {
    // 身上携带的材料，材料本身没有特殊属性，多个材料只是堆叠数字增加
    // 材料单独显示在物品栏上方，没有携带的材料不会显示
    // 金钱也是一种材料，其他材料包括可以用来建筑的木材、石料等
    this.materials = MaterialStorage()

    // 身上携带的普通物品，每一个都是单独生成，无法堆叠
    this.inventory = {}

    // 装备栏的位置是固定的 8 个
    // 装备栏只能装备法宝，获得其佩戴效果
    // 装备数据的 key 是 1-8 的数字，代表第几栏，
    // value 是一个 equipData 对象
    this.equipments = {}

    // 随主角移动的其他角色
    this.companions = {}

    // 战斗卡组的位置是固定的，根据境界有 4-8 张
    // TODO: 可以准备多个卡组随时切换
    // key 是 1-8 的数字，代表第几栏
    this.battleDeck = {}

    // 角色卡牌库，每张牌只有一张，取等级最高者保存，重复获得时会进入备用牌库
    this.cardLibrary = {}
    // 备用牌库
    this.reservedCardLibrary = []

    // 修为点数，其实就是经验值，可以换算为天赋点数
    this.cultivationPoints = 0

    // 角色的属性
    // 包括：灵力、身法、体魄、念力、神识
    this.attributes = attributes ?? {}
    let generated = generateCharacterAttributes(
      attributesSum: attributeSum ?? _kAttributeSum,
      majorAttributes: majorAttributes,
    )
    Object.assign(this.attributes, generated)

    // 当前状态，包括增益和减益等等。
    this.statusEffects = {}

    // 天赋，天赋本身的数据另外保存，这里只保存了天赋的id和天赋等级
    this.talents = {}

    // 角色的数值
    // 包括经过物品、天赋和状态加成的基本属性值
    // 通过属性还会计算出：攻击、防御、体力、生命、灵气
    this.stats = {}

    calculateCharacterStats(this, baseStats)
    rejuvenate(this)
  }
}

function generateCharacterAttributes({
    attributesSum,
    minValue = 0,
    majorAttributes: List = [],
  }) {
  assert(attributesSum > 0)
  assert(minValue >= 0)

  const attributes = {}

  let maxV = attributesSum
  let residue = (attributesSum * _kMajorAttributeFactor).toInt()
  if (majorAttributes) {
    maxV = attributesSum - residue
  }
  
  let rest = maxV
  let attrList = random.shuffle(kCharacterAttributeNames).toList()
  for (var i = 0; i < attrList.length - 1; ++i) {
    const value = Random().nextInt(rest)
    attributes[attrList[i]] = value + minValue
    rest -= value
  }
  attributes[attrList.last] = rest

  if (majorAttributes) {
    let majorAttrList = random.shuffle(majorAttributes).toList()
    for (var i = 0; i < majorAttrList.length - 1; ++i) {
      const value = Random().nextInt(residue)
      attributes[majorAttrList[i]] += value
      residue -= value
    }
    attributes[majorAttrList.last] += residue
  }
  
  return attributes
}

/// 当前状态数值，由特性、属性、物品、天赋、技能、增益减损等计算得来
/// 状态包括：生命、伤害、防御等。
function calculateCharacterStats(character, [ baseStats ]) {
  
  // 基础属性，在此基础上还要加上物品和状态的加成
  // baseStas可能是从Dart传过来的map，所以这里用了特殊写法取属性
  let spirituality = baseStats?['spirituality'] + character.attributes.spirituality
  let dexterity = baseStats?['dexterity'] + character.attributes.dexterity
  let strength = baseStats?['strength'] + character.attributes.strength
  let willpower = baseStats?['willpower'] + character.attributes.willpower
  let perception = baseStats?['perception'] + character.attributes.perception

  // for (const equipData of character.equipments) {
  //   const item = getEquipped(equipData, character)
  //   for (const effect of item.stats.effects) {
  //     if (effect.handlerType == kEffectCategoryCharacter) {
  //       switch (effect.id) {
  //         'addStamina' : {
  //           baseStamina += effect.values[0].value
  //         }
  //         'addLife' : {
  //           baseLife += effect.values[0].value
  //         }
  //         'addMana' : {
  //           baseMana += effect.values[0].value
  //         }
  //         'addSpirituality' : {
  //           baseSpirituality += effect.values[0].value
  //         }
  //         'addDexterity' : {
  //           baseDexterity += effect.values[0].value
  //         }
  //         'addStrength' : {
  //           baseStrength += effect.values[0].value
  //         }
  //         'addWillpower' : {
  //           baseWillpower += effect.values[0].value
  //         }
  //         'addPerception' : {
  //           basePerception += effect.values[0].value
  //         }
  //       }
  //     }
  //   }
  // }
  
  let stamina = (strength + dexterity) ~/ 4 + kBasicStamina
  let life = baseStats?['life'] + strength ~/ 2 + kBasicLife
  let mana = baseStats?['mana'] + spirituality ~/ 25 + kBasicManaMax
  let lightedArea = perception ~/ 25 + kBasicLightedArea

  character.stats.spirituality = spirituality
  character.stats.dexterity = dexterity
  character.stats.strength = strength
  character.stats.willpower = willpower
  character.stats.perception = perception

  character.stats.stamina = character.stats.staminaMax = stamina
  character.stats.life = character.stats.lifeMax = life
  character.stats.mana = 0
  character.stats.manaMax = mana

  character.stats.armor = 0
  character.stats.weaponAttack = 0

  character.stats.lightedArea = lightedArea
}

function getCharacterStats(character) {
  const stats = character.stats.clone()
  // stats.equipments = {}
  // for (const i in range(1, kEquipmentMax)) {
  //   const equipData = character.equipments[i]
  //   if (equipData != null) {
  //     const equipment = getEquipped(equipData, character)
  //     stats.equipments[i] = equipment.stats.clone()
  //   }
  // }
  return stats
}

// 战斗，异步函数，如果获胜则返回 true
// function heroBattle (
//   char2, {
//   resolveResult = true,
//   loot = true,
//   takeAll = true,
//   isMazeIncident = false,
//   char1Resurrect = true,
//   char2Resurrect = false,
//   onWon,
//   onLost,
// }) -> Future async {
  // const char1 = getHero()
  // return showDuel(char1, char2).then((result) {
  //   if (result?.result) {
  //     if (resolveResult) resolveDuelResult(char1, char2, result)
  //     if (loot) lootCharacter(char1, char2, takeAll: takeAll)
  //     const incidentContent = engine.locale('duelVistory', interpolations: [ char1.name, char2.name ] )
  //     Incident(
  //       content: incidentContent,
  //       subjectIds: [char1.id],
  //       isPrivate: true,
  //       isMazeIncident: isMazeIncident,
  //     )
  //     if (char2Resurrect) {
  //       if (char2.isMajorCharacter) {
  //         const injury = WorldMapStatusEffect.injury()
  //         char2.statusEffects[injury.kind] = injury
  //         char2.stats.life = 1
  //       }
  //     } else {
  //       const incidentContent = engine.locale('characterKill', interpolations: [ char1.name, char2.name ] )
  //       Incident(
  //         content: incidentContent,
  //         subjectIds: [char1.id],
  //         isPrivate: true,
  //         isMazeIncident: isMazeIncident,
  //       )
  //       if (char2.isMajorCharacter) {
  //         char2.isDead = true
  //       } else {
  //         delete game.minorCharacters[char2.id]
  //       }
  //     }
  //     if (onWon is function) {
  //       onWon()
  //     }
  //     return true
  //   } else {
  //     if (char1Resurrect) {
  //       const injury = WorldMapStatusEffect.injury()
  //       char1.statusEffects[injury.kind] = injury
  //       char1.stats.life = 1
  //     }
  //     if (onLost is function) {
  //       onLost()
  //     }
  //     return false
  //   }
  // })
// }
