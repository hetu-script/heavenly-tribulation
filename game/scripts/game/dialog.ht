import 'entity/character/common.ht'
import 'util.ht'
import 'binding/dialog.ht'

/// 加载到本次游戏的对话资源
let gDialogs = {}

struct DialogData {
  construct({
    this.id,
    this.contents,
  }) {}
}

struct DialogContentData {
  construct({
    isHero,
    characterId,
    displayNameLocaleKey,
    displayName,
    isMajorCharacter,
    icon,
    localeKeys,
    interpolations,
    lines,
  }) {
    // 在游戏刚启动时，载入对话框数据，此时尚未设定玩家角色信息
    // 因此 hero 有可能是 null
    if (isHero && hero != null) {
      this.characterId = hero.id
      this.displayName = hero.name
      this.isMajorCharacter = true
      this.icon = hero.icon
    } else if (characterId) {
      const character = game.characters[characterId]
      assert(character != null)
      this.displayName = character.name
      this.isMajorCharacter = character.isMajorCharacter
      this.icon = character.icon
    } else {
      if (displayNameLocaleKey) {
        this.displayName = engine.locale(displayNameLocaleKey)
      } else {
        this.displayName = displayName
      }
      this.isMajorCharacter = isMajorCharacter
      this.icon = icon
    }
    
    let strings
    if (localeKeys is List) {
      assert(localeKeys.isNotEmpty)
      strings = localeKeys.map( (key) => engine.locale(key, interpolations: interpolations) ).toList()
    } else {
      assert(lines is List && lines.isNotEmpty)
      strings = lines
    }
    this.lines = []
    for (const message in strings) {
      const splits = message.split('\n')
      this.lines.addAll(splits)
    }
  }

  construct fromData(data) : this(
    isHero: data.isHero,
    characterId: data.characterId,
    displayNameLocaleKey: data.displayNameLocaleKey,
    displayName: data.displayName,
    isMajorCharacter: data.isMajorCharacter,
    icon: data.icon,
    localeKeys: data.localeKeys,
    lines: data.lines,
  ) {}
}

// 将预定义的对话数据转化为实际上的对话数据，例如本地化Key会被替换为文本等
function addDialogs(dlgsData: List) {
  engine.info('载入预定义对话树数据')
  for (const dlgData in dlgsData) {
    const dlg = DialogData(
      id: dlgData.id,
      contents: [],
    )
    for (const contentData in dlgData.contents) {
      const dlgContent = DialogContentData.fromData(contentData)
      dlg.contents.add(dlgContent)
    }
    gDialogs[dlg.id] = dlg
  }
}

function showDialogByLocaleKeys(localeKeys, { returnValue, character, displayName, interpolations: List }) -> Future {
  assert(localeKeys is List)
  const dlgData = {
    contents: [
      DialogContentData(
        characterId: character?.isMajorCharacter ? character.id : null,
        displayName: displayName ?? character?.name,
        icon: character?.icon,
        localeKeys: localeKeys,
        interpolations: interpolations,
      ),
    ]
  }
  return Dialog.showGameDialog(buildContext, dlgData, returnValue)
}

function showDialogByStrings(lines, { returnValue, character, displayName }) -> Future {
  assert(lines is List)
  const dlgData = {
    contents:[
      DialogContentData(
        characterId: character?.isMajorCharacter ? character.id : null,
        displayName: displayName ?? character?.name,
        icon: character?.icon,
        lines: lines,
      ),
    ]
  }
  return Dialog.showGameDialog(buildContext, dlgData, returnValue)
}

function showDialogByResourceId(id: string, { returnValue, interpolations: List }) -> Future {
  const data = gDialogs[id]
  // 这里之后是否可以优化一下？
  for (const content in data.contents) {
    if (content.isHero) {
      content.displayName = hero.name
      content.isMajorCharacter = true
      content.icon = hero.icon
      delete content.isHero
    }
    if (interpolations is List) {
      for (const i = 0; i < content.lines.length; ++i) {
        content.lines[i] = interpolate(content.lines[i], interpolations)
      }
    }
  }
  return Dialog.showGameDialog(buildContext, data, returnValue)
}

function showDialog(data, { returnValue }) -> Future {
  return Dialog.showGameDialog(buildContext, data, returnValue)
}

function showSelectionByLocaleKeys(texts: List) -> Future {
  const selections = {}
  for (const text in texts) {
    selections[text] = engine.locale(text)
  }
  return Dialog.showSelection(buildContext, selections)
}

function showSelection(selections) -> Future {
  return Dialog.showSelection(buildContext, selections)
}

function showCharacterSelection({title, ids, showCloseButton = true}) -> Future {
  return Dialog.showCharacterSelection(buildContext, title, ids, showCloseButton)
}

function showVisitCharacterSelection(idList) -> Future {
  return Dialog.showVisitCharacterSelection(buildContext, idList)
}

function showSkillSelection({title, skills, showCloseButton = true}) {
  return Dialog.showSkillSelection(buildContext, title, skills, showCloseButton)
}

function showMerchant(merchant, {
  priceFactor = 2.0,
  allowSell = true,
  sellableCategory = [],
  sellableKind = [],
}) -> Future {
  return Dialog.showMerchant(
    buildContext,
    merchant,
    priceFactor,
    allowSell,
    sellableCategory,
    sellableKind,
  )
}

function showQuests(site) -> Future {
  return Dialog.showQuests(buildContext, site)
}

function showMaze(maze) -> Future {
  return Dialog.showMaze(buildContext, maze)
}

// 显示一个进度窗口，以天为单位显示动画，每天会调用传入的 checkProgress 函数的返回值来判断是否继续下一天
function showProgress(title, { checkProgress: function }) {
  return Dialog.showProgress(buildContext, title, checkProgress)
}

function showIntInput(title, minOrMax, [max]) {
  let min = 1
  if (max == null) {
    max = minOrMax
  } else {
    min = minOrMax
  }
  assert(min <= max)
  return Dialog.showIntInput(buildContext, title, min, max)
}
