import '../random.ht'
import '../name/skill.ht'
import '../common.ht'

struct BattleCard {
  construct ({
    genre, // 'general', 'daoism', 'swordcraft'
    category, // 'attack', 'buff'
    kind, // 'sword',
    level,
    rank = 0, // 境界决定了额外词条数量
  }) {
    if (level == null) {
      if (rank > 0) {
        level = random.nextInt(rank * kLevelPerRank) + 1
      } else {
        level = 0
      }
    } else {
      assert(rank != null)
      assert(level >= 0 && level <= (rank * kLevelPerRank))
    }

    this.id = crypto.randomNID(length: 6, withTime: true)
    this.rank = rank

    // 注意：主词条数据的genre是字符串，但额外词条的genre是字符串数组
    final mainAffixes = game.battleCardMainAffixes.values.where( (affix) {
      if (genre != null && affix['genre'] != genre) {
        return false
      }
      if (category != null && affix['category'] != category) {
        return false
      }
      if (kind != null && affix['kind'] != kind) {
        return false
      }
      return true
    })
    assert(mainAffixes.isNotEmpty)
    const mainAffix = JSON.deepcopy(random.nextIterable(mainAffixes))
    this.level = mainAffix.level = level
    this.name = generateSkillName(category: mainAffix.kind).name

    final affixUniqueIds = []
    if (mainAffix.affixId is List) {
      affixUniqueIds.addAll(mainAffix.affixId)
    } else if (mainAffix.affixId is string) {
      affixUniqueIds.add(mainAffix.affixId)
    }

    let minExtraAffixCount = rank > 0 ? (rank - 1) : 0
    let minGreaterAffixCount = 0
    let maxGreaterAffixCount = 0
    if (rank >= 5) {
      minExtraAffixCount = 4
      minGreaterAffixCount = rank - 5
      maxGreaterAffixCount = rank - 4
    }

    final supportAffixes = game.battleCardSupportAffixes.values.where( (affix) {
      if (!affix['genre'].contains(mainAffix.genre)) {
        return false
      }
      if (!affix['category'].contains(mainAffix.category)) {
        return false
      }
      if (affixUniqueIds.contains(affix.affixId)) {
        return false
      }
      return true
    })
    assert(supportAffixes.isNotEmpty)

    if (rank < 5 && rank > 0) {
      let r = random.nextDouble()
      if (r >= 0.15) {
        ++minExtraAffixCount
      }
    }
    final extraAffixes = []
    for (var i = 0; i < minExtraAffixCount; ++i) {
      let existed = false
      let supportAffix
      do {
        supportAffix = JSON.deepcopy(random.nextIterable(supportAffixes))
        for (final existedAffix in extraAffixes) {
          if (extraAffixes.id == supportAffix.id) {
            existed = true
            break
          }
        }
      } while (existed)
      extraAffixes.add(supportAffix)
    }

    this.affixes = [mainAffix, ...extraAffixes]
  }
}
