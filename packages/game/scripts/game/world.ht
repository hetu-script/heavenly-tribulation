import 'generator/name/name.ht' as nameGenerator
import 'game.ht'
import 'entity/location.ht'
import 'entity/character/character.ht'
import 'entity/nation.ht'
import 'l10n.ht'
import 'tile/hexagonal_tile.ht'
import 'tile/tilemap.ht'
import 'entity/item/weapon.ht'
import 'entity/constants.ht'
import { hyperbola } from 'util.ht'
import 'datetime.ht' as datetime
import 'logic.ht'

/// 生成世界地图的算法
///
/// spritesheet上不同地形对应的编号：
/// 0：虚空
/// 1：浅海
/// 2：深海
/// 3：陆地（草原）
///
/// 算法思路：
///
/// 用海面填满整个地图空间
///
/// 找到一个出发点，通常在地图中间部分
///
/// 找到出发点周围的方块，将其加入一个数组，作为当前陆地的边界
///
/// 将当前方块变成陆地，检查陆地比例，如果不够，就从当前陆地边界中随机挑选一个方块，将其变成陆地，同时重新计算边界。
///
/// 循环上述步骤，直到陆地和海水的比例达到预设值
///
/// 为陆地所属的整个大地块命名，然后找到尚未命名的地块，将所有相连的地块作为一个整体命名，直到所有的地块都有名字，根据地块大小有不同命名方式
///
/// 根据城市密度，生成城市，并根据城市位于陆地、海边还是海中，对其进行特殊命名
///
/// 对于每个城市，链接最近的另外两个城市，使用 A* 寻路算法，标记经过的地块
///
/// 对于没有道路经过的地块，随机填充山脉和树林

const _kDefaultWorldScale = 1
final _kWorldSizePerWorldScale = {
  '1': {width: 12, height: 12},
  '2': {width: 18, height: 18},
  '3': {width: 27, height: 27},
  '4': {width: 40, height: 40},
}
const _kDefaultNationNumber = 4
const _kDefaultLocationNumber = 6
const _kDefaultOrganizationNumber = 4
const _kDefaultCharacterNumber = 20

const _kMinZoneSizeForSea = 8
const _kForestThreshold = 0.5
const _kMountainThreshold = 0.2

const _kCharacterMarriageAgeMin = 15
const _kCharacterMarriageAgeMax = 40
const _kPregnancyAgeMax = 40

fun createWorldMap({
    style = 'island',
    terrainSpriteSheet: str,
    worldScale = _kDefaultWorldScale,
    nationNumber = _kDefaultNationNumber,
    locationNumber = _kDefaultLocationNumber,
    organizationNumber = _kDefaultOrganizationNumber,
    characterNumber = _kDefaultCharacterNumber,
    landProportion = 0.55,
  }) {
  assert(organizationNumber < locationNumber)
  assert(organizationNumber < characterNumber)
  
  engine.info('开始生成世界')
  
  game.savePath = null
  game.nations = {}
  game.characters = {}
  game.locations = {}
  game.organizations = {}
  game.mazes = {}
  
  history = []

  final { width, height } = _kWorldSizePerWorldScale[worldScale.toString()]

  // 生成过程中，引入了一些别的文件中的函数
  // 他们可能会通过game.world访问, 因此这里直接使用全局变量
  game.world = TileMap(
    scene: 'worldmap',
    width: width,
    height: height,
  )

  game.world.isNewGame = true

  engine.info('生成地块')
  for (var j in range(height)) {
    for (var i in range(width)) {
      game.world.terrains.add(
        {
          ...Tile(i + 1, j + 1),
          index: tilePos2Index(i + 1, j + 1, width),
          spriteIndex: kSpriteWater,
          overlaySprite: {},
          showGrid: true,
          isSelectable: true,
        }
      )
    }
  }

  // 没有区域，也是一个区域
  final voidZone = Zone(index: game.world.zones.length, name: null, category: kZoneVoid)
  game.world.zones.add(voidZone)

  // 当前地域的边缘格子坐标
  final shelf = Set()

  // 刷新当前地域的边缘格子坐标
  fun updateShelf(left, top) {
    shelf.remove(tilePos2Index(left, top, width))
    final neighbors = getMapTileNeighbors(left, top, game.world)
    for (final tile in neighbors) {
      if (tile.spriteIndex == kSpriteWater) {
        shelf.add(tile.index)
      }
    }
  }

  // 生成地域
  engine.info('准备生成地域')
  final landArea = (width * height * landProportion).floor()

  final minLeft = width ~/ 3
  final minTop = height ~/ 3
  final maxLeft = width ~/ 3 * 2
  final maxTop = height ~/ 3 * 2

  final startLeft = Math.randomInt(maxLeft - minLeft) + minLeft
  final startTop = Math.randomInt(maxTop - minTop) + minTop
  // engine.info('start: ${startLeft},${startTop}')
  final startIndex = tilePos2Index(startLeft, startTop, width)
  final firstTile = game.world.terrains[startIndex]
  firstTile.spriteIndex = kSpriteLand
  final landZone = Zone(index: game.world.zones.length, category: kZoneContinent)
  game.world.zones.add(landZone)
  addTerrainToZone(firstTile, landZone.index, game.world)
  updateShelf(startLeft, startTop)

  var currentLandSize = 1
  while (currentLandSize < landArea) {
    // engine.info('expanding land')
    ++currentLandSize
    final tile = game.world.terrains[shelf.random]
    updateShelf(tile.left, tile.top)
    tile.spriteIndex = kSpriteLand
    addTerrainToZone(tile, landZone.index, game.world)
  }

  // 根据相邻的格子的地域，分配地域索引
  fun updateZone(tile, [spriteIndex, unzonedNeighbors]) {
    assert(tile.zoneIndex == null)
    var willCreateZone = true
    if (spriteIndex != null) {
      willCreateZone = false
    } else {
      spriteIndex = tile.spriteIndex
    }
    unzonedNeighbors ??= {}
    // engine.info('processing: ${tile.left},${tile.top}, spriteIndex: ${tile.spriteIndex}')
    tile.zoneIndex = -1 // mark this tile is being processed, will skip it when process others
    final neighbors = getMapTileNeighbors(tile.left, tile.top, game.world)
    var foundAdjacentZone = false
    for (final neighbor in neighbors) {
      // skip tiles that has diffrent spriteIndex and those still being processed
      if (neighbor.spriteIndex != spriteIndex) continue
      if (neighbor.zoneIndex == null) {
        updateZone(neighbor, spriteIndex, unzonedNeighbors)
      }
      if (neighbor.zoneIndex == -1) {
        unzonedNeighbors[neighbor.index] = neighbor
        continue
      }
      addTerrainToZone(tile, neighbor.zoneIndex, game.world)
      foundAdjacentZone = true
      // engine.info('Found neighbor: ${neighbor.left},${neighbor.top}, zoneIndex: ${neighbor.zoneIndex}')
      break
    }
    if (!foundAdjacentZone && willCreateZone) {
      var category = tile.spriteIndex == kSpriteLand ? kZoneContinent : kZoneWater
      final zone = Zone(index: game.world.zones.length, category: category)
      game.world.zones.add(zone)
      // engine.info('Created zone! left: ${tile.left}, top: ${tile.top} spriteIndex: ${tile.spriteIndex}, zoneIndex: ${zone.index}')
      addTerrainToZone(tile, zone.index, game.world)
      // engine.info('processing previoused stored unzoned tiles: ${unzonedNeighbors}')
      for (final unzonedTile of unzonedNeighbors) {
        if (unzonedTile.zoneIndex == -1) {
          addTerrainToZone(unzonedTile, zone.index, game.world)
        }
      }
    }
  }

  var unzonedTile
  engine.info('开始生成地域')
  while (
    unzonedTile = game.world.terrains.firstWhere((tile) => tile.zoneIndex == null)
  ) {
    // engine.info('updating unzoned tile')
    updateZone(unzonedTile)
  }

  fun find2NearestLocation(origin, {restricted2Zone: bool = true}) {
    assert(game.locations.length > 0)
    var nearest
    var nearestDistance
    var secondNearest
    var secondNearestDistance
    for (final location of game.locations) {
      if (location.index == origin.index) {
        continue
      } else {
        final start = game.world.terrains[origin.terrainIndex]
        final end = game.world.terrains[location.terrainIndex]
        final distance = getTileDistance(start, end)
        if (!restricted2Zone || location.zoneIndex == origin.zoneIndex) {
          if (nearestDistance == null || distance < nearestDistance) {
            nearestDistance = distance
            nearest = location
          } else if (secondNearestDistance == null || distance < secondNearestDistance) {
            secondNearestDistance = distance
            secondNearest = location
          } else {
            continue
          }
        }
      }
    }
    return { nearest, secondNearest }
  }

  final islands = []
  // 根据 tile 的所在位置的类型，添加属性
  engine.info('根据 tile 的所在位置的类型，添加属性')
  fun checkPerimeterOfLocation(tile) {
    if (tile.spriteIndex == kSpriteLand) return
    final neighbors = getMapTileNeighbors(tile.left, tile.top, game.world)
    for (final neighbor in neighbors) {
      if (neighbor.spriteIndex == kSpriteLand) {
        tile.isHarbor = true
        tile.harborOfZoneIndex = tile.zoneIndex
        addTerrainToZone(tile, neighbor.zoneIndex, game.world)
        return
      }
    }
    islands.add(tile)
  }

  // 生成据点
  engine.info('生成据点')
  final locationIndexes = Set()
  while (game.locations.length < locationNumber) {
    var index
    do {
      // engine.info('generating location index')
      index = Math.randomInt(game.world.terrains.length)
    } while (locationIndexes.contains(index))
    final tile = game.world.terrains[index]
    // location category只有两种：城市和秘境
    final location = Location(terrainIndex: index, category: kLocationCategoryCity)
    locationIndexes.add(index)
    checkPerimeterOfLocation(tile)
    tile.locationId = location.id
    tile.overlaySprite.index = kSpriteCity
  }

  // 每个岛屿是独立的 zone
  engine.info('处理岛屿')
  for (final island in islands) {
    final islandZone = Zone(index: game.world.zones.length, category: kZoneIsland)
    game.world.zones.add(islandZone)
    addTerrainToZone(island, islandZone.index, game.world)
  }

  // 因为 zone 的命名和其大小有关，因此在最后单独处理
  engine.info('为地域命名')
  for (final zone in game.world.zones) {
    if (zone.name) {
      continue
    }
    late category
    if (zone.category == kZoneWater) {
      category = zone.terrainIndexes.length < _kMinZoneSizeForSea ? kZoneLake : kZoneWater
    } else {
      category = zone.category
    }
    final r = nameGenerator.getZone(1, category: category)
    zone.name = r.first.name
  }
  
  // 将大陆和海洋接触的地方填充为大陆架
  engine.info('将大陆和海洋接触的地方填充为大陆架')
  for (final index in shelf) {
    final tile = game.world.terrains[index]
    tile.spriteIndex = kSpriteShelf
  }

  engine.info('确保陆地上的每个城市至少可以链接到另外两个城市')
  for (final location of game.locations) {
    final start = game.world.terrains[location.terrainIndex]
    // 确保陆地上的每个城市至少可以链接到另外两个城市
    if (start.zoneCategory == kZoneContinent) {
      final searchResult = find2NearestLocation(location, restricted2Zone: true)
      if (searchResult.nearest) {
        final end = game.world.terrains[searchResult.nearest.terrainIndex]
        final route = calculateRoute(start, end, game.world)
        if (route) {
          // routes.add(route)
          for (final index in route) {
            final terrain = game.world.terrains[index]
            terrain.isRoute = true
          }
        }
      }
      if (searchResult.secondNearest) {
        final end = game.world.terrains[searchResult.secondNearest.terrainIndex]
        final route = calculateRoute(start, end, game.world)
        if (route) {
          // routes.add(route)
          for (final index in route) {
            final terrain = game.world.terrains[index]
            terrain.isRoute = true
          }
        }
      }
    }
  }

  // 将大陆上没有道路的方格，随机填充为平原、森林、山地
  engine.info('将大陆上没有道路的方格，随机填充为平原、森林、山地')
  for (final index in landZone.terrainIndexes) {
    final terrain = game.world.terrains[index]
    if (!terrain.isRoute) {
      final r = Math.random()
      if (r < _kMountainThreshold) {
        terrain.spriteIndex = kSpriteMountain
      } else if (r < _kForestThreshold) {
        terrain.spriteIndex = kSpriteForest
      }
    }
  }

  // 随机挑选几个城市，作为各个国家的都城，生成地图上的不同国家
  engine.info('随机挑选几个城市，作为各个国家的都城，生成地图上的不同国家')
  while (game.nations.length < nationNumber) {
    var location
    do {
      location = game.locations.values.random
    } while (location.nationId != null)
    // engine.info('picking location for new nation capital: ${location}')
    final nation = Nation(capitalId: location.id)
    Site(category: kSitePalace, location: location)
    final terrain = game.world.terrains[location.terrainIndex]
    addTerrainToNation(nation, terrain)
  }

  // 根据相邻的格子的 nationId 进行分配
  fun expandNation(nation) {
    // engine.info('processing nation: ${nation}')
    assert(nation.borderIndexes != null && nation.borderIndexes.length > 0)
    var expanded = false
    // avoid editing iterable while iterating
    final currentBorder = nation.borderIndexes.toList()
    for (final index in currentBorder) {
      final terrain = game.world.terrains[index]
      if (terrain.nationId == null && terrain.zoneCategory == kZoneContinent) {
        addTerrainToNation(nation, terrain)
        expanded = true
      }
    }
    return expanded
  }

  // 随机选择各个国家的都城，然后各自扩散都城直到没有没有分配国家的区块
  engine.info('生成每个国家的疆域')
  var unoccupiedTile
  while (
    unoccupiedTile = game.world.terrains.firstWhere(
      (tile) => 
        tile.nationId == null &&
        tile.zoneCategory == kZoneContinent
    )
  ) {
    final nation = game.nations.values.random
    expandNation(nation)
    // engine.info('expanded nation ${nation.name}')
  }

  // 将地域的上色信息复制到引擎侧
  engine.info('刷新上色信息')
  updateWorldMapZoneColors()
  updateWorldMapNationColors()
  // final leaders = []
  // final headquarters = []

  // 随机生成每个组织的创建时间，分布在20年的范围内，时间固定为某月1号
  var organizationCreatedDate = []
  for (final i in range(organizationNumber)) {
    organizationCreatedDate.add(Math.randomInt(20 * kMonthsPerYear) * kTicksPerMonth)
  }
  organizationCreatedDate.sort()
  organizationCreatedDate = organizationCreatedDate.reversed.toList()

  // 模拟世界演化，按照时间推进并生成人物、组织，并且为期分配人物关系
  // 在此种演化算法中，人物不会死亡，组织不会被消灭，因此只判断人数是否达到要求
  engine.info('生成人物，快速模拟一段时间的演化')
  do {
    if (game.organizations.length < organizationNumber) {
      if (game.timestamp >= organizationCreatedDate.last) {
        // 组织数量不够，在来到下一个组织创建时间时，创建组织
        organizationCreatedDate.removeLast()
        var leader
        // 组织总舵不允许和其他组织的总舵在同一个据点
        var headquarters
        do {
          headquarters = game.locations.values.random
        } while (headquarters.isHeadquarters)
        if (game.characters.length == 0) {
          // 人物列表是空的，此时要创造第一个角色
          leader = Character(
            locationId: headquarters.id,
            birthTimestamp: createRandomBirthTimestamp(20) // 年龄至少是20岁
          )
        } else {
          final characterIdList = game.characters.keys.toList()
          characterIdList.shuffle()
          var found = false
          for (final id in characterIdList) {
            final character = game.characters[id]
            final age = datetime.toYear(game.timestamp - character.birthTimestamp)
            // 年龄至少是20岁，并且不能已经是其他组织的掌门
            if (character.organizationRank == 0 && age >= 20) {
              found = true
              leader = character
              break
            }
          }
          if (!found) {
            // 没有找到合适的人，则立刻创建一个
            leader = Character(
              locationId: headquarters.id,
              birthTimestamp: createRandomBirthTimestamp(20), // 年龄至少是20岁
            )
          }
        }
        setCharacterLocationId(leader, headquarters.id)
        
        // 创建组织
        Organization(
          nationId: headquarters.nationId,
          headquartersId: headquarters.id,
          leaderId: leader.id,
        )
      }
    }

    if (game.timestamp % kTicksPerMonth == 0) {
      // 每月月初执行的代码

      // 婴儿出生
      handleBabies()
      
      // 产生新的在野角色
      if (game.characters.length < characterNumber) {
        final location = game.locations.values.random
        final character = Character(
          locationId: location.id,
          birthTimestamp: createRandomBirthTimestamp(15, 50),
        )
      }
      
      // 为组织招募新的角色
      final organizationIdList = game.organizations.keys.toList()
      organizationIdList.shuffle()
      for (final id in organizationIdList) {
        final organization = game.organizations[id]
        final location = game.locations[organization.headquartersId]
        if (location.residingWildCharacterIds.isNotEmpty) {
          final characterId = location.residingWildCharacterIds.random
          final character = game.characters[characterId]
          assert(character.organizationId == null)
          addCharacterToOrganization(character, organization)
        }
      }
      
      // 为角色添加家庭关系
      final characterIdList = game.characters.keys.toList()
      characterIdList.shuffle()
      for (final id in characterIdList) {
        final char = game.characters[id]
        final age = getCharacterAge(char)
        if (char.relationships.spouseId) {
          if (char.isFemale && !char.isPregnant && age < _kPregnancyAgeMax) {
            if (char.thinkings.contains('dink')) continue
            if (char.thinkings.contains('clumsy')) continue
            if (char.relationships.childrenIds.isNotEmpty) {
              if (char.personality.social < 10) continue
              if (char.personality.prudence > 10) continue
              if (char.personality.frugal > 10) continue
              if (char.relationships.childrenIds.length > 2) {
                continue
              }
            }
            final spouse = game.characters[char.relationships.spouseId]
            if (spouse.thinkings.contains('dink')) continue
            if (spouse.thinkings.contains('clumsy')) continue
            Baby(
              father: spouse,
              mother: char,
              conceptionTimestamp: game.timestamp,
            )
          }
        } else {
          if (age > _kCharacterMarriageAgeMin && age < _kCharacterMarriageAgeMax) {
            for (final otherId in characterIdList) {
              if (id == otherId) continue
              final otherChar = game.characters[otherId]
              // TODO: 这里暂时没有允许同性婚姻
              if (otherChar.isFemale == char.isFemale) continue
              final otherCharAge = getCharacterAge(otherChar)
              if (otherCharAge > _kCharacterMarriageAgeMin
                  && otherCharAge < _kCharacterMarriageAgeMax
                  && otherChar.relationships.spouseId == null) {
                char.relationships.spouseId = otherId
                otherChar.relationships.spouseId = id
                var home
                if (char.organizationRank > otherChar.organizationRank) {
                  home = game.locations[char.homeId]
                } else if (char.organizationRank < otherChar.organizationRank) {
                  home = game.locations[otherChar.homeId]
                } else {
                  if (otherChar.isFemale) {
                    home = game.locations[char.homeId]
                  } else {
                    home = game.locations[otherChar.homeId]
                  }
                }
                characterFirstMet(char, otherChar)
                final incidentContent = getLocaleString('incidentMarriage', [
                    char.name,
                    otherChar.name,
                    home.name,
                  ])
                Incident(
                  content: incidentContent,
                  subjectIds: [char.id, otherChar.id],
                  locationId: home.id,
                  order: 20,
                )
                char.marriageTimestamp = game.timestamp
                otherChar.marriageTimestamp = game.timestamp
                break
              }
            }
          }
        }
      }
    }

    // 因为是模拟运行，时间直接以月为单位流逝
    game.timestamp += kTicksPerMonth
  } while (game.characters.length < characterNumber || game.organizations.length < organizationNumber)

  // 为生成的世界填充一些必要信息

  // 为角色添加次要动机
  final characterIdList = game.characters.keys.toList()
  characterIdList.shuffle()
  for (final id in characterIdList) {
    final char = game.characters[id]
    if (char.organizationId == null) {
      char.motivations.add('recruitment')
    }
    if (char.relationships.spouseId == null) {
      final age = getCharacterAge(char)
      if (age > _kCharacterMarriageAgeMin && age < _kCharacterMarriageAgeMax) {
        char.motivations.add('marriage')
      }
    } else {
      if (char.relationships.childrenIds.isEmpty) {
        char.motivations.add('child')
      }
    }
  }

  // 填充据点月常任务
  engine.info('填充据点月常任务')
  for (final location of game.locations) {

    location.quests.add()
  }

  engine.info('世界生成完毕。')

  return game.world
}

fun loadWorldMap(jsonData) {
  engine.info('载入世界地图数据')
  final data = prototype.fromJson(jsonData)
  game.world = data
}

fun getWorld() {
  return game.world
}

fun getZoneByIndex(index: int) {
  return game.world.zones[index]
}

/// 刷新地图地域上色信息
fun updateWorldMapZoneColors {
  final zoneColors = Map()
  for (final zone in game.world.zones) {
    zoneColors[zone.index] = zone.color
  }
  engine.updateZoneColors(zoneColors)
}
  
/// 刷新地图疆域上色信息
fun updateWorldMapNationColors {
  final nationColors = Map()
  for (final nation of game.nations) {
    nationColors[nation.id] = nation.color
  }
  engine.updateNationColors(nationColors)
}