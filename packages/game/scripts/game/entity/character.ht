import '../game.ht'
import '../l10n.ht'
import '../datetime.ht'
import 'incident.ht'
import '../generator/name/name.ht' as nameGenerator
import '../util.ht'
import 'constants.ht'
import '../duel.ht'

// number of the male avatar images
const kMaleAvatarCount = 37
 // number of the female avatar images
const kFemaleAvatarCount = 75
const kCharacterInitialMinAge = 10
const kCharacterInitialMaxAge = 25

const kCharacterAverageLooks = 75.0
/// 容貌最大值: 100.0
const kCharacterMaxLooks = 100.0
const kCharacterImpressionCheckpoint = 10.0

const kOrganizationLeaderTitle = 'organizationLeaderTitle'

// 羁绊, 人物对其他的某个事物的印象和评价
struct Bond {
  var id
  var name
  var score

  construct ({
    id,
    name,
    score = 0
  }) {
    this.id = id
    this.name = name
    this.score = score
    this.incidentScores = {}
    this.haveMet = false
  }
}

struct Character {
  construct ({
    familyName,
    shortName,
    isFemale: bool,
    birthTimestamp,
    birthPlaceId,
    nationId,
  }) {
    assert(birthPlaceId != null)
    assert(nationId != null)

    this.index = game.characters.length
    if (isFemale != null) {
      this.isFemale = isFemale
    } else {
      this.isFemale = Math.randomInt(2) == 0
    }
    if (isFemale) {
      final index = Math.randomInt(kFemaleAvatarCount)
      this.avatar = 'avatar/male/${index}.jpg';
    } else {
      final index = Math.randomInt(kMaleAvatarCount)
      this.avatar = 'avatar/male/${index}.jpg';
    }
    if (familyName != null && shorname != null) {
      this.familyName = familyName
      this.shortName = shortName
    } else {
      final r = nameGenerator.getCharacter(1, isFemale: this.isFemale).first
      this.familyName = familyName ?? r.familyName
      this.shortName = shortName ?? r.shortName
    }
    this.name = this.familyName + this.shortName
    this.id = 'character_${this.index}_${this.name}'
    // age 的格式是 timestamp, 精确到 tick. 
    if (birthTimestamp != null) {
      this.birthTimestamp = birthTimestamp
    } else {
      this.birthTimestamp = _createRandomBirthTimestamp()
    }
    this.looks = hyperbola(kCharacterAverageLooks)
    this.favoredLooks = hyperbola(kCharacterMaxLooks)

    this.birthPlaceId = birthPlaceId
    this.nationId = nationId

    // 该角色的称号
    this.titles = {}
    this.currentTitleId = null
 
    // 名声，指有多少人知道此人的名字
    this.fame = 0

    // // 恶名，知道名字中，对此人差评的人的数量
    // this.infamy = 0

    this.skills = {
      inventory: [],
      equipments: {},
    }

    this.items = {
      inventory: [],
      equipments: {},
    }

    // 属性点数数值
    this.attributes = generateRandomAttributes(Math.randomInt(10) + 10, 10)

    // 当前状态数值，由种族、天赋、属性点数、增益减损、物品、技能等计算得来
    this.stats = {}

    recalculateAttributesOfCharacter(this)

    // 该角色对世界上的其他事物的关系
    this.bonds = {
      characters: {},
      organizations: {},
      talismans: {},
      locations: {},
      nations: {},
    }

    // 该角色的人格纬度
    this.personality = {
      // 三观，最小 -50 最大 +50
      ideal: Math.random() * 100.0 - 50.0,
      order: Math.random() * 100.0 - 50.0,
      good: Math.random() *100.0 - 50.0,

      // 行为逻辑，最小 -50 最大 +50
      social: Math.random() * 100.0 - 50.0,
      intuition: Math.random() * 100.0 - 50.0,
      reason: Math.random() * 100.0 - 50.0,
      controlment: Math.random() * 100.0 - 50.0,
    }

    this.heardOfIncidentIndexes = Set()
    this.experiencedIncidentIndexes = Set()

    game.characters[this.id] = this
  }
}

fun getCharAgeString(character) {
  return toAgeString(game.timestamp - character.birthTimestamp)
}

fun _createRandomBirthTimestamp() {
  final age = Math.randomInt(kCharacterInitialMaxAge - kCharacterInitialMinAge) + kCharacterInitialMinAge
  final randomDateInAYear = Math.randomInt(kTicksPerYear)
  return game.timestamp - (age * kTicksPerYear + randomDateInAYear)
}

/// 容貌评价的计算公式
/// 每个角色自身有一个容貌值，这个数值代表大众眼中的评价
/// 每个角色都会有一个对特定容貌值的偏好
/// 本公式会利用这两个数值，计算某个角色对另一个角色的容貌的评价
/// looks 是对方的容貌，0 <= looks <= 100
/// favor 是该角色的偏好，0 <= favor <= 100
fun _calculateLooksScore({looks: float, favor: float}) -> float {
  assert(0.0 <= looks && looks <= kCharacterMaxLooks)
  if (favor != null) {
    assert(0.0 <= favor && favor <= kCharacterMaxLooks)
  }
  if (looks < ((favor + kCharacterMaxLooks) / 2)) {
    return (-(looks - favor) * (looks - favor)) / 20 + kCharacterMaxLooks
  } else {
    return (-(looks - kCharacterMaxLooks) * (looks - kCharacterMaxLooks)) / 20 + kCharacterMaxLooks
  }
}

fun generateRandomAttributes(maxStats, minValue) {
  assert(maxStats != null)
  assert(minValue != null)

  final strength = Math.randomInt(maxStats)
  final intelligence = Math.randomInt(maxStats - strength)
  final perception = Math.randomInt(maxStats - strength - intelligence)
  final superpower = Math.randomInt(maxStats - strength - intelligence - perception)
  final leadership = Math.randomInt(maxStats - strength - intelligence - perception - superpower)
  final management = maxStats - strength - intelligence - perception - superpower - leadership

  return {
    strength: strength + minValue,
    intelligence: intelligence + minValue,
    perception: perception + minValue,
    superpower: superpower + minValue,
    leadership: leadership + minValue,
    management: management + minValue,

    resists: {
      slashing: 0,
      bludgeoning: 0,
      piercing: 0,
      cold: 0,
      fire: 0,
      lightning: 0,
      chi: 0,
      spell: 0,
      power: 0,
    }
  }
}

fun recalculateAttributesOfCharacter(character) {
  character.stats.maxLife = character.stats.life = 100 + character.attributes.strength ~/ 5 * 10
  character.stats.maxStamina = character.stats.stamina = 100 + character.attributes.strength ~/ 10 * 5
}

// 第一印象分
fun _firstImpressionOfOtherCharacter(subject, target) {
  var bond
  var hasBond = false
  if (subject.bonds.characters[target.id] != null) {
    hasBond = true
    bond = subject.bonds.characters[target.id]
    if (bond.haveMet) {
      throw 'called first impression on characters already met, subject: ${subject.id}, target: ${target.id}'
    }
  } else {
    bond = Bond(id: target.id, name: target.name)
  }
  var score = 0
  score += _calculateLooksScore(looks: target.looks, favor: subject.favoredLooks) / 10
  if (target.organizationId != null) {
    // TODO: 敌对门派要减分
    score += target.organizationId == subject.organizationId ? 10 : 0
  }
  // TODO: 敌对国家要减分
  // TODO: 这两个挪到聊天互动之后再计算
  // bond.scoreOfSameNation = target.nationId == subject.nationId ? 5 : 0
  // bond.scoreOfSameBirthPlace = target.birthPlaceId == subject.birthPlaceId ? 10 : 0
  score += target.familyName == subject.familyName ? 10: 0
  // TODO: 同名之谊?

  var incidentContent
  if (bond.score < -kCharacterImpressionCheckpoint) {
    incidentContent = getLocaleString('characterFirstImpressionHateEvent', [
      subject.name,
      target.name,
    ])
  } else if (bond.score > kCharacterImpressionCheckpoint) {
    incidentContent = getLocaleString('characterFirstImpressionLikeEvent', [
      subject.name,
      target.name,
    ])
  } else {
    incidentContent = getLocaleString('characterFirstImpressionNormalEvent', [
      subject.name,
      target.name,
    ])
  }

  final incident = Incident(
    content: incidentContent,
    subjectId: subject.id,
    isPublic: false,
  )

  bond.incidentScores[incident.index] = score
  bond.score += score
  bond.haveMet = true

  if (!hasBond) {
    ++target.fame
    subject.bonds.characters[target.id] = bond
  }
}

fun firstImpressionOfOtherCharacter(subject, target) {
  _firstImpressionOfOtherCharacter(subject, target)
  _firstImpressionOfOtherCharacter(target, subject)
}

fun characterHeardOfIncident(character, incident) {
  final subject = game.characters[incident.subjectId]
  final score = ((character.personality.ideal * incident.ideal +
                 character.personality.order * incident.order +
                 character.personality.good * incident.good) / 100)
  if (character.bonds.characters.containsKey(incident.subjectId)) {
    final bond = character.bonds.characters[incident.subjectId]
    bond.incidentScores[incident.index] = score
    bond.score += score
    // 评价发生了改变
    // if (oldScore < 0 && bond.score >= 0) {
    //   --subject.infamy
    // } else if (oldScore >= 0 && bond.score < 0) {
    //   ++subject.infamy
    // }
  } else {
    // 名声增加
    ++subject.fame
    final bond = Bond(id: subject.id, name: subject.name)
    bond.incidentScores[incident.index] = score
    bond.score += score
    character.bonds.characters[incident.subjectId] = bond
    // if (score < 0) {
    //   ++subject.infamy
    // }
  }
  character.heardOfIncidentIndexes.add(incident.index)
}

fun characterWitnessedIncident(character, incident) {
  
}

fun characterSufferedIncident(character, incident) {

}

// fun getSpiritRankTitle(spiritRank) {
//   return getLocaleString('spiritRank${spiritRank}') + getLocaleString('sorcerer')
// }

fun getOrganizationLeaderTitle(organization) {
  return organization.name + getLocaleString('leader')
}

fun removeCharacterHome(character) {
  if (!character.homeId) return

  final loc = game.locations[character.homeId]
  loc.residingWildCharacterIds.remove(character.id)
  loc.residingOrganizedCharacterIds.remove(character.id)
  character.homeId = null
}

fun setCharacterHome(location, character, {isOrganized: bool = true}) {
  if (character.homeId != null) {
    assert(character.homeId != location.id)
    removeCharacterHome(character)
  }
  if (isOrganized) {
    location.residingOrganizedCharacterIds.add(character.id)
  } else {
    location.residingWildCharacterIds.add(character.id)
  }
  character.homeId = location.id
}

fun setHero(id: str) {
  assert(game.characters.containsKey(id))
  engine.info('设置当前玩家人物为 [${game.characters[id].name}]。')
  game.heroId = id;
}

fun getHero() {
  return game.characters[game.heroId]
}

fun addCharacter(char) {
  if (char.nameId) {
    char.name = getLocaleString(char.nameId)
  }
  if (char.artNameId) {
    char.artName = getLocaleString(char.artNameId)
  }
  game.characters[char.id] = char
}

fun addCharacters(chars: List) {
  engine.info('载入人物数据')
  for (final char in chars) {
    addCharacter(char)
  }
}

fun getCharacterById(id: str) {
  return game.characters[id]
}

fun getCharacters() {
  return game.characters
}

fun haveMet(subject, target) {
  final bond = subject.bonds.characters[target.id]
  if (bond && bond.haveMet) {
    return true
  } else {
    return false
  }
}

fun handleCharacterTalk(subject, target) {

}

fun handleCharacterInteraction(characterId) {
  assert(game.characters.containsKey(characterId))
  final character = game.characters[characterId]
  final hero = game.characters[game.heroId]
  final selections = {}
  if (characterId in! game.monthlyActivities.talked) {
    selections.talk = getLocaleString('talk')
  }
  if (characterId in! game.monthlyActivities.gifted) {
    selections.gift = getLocaleString('gift')
  }
  if (characterId in! game.monthlyActivities.practiced) {
    selections.practice = getLocaleString('practice')
  }
  if (characterId in! game.monthlyActivities.consulted) {
    selections.consult = getLocaleString('consult')
  }
  if (characterId in! game.monthlyActivities.requested) {
    selections.request = getLocaleString('request')
  }
  if (characterId in! game.monthlyActivities.insulted) {
    selections.insult = getLocaleString('insult')
  }
  if (characterId in! game.monthlyActivities.stolen) {
    selections.steal = getLocaleString('steal')
  }
  if (characterId in! game.monthlyActivities.peeped) {
    selections.peep = getLocaleString('peep')
  }
  selections.sneekAttack = getLocaleString('sneekAttack')
  showSelectionDialog(selections)
  .then((key) {
    when (key) {
      'talk' -> {
        if (!haveMet(hero, character)) {
          firstImpressionOfOtherCharacter(hero, character)
        }
        handleCharacterTalk(hero, character)
      }
      'gift' -> {
        
      }
      'practice' -> {
        
      }
      'consult' -> {
        
      }
      'request' -> {
        
      }
      'insult' -> {
        
      }
      'steal' -> {
        
      }
      'peep' -> {
        
      }
      'sneekAttack' -> {
        final duel = Duel(hero, character, heroMoveFirst: true)
        showDuel(duel.log)
      }
    }
  })
}
