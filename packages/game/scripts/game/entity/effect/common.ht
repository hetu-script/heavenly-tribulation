// 效果 id 对应一个效果的文字描述，以及触发效果的回调函数。
// 效果的触发分不同场合，可能在食用时触发，或者在攻击时触发等等
// 效果本身有不同数据，例如同样是回复生命的效果，但具体回复的数值可能不同
// 回调函数的工作就是根据效果的具体数值来修改对应的游戏对象
// 某些回调函数直接修改游戏对象，因此没有返回值，
// 也有些回调函数会返回包含执行结果的数值，例如受击减伤效果
// 效果中的数值以列表形式保存，这是为了在游戏界面显示时可以不用关心具体数值的 key。
// 某些效果会以“第 x 次攻击后”的形式触发
// 对于此种效果，回调函数会在该效果对象上临时赋值，计算 CD 时间。

import 'effects.ht'
import 'handlers.ht'
import '../../random.ht'

const kEffectValueTypeInt = 'int';
const kEffectValueTypeFloat = 'float';
const kEffectValueTypePercentage = 'percentage';

// 人物永久效果
const kEffectCategoryCharacter = 'character'
// 物品永久效果
const kEffectCategoryEquippedEntity = 'equippedEntity'
// 食用时触发的效果
const kEffectCategoryConsume = 'consume'
// 受击时触发的效果
const kEffectCategoryDefend = 'defend'
// 造成伤害时触发的改变伤害数值的效果
const kEffectCategoryOffense = 'offense'
// 造成伤害后触发的效果
const kEffectCategoryAfterHit = 'afterHit'

// add / reduce damage: 按照数值增加和减少伤害
// increase / decrease damage: 按照百分比增加和减少伤害，多个百分比时，先加一起，再乘基础值
// more / less damage: 按照百分比增加和减少伤害，多个百分比时，分别乘基础值，最后加一起

// 参考：https://pathofexile.fandom.com/wiki/Stat#more_vs_increased

struct EffectValue {
  construct ({
    value,
    type,
  }) {
    assert(value != null && value > 0)
    this.value = value
    this.type = type
  }
}

struct Effect {
  construct ({
    category,
    handlerType,
    id,
    level,
    description,
    values,
  }) {
    assert(category != null)
    assert(handlerType != null)
    assert(id != null)
    this.category = category
    this.handlerType = handlerType
    this.id = id

    this.description = description ?? 'effect.${this.handlerType}.${this.id}'
    this.values = values ?? []
    this.cooldown = 0
  }
}

fun getEffect({category, id, level}) {
  if (category != null) {
    assert(gEffects.containsKey(category))
  } else {
    category = random.nextIterable(gEffects.keys)
  }
  final c = gEffects[category]
  if (c.isEmpty) return null
  if (id != null) {
    assert(c.containsKey(id))
  } else {
    id = random.nextIterable(c.keys)
  }
  final cl = gEffects[category][id]
  if (cl.isEmpty) return null
  level ??= 0
  if (level >= cl.length) {
    engine.warning('找不到等级 ${level} 的 技能 ${id}，getEffect 将会返回可用的最高等级。')
    return cl.last
  } else {
    return cl[level]
  }
}

fun getEffects({category, count}) {
  assert(category != null)
  final c = gEffects[category]
  final ec = Math.min(c.length, count)
  final effects = {}
  for (final i in range(ec)) {
    var effect
    do {
      effect = getEffect(category: category)
    } while (effects.containsKey(effect.id))
    effects[effect.id] = effect
  }
  return effects
}

fun addEffect({categroy, id, effect}) {
  assert(category != null)
  assert(id != null)
  assert(effect != null)
  if (gEffects.containsKey(category)) {
    final c = gEffects[category]
    assert(!c.containsKey(id))
    c[id] = effect
  } else {
    final c = {}
    c[id] = effect
    gEffects[category] = c
  }
}

fun getEffectHandlerById(id: str) {
  return gEffectHandlers[id]
}

fun addEffectHandler(handler) {
  engine.info('载入效果处理模块 [${handler.name}]')
  gEffectHandlers[handler.id] = handler
}
