import '../random.ht'

const kNone = 'none'

const kStats = 'stats'
final kStrength = 'strength'
final kDexterity = 'dexterity'
final kConstitution = 'constitution'
final kSuperpower = 'superpower'
final kPerception = 'perception'
final kIntelligence = 'intelligence'
final kLeadership = 'leadership'
final kManagement = 'management'

// 进行某些互动的时候
final kFameCheckThreshold = 75
// 进行某些互动的时候
final kCharismaCheckThreshold = 75

const kCommon = 'common'
const kUncommon = 'uncommon'
const kRare = 'rare'
const kEpic = 'epic'
const kLegendary = 'legendary'
const kMythic = 'mythic'
const kExotic = 'exotic'

final kDifficulties = [
  'normal',
  'hard',
  'expert',
  'master',
  'torment',
  'nightmare',
  'purgatory',
]

final kRarity = {
  common: {
    // common 白
    rarity: 'common',
    color: '#ffffff',
    rarityLevel: 0,
  },
  uncommon:{
    // uncommon 灰
    rarity: 'uncommon',
    color: '#CCCCCC',
    rarityLevel: 1,
  },
  rare:{
    // rare 蓝
    rarity: 'rare',
    color: '#00A6A9',
    rarityLevel: 2,
  },
  epic: {
    // epic 紫
    rarity: 'epic',
    color: '#804DC8',
    rarityLevel: 3,
  },
  legendary: {
    // legendary 橙
    rarity: 'legendary',
    color: '#C5C660',
    rarityLevel: 4,
  },
  mythic: {
    // mythic 金
    rarity: 'mythic',
    color: '#F28234',
    rarityLevel: 5,
  },
  exotic: {
    // exotic 虹
    rarity: 'exotic',
    color: '#C65043',
    rarityLevel: 6,
  },
}

fun getRarity({ name }) {
  if (name) {
    assert(kRarity.containsKey(name))
    return kRarity[name]
  } else {
    final r = random.nextDouble()
    if (r > 0.35) {
      return kRarity.common
    }
    if (r > 0.15) {
      return kRarity.uncommon
    }
    if (r > 0.075) {
      return kRarity.rare
    }
    if (r > 0.012) {
      return kRarity.epic
    }
    if (r > 0.003) {
      return kRarity.legendary
    }
    if (r > 0.0005) {
      return kRarity.mythic
    }
    return kRarity.exotic
  }
}

// 从一个稀有度和值的对应表中，按照稀有度的概率取出值
// fun getMappedRarityValue(valueMap) {
//   final r = getRarity()
//   final v = valueMap[r.rarity]
//   return (v is Iterable) ? v.random : v
// }

const kLife = 'life'
const kStamina = 'stamina'

// entityType决定了该对象的数据结构和保存位置
const kEntityTypeCharacter = 'character' //game.characters
const kEntityTypeNpc = 'npc' //game.npcs
const kEntityTypeCompanion = 'companion' //character.companions // 仅用于随从栏数据
const kEntityTypeItem = 'item' //character.inventory
const kEntityTypeSkill = 'skill' //character.skills
const kEntityTypeOrganization = 'organization' //game.organizations

// category是界面上显示的对象类型文字
const kEntityCategoryCharacter = 'character'
const kEntityCategoryBeast = 'beast'
const kEntityCategoryWeapon = 'weapon'
const kEntityCategoryProtect = 'protect'
const kEntityCategoryTalisman = 'talisman'
const kEntityCategoryConsumable = 'consumable'
const kEntityCategoryMaterial = 'material'
const kEntityCategoryOffenseSkill = 'offenseSkill'
const kEntityCategoryMoney = 'money'

// 可食用的物品类型，这里的类型只影响文字描述。
const kEntityConsumableKindMedicine = 'medicine'
const kEntityConsumableKindBeverage = 'beverage'
const kEntityConsumableKindAlchemy = 'alchemy'
const kEntityConsumableKindFood = 'food'

// 材料的类型
const kEntityMaterialKindGrain = 'grain'
const kEntityMaterialKindFruit = 'fruit'
const kEntityMaterialKindFish = 'fish'
const kEntityMaterialKindVegetable = 'vegetable'
const kEntityMaterialKindHerb = 'herb'
const kEntityMaterialKindWood = 'wood'
const kEntityMaterialKindOre = 'ore'
const kEntityMaterialKindJade = 'jade'
const kEntityMaterialKindWater = 'water'
const kEntityMaterialKindEnergy = 'energy'
const kEntityMaterialKindSpectre = 'spectre'

fun _entityStatsChange(data, statsName, change, { overflow = false }) {
  assert(data[statsName] != null)
  data[statsName] += change
  if (!overflow) {
    final max = data['${statsName}Max']
    if (data[statsName] < 0) data[statsName] = 0
    if (data[statsName] >= max) data.life = max
  }
}

fun entityStaminaChange(entity, change, { overflow = false }) {
  if (entity.stats) {
    _entityStatsChange(entity.stats, 'stamina', change, overflow: overflow)
  } else {
    _entityStatsChange(entity, 'stamina', change, overflow: overflow)
  }
}

fun entityLifeChange(entity, change, { overflow = false }) {
  if (entity.stats) {
    _entityStatsChange(entity.stats, 'life', change, overflow: overflow)
  } else {
    _entityStatsChange(entity, 'life', change, overflow: overflow)
  }
}

fun entityChiChange(entity, change, { overflow = false }) {
  if (entity.stats) {
    _entityStatsChange(entity.stats, 'chi', change, overflow: overflow)
  } else {
    _entityStatsChange(entity, 'chi', change, overflow: overflow)
  }
}

fun entitySpiritChange(entity, change, { overflow = false }) {
  if (entity.stats) {
    _entityStatsChange(entity.stats, 'spirit', change, overflow: overflow)
  } else {
    _entityStatsChange(entity, 'spirit', change, overflow: overflow)
  }
}

const _kCharacterRandomAgeMax = 40

fun createRandomBirthTimestamp({min = 1, max = _kCharacterRandomAgeMax}) {
  assert(min > 0)
  final age = random.nextInt(max - min) + min
  final randomDateInAYear = random.nextInt(kTicksPerYear)
  return game.timestamp - (age * kTicksPerYear + randomDateInAYear)
}

const kEncounterTypeCharacter = 'character'

const kDamageTypeBludgeon = 'bludgeon'
const kDamageTypeSlash = 'slash'
const kDamageTypePierce = 'pierce'
const kDamageTypeCold = 'cold'
const kDamageTypeFire = 'fire'
const kDamageTypeLightning = 'lightning'
const kDamageTypeChi = 'chi'
const kDamageTypeSpell = 'spell'
const kDamageTypeCurse = 'curse'

// level up exp function from pokemon
fun expForLevel(level) {
  assert(level >= 0)
  return ((4 * (level * level * level)) ~/ 5 + 1) * 100
}
