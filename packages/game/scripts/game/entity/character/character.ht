import '../../game.ht'
import '../../l10n.ht'
import '../../datetime.ht'
import '../incident.ht'
import '../../generator/name/name.ht' as nameGenerator
import '../../duel.ht'
import '../../util.ht'
import '../constants.ht'
import '../../tile/hexagonal_tile.ht'

// number of the male avatar images
const _kMaleAvatarCount = 37
 // number of the female avatar images
const _kFemaleAvatarCount = 75
const _kCharacterRandomAgeMax = 150
const _kCharacterAverageLooks = 75.0
/// 容貌最大值: 100.0
const _kCharacterMaxLooks = 100.0
const _kCharacterImpressionCheckpoint = 10.0
const _kCharacterInitialGeneralThinking = 4
const _kMajorMotivationProbobility = 0.2
const _kCharacterAttributeMinValue = 1
const _kCharacterAttributeMaxValue = 100
const _kCharacterAttributeSumBase = 400
const _kCharacterAttributeSumDeviation = 300
const _kEquipmentMax = 5

final kCharacterAttributeNames = [
  'strength',
  'superpower',
  'intelligence',
  'perception',
  'leadership',
  'management',
]

final kMajorMotivations = [
  'duty',
  'pleasure',
  'love',
  'wealth',
  'service',
  'eternity',
  'arcane',
  'throne',
  'expert',
]

final kMinorMotivations = [
  'recruitment'
  'marriage',
  'child',
]

final kGeneralThinkings = [
  'self-discipline',
  'helping',
  'travelling',
  'curiosity',
  'competitiveness',
  'humor',
  'enthusiasm',
  'romance',
  'modesty',
  'celibate',
  'dink',
  'chatting',
  'clumsy',
  'cynicism',
  'appearanceIsEverything',
  'bullying',
  'promiscuousness',
  'saddist',
  'backstabbing',
  'greediness',
  'arrogance',
  'jealousness',
  'anger',
]

// 羁绊, 人物对其他的某个事物的印象和评价
struct Bond {
  var id
  var name
  var score

  construct ({
    id,
    name,
    score = 0
  }) {
    this.id = id
    this.name = name
    this.score = score
    this.memory = {}
    this.haveMet = false
  }
}

final _kPregnancyTime = kTicksPerMonth * 9
final _kPregnancyTimeVariable = kTicksPerMonth * 2

struct Baby {
  construct ({
    father,
    mother,
    conceptionTimestamp,
  }) {
    assert(father != null)
    assert(mother != null)
    assert(conceptionTimestamp != null)

    mother.isPregnant = true

    this.fatherId = father.id
    this.motherId = mother.id
    this.conceptionTimestamp = conceptionTimestamp
    this.pregnancyTimestamp = Math.gaussianNoise(_kPregnancyTime, _kPregnancyTimeVariable)
    
    this.isFemale = Math.randomBool()
    if (this.isFemale) {
      final index = Math.randomInt(_kFemaleAvatarCount)
      this.avatar = 'avatar/female/${index}.jpg';
    } else {
      final index = Math.randomInt(_kMaleAvatarCount)
      this.avatar = 'avatar/male/${index}.jpg';
    }
    final r = nameGenerator.getCharacter(
      1,
      isFemale: this.isFemale,
      familyName: father.familyName,
    ).first
    this.familyName = father.familyName
    this.shortName = r.shortName
    this.name = this.familyName + this.shortName
    this.id = 'character_${this.index}_${this.name}'

    game.babies[this.id] = this
  }
}

struct Character {
  construct ({
    familyName,
    shortName,
    hasName = true,
    isFemale: bool,
    birthTimestamp,
    locationId,
    nationId,
    isNewborn = false, // 是否是新生儿，如果是则会自动为其添加父母关系
    fatherId,
    motherId,
    attributes,
    isMajor = true, // 是否是主要NPC，主要NPC会加入世界人物列表，并会有更多互动
    worldPositionX,
    worldPositionY,
  }) {
    this.index = game.characters.length
    if (isFemale != null) {
      this.isFemale = isFemale
    } else {
      this.isFemale = Math.randomBool()
    }
    if (this.isFemale) {
      final index = Math.randomInt(_kFemaleAvatarCount)
      this.avatar = 'avatar/female/${index}.jpg';
    } else {
      final index = Math.randomInt(_kMaleAvatarCount)
      this.avatar = 'avatar/male/${index}.jpg';
    }
    if (familyName != null && shortName != null) {
      this.familyName = familyName
      this.shortName = shortName
      this.name = this.familyName + this.shortName
    } else if (hasName) {
      final r = nameGenerator.getCharacter(1, isFemale: this.isFemale).first
      this.familyName = familyName ?? r.familyName
      this.shortName = shortName ?? r.shortName
      this.name = this.familyName + this.shortName
    }
    if (isMajor) {
      assert(this.name != null)
      this.id = 'character_${this.index}_${this.name}'
      game.characters[this.id] = this
    }
    
    // age 的格式是 timestamp, 精确到 tick. 
    if (birthTimestamp != null) {
      this.birthTimestamp = birthTimestamp
    } else {
      this.birthTimestamp = createRandomBirthTimestamp()
    }
    this.nationId = nationId
    this.looks = hyperbola(_kCharacterAverageLooks)
    this.favoredLooks = hyperbola(_kCharacterMaxLooks)

    // 该角色的称号
    this.titles = {
      'none': getLocaleString(kNone),
    }
    // titles中直接保存了称号字符串
    this.currentTitleId = kNone
    this.organizationRank = 0
 
    // 有多少人知道此人的名字
    this.knownByPopulation = 0

    // // 恶名，知道名字中，对此人差评的人的数量
    // this.infamy = 0

    // 身上携带的金钱数量
    this.money = 0

    // 身上的普通物品，id相同的可以堆叠，宝物，技能，道具都在这里，每一个都是单独生成，无法堆叠
    // 可以放在主位（武器）、支持位（护甲、靴子）
    this.inventory = {}

    // 技能，可以放在主位（斗技）、辅助位（玄功）、支持位（遁术）
    this.skills = {}

    // 装备栏的位置和数量是固定的
    // 法宝、技能都可以装备，比如拳法作为技能可以直接放在装备栏第一位，但剑法作为辅助技能只能放在作为物品的剑后面
    // 每个位置都是一个EquipSlot形式的对象
    this.equipments = {
      offense: {},
      defense: {},
    }

    // NPC类随从，跟随时可以装备他们的物品和技能，并在战斗中使用
    this.companions = []

    // 属性点数数值
    this.attributes = generateRandomAttributes(
      Math.gaussianNoise(_kCharacterAttributeSumBase, _kCharacterAttributeSumDeviation, min: 6, max: 600),
      _kCharacterAttributeMinValue,
      _kCharacterAttributeMaxValue,
    )

    if (attributes) {
      this.assign(attributes)
    }

    // 当前状态数值，由种族、天赋、属性点数、增益减损、物品、技能等计算得来
    this.stats = {}

    recalculateAttributes(this)
    rejuvenate(this)

    // 该角色的家庭关系
    this.relationships = {
      fatherId,
      motherId,
      spouseId: null,
      siblingIds: [],
      childrenIds: [],
    }

    // 该角色的人格纬度
    this.personality = {
      // 三观，最小 -50 最大 +50
      ideal: Math.random() * 100.0 - 50.0,
      order: Math.random() * 100.0 - 50.0,
      good: Math.random() *100.0 - 50.0,

      // 行为逻辑，最小 -50 最大 +50
      social: Math.random() * 100.0 - 50.0,
      reason: Math.random() * 100.0 - 50.0,
      control: Math.random() * 100.0 - 50.0,
      frugal: Math.random() * 100.0 - 50.0,
      frank: Math.random() * 100.0 - 50.0,
      confidence: Math.random() * 100.0 - 50.0,
      prudence: Math.random() * 100.0 - 50.0,
      empathy: Math.random() * 100.0 - 50.0,
      generosity: Math.random() * 100.0 - 50.0,
    }

    // 该角色的动机，主要动机只有一个，次要动机可以有多个
    // 动机决定了角色的行动
    this.motivations = []
    // 思想列表，思想决定了角色对于其他事物的看法
    this.thinkings = []

    if (Math.random() < _kMajorMotivationProbobility) {
      this.motivations.add(kMajorMotivations.random)
    }

    final r = Math.randomInt(_kCharacterInitialGeneralThinking)
    for (final i in range(r)) {
      var thinking
      do {
        thinking = kGeneralThinkings.random
      } while (this.thinkings.contains(thinking))
      this.thinkings.add(thinking)
    }

    // 该角色的记忆
    this.memory = {
      // conducted: [],
      experienced: [], // 主动或者被动
      witnessed: [],
      // heard: [],
    }

    // 该角色和世界上其他事物的交互历史
    // 反过来，这些其他的事物，也保存了一份对应这个人的历史
    // 例如一个据点保存的这个人所做过事情的历史，决定了此人在此地的声望
    // 这个声望会影响到和官府的交互。
    this.bonds = {
      // 代表对另一个角色的记忆
      characters: {},
      // 代表对某个组织的记忆
      organizations: {},
      // 代表对某个据点的记忆
      locations: {},
      // 代表对某个国家的记忆
      nations: {},
      // 代表对某个法宝的记忆
      talismans: {},
    }

    this.tasks = []
    
    if (locationId) {
      final location = game.locations[locationId]
      setCharacterLocationId(this, locationId)

      final terrainIndex = location.terrainIndex
      final position = index2TilePos(terrainIndex, game.world.width)
      this.worldPositionX = position.left
      this.worldPositionY = position.top

      if (isNewborn) {
        assert(fatherId != null)
        assert(motherId != null)
        final father = game.characters[fatherId]
        final mother = game.characters[motherId]
        this.birthPlaceId = locationId
        // 出生事件会修改自身，需要放在最后处理
        final incidentContent = getLocaleString('incidentBorn', [
            father.name,
            mother.name,
            this.name,
            location.name,
          ])
        Incident(
          content: incidentContent,
          subjectIds: [father.id, mother.id],
          objectIds: [this.id],
          locationId: locationId,
          isPrivate: false,
          order: 10,
          ideal: -10,
        )
        // final homeId = mother.homeId ?? mother.locationId
        // final home = game.locations[homeId]
        final home = game.locations[mother.homeId]
        setCharacterHome(this, home)
        final siblingIds = father.relationships.childrenIds
        this.relationships.siblingIds.addAll(siblingIds)
        for (final id in siblingIds) {
          final sib = game.characters[id]
          sib.relationships.siblingIds.add(this.id)
        }
        father.relationships.childrenIds.add(this.id)
        mother.relationships.childrenIds.add(this.id)
      } else {
        // 设置居住地会触发事件从而修改自身，需要放在最后处理
        setCharacterHome(this, location)
      }
    } else {
      this.worldPositionX = worldPositionX
      this.worldPositionY = worldPositionY
    }
  }
}

fun rejuvenate(character) {
  character.stats.life = character.attributes.life
  character.stats.stamina = character.attributes.stamina
}

fun setCharacterTitle(character, titleId) {
  character.currentTitleId = titleId
}

// 如果没有称号，会返回空字符串
fun getCharacterTitle(character) {
  if (character.currentTitleId != kNone) {
    return character.titles[character.currentTitleId]
  } else {
    return ''
  }
}

// 如果没有称号，会返回“无”
fun getCharacterTitleString(character) {
  return character.titles[character.currentTitleId]
}

fun getCharacterAge(character) {
  return (game.timestamp - character.birthTimestamp) ~/ kTicksPerYear
}

fun getCharacterAgeString(character) {
  return toAgeString(game.timestamp - character.birthTimestamp)
}

// 名声等于有多少个角色听说过你，是随着世界上的人数变化而动态变化的，取值：0 - 100
fun getCharacterFame(character) {
  return character.knownByPopulation / game.characters.length * 100
}

fun getCharacterFameString(character) {
  return (character.knownByPopulation / game.characters.length).toPercentageString(2)
}

fun createRandomBirthTimestamp([min = 1, max = _kCharacterRandomAgeMax]) {
  assert(min > 0)
  final age = Math.randomInt(max - min) + min
  final randomDateInAYear = Math.randomInt(kTicksPerYear)
  return game.timestamp - (age * kTicksPerYear + randomDateInAYear)
}

/// 容貌评价的计算公式
/// 每个角色自身有一个容貌值，这个数值代表大众眼中的评价
/// 每个角色都会有一个对特定容貌值的偏好
/// 本公式会利用这两个数值，计算某个角色对另一个角色的容貌的评价
/// looks 是对方的容貌，0 <= looks <= 100
/// favor 是该角色的偏好，0 <= favor <= 100
fun _calculateLooksScore({looks: float, favor: float}) -> float {
  assert(0.0 <= looks && looks <= _kCharacterMaxLooks)
  if (favor != null) {
    assert(0.0 <= favor && favor <= _kCharacterMaxLooks)
  }
  if (looks < ((favor + _kCharacterMaxLooks) / 2)) {
    return (-(looks - favor) * (looks - favor)) / 20 + _kCharacterMaxLooks
  } else {
    return (-(looks - _kCharacterMaxLooks) * (looks - _kCharacterMaxLooks)) / 20 + _kCharacterMaxLooks
  }
}

fun generateRandomAttributes(maxStats, minValue, maxValue) {
  assert(maxStats != null)
  assert(minValue != null)
  assert(maxValue != null)

  final attributes = {}
  
  fun checkValue(value) {
    if (value < minValue) return minValue
    if (value > maxValue) return maxValue
    return value
  }
  
  final list = kCharacterAttributeNames.toList()
  list.shuffle()
  var rest = maxStats
  for (var i = 0; i < list.length - 1; ++i) {
    final name = list[i]
    final value = Math.randomInt(rest)
    attributes[name] = checkValue(value)
    rest -= value
  }
  attributes[list.last] = checkValue(rest)
  return attributes
}

// 根据属性、装备、技能计算出当前状态
// 状态包括：生命、伤害、防御等。
fun recalculateAttributes(character) {
  character.attributes.life = (character.attributes.strength ~/ 5 + 1) * 25
  character.attributes.stamina = (character.attributes.strength ~/ 10 + 1) * 50
}

fun getStatsPercentageOfCharacter(character) {
  final life = (character.stats.life / character.attributes.life)
  final stamina = (character.stats.stamina / character.attributes.stamina)
  return {
    life: {
      value: character.stats.life,
      max: character.attributes.life,
      percentage: life,
      string: life.toPercentageString(2),
    },
    stamina: {
      value: character.stats.stamina,
      max: character.attributes.stamina,
      percentage: stamina,
      string: stamina.toPercentageString(2),
    }
  }
}

// 第一印象分
fun _characterFirstMet(subject, target, [causeIncident, causeIncidentScore]) {
  var bond
  if (subject.bonds.characters[target.id] != null) {
    // 虽然没见过，但如果以前就听说过的话
    bond = subject.bonds.characters[target.id]
    if (bond.haveMet) return
  } else {
    ++target.knownByPopulation // 第一次创建羁绊，target 的知名度增加
    bond = Bond(id: target.id, name: target.name)
    subject.bonds.characters[target.id] = bond
  }
  var metScore = 0
  metScore += _calculateLooksScore(looks: target.looks, favor: subject.favoredLooks) / 10
  if (target.organizationId != null) {
    // TODO: 敌对门派要减分
    metScore += target.organizationId == subject.organizationId ? 10 : 0
  }
  // TODO: 敌对国家要减分
  // TODO: 这两个挪到聊天互动之后再计算
  // bond.scoreOfSameNation = target.nationId == subject.nationId ? 5 : 0
  // bond.scoreOfSameBirthPlace = target.birthPlaceId == subject.birthPlaceId ? 10 : 0
  // score += target.familyName == subject.familyName ? 10: 0
  // TODO: 同名之谊?

  var incidentContent
  if (metScore < -_kCharacterImpressionCheckpoint) {
    incidentContent = getLocaleString('incidentFirstMetHate', [
      subject.name,
      target.name,
    ])
  } else if (metScore > _kCharacterImpressionCheckpoint) {
    incidentContent = getLocaleString('incidentFirstMetLike', [
      subject.name,
      target.name,
    ])
  } else {
    incidentContent = getLocaleString('incidentFirstMetNormal', [
      subject.name,
      target.name,
    ])
  }

  final metIncident = Incident(
    content: incidentContent,
    subjectIds: [subject.id], // 见面是一个单向事件
    isPrivate: true,
  )

  bond.memory[metIncident.index] = metScore
  bond.score += metScore
  bond.haveMet = true
}

fun characterFirstMet(subject, target, [causeIncident, causeIncidentScore]) {
  _characterFirstMet(subject, target, causeIncident, causeIncidentScore)
  _characterFirstMet(target, subject, causeIncident, causeIncidentScore)
}

fun _calculateIncidentScore(character, incident) {
  return (character.personality.ideal * incident.ideal +
                 character.personality.order * incident.order +
                 character.personality.good  * incident.good) / 100
}

fun characterExperiencedIncident(character, incident) {
  assert(character != null)
  assert(incident != null)
  character.memory.experienced.add(incident.index)
  if (character.id in incident.subjectIds) {
    character.personality.ideal += character.personality.ideal * incident.ideal / 100
    character.personality.order += character.personality.order * incident.order / 100
    character.personality.good += character.personality.good * incident.good / 100
  } else if (character.id in incident.objectIds) {
    // 亲身经历者会放大原本的评价
    final score = _calculateIncidentScore(character, incident) * 1.5 + incident.score
    for (final id in incident.subjectIds) {
      var bond
      if (!character.bonds.characters.contains(id)) {
        // 如果还不认识行动者
        final subject = game.characters[id]
        characterFirstMet(character, subject, incident, score)
      }
      bond = character.bonds.characters[id]
      bond.memory[incident.index] = score
      bond.score += score
    }
  }
}

fun characterWitnessIncident(character, incident, { witnessed }) {
  assert(character != null)
  assert(incident != null)
  character.memory.witnessed.add(incident.index)
  var score = _calculateIncidentScore(character, incident)
  if (witnessed) {
    // 亲身经历者会放大原本的评价
    score *= 1.5
  }
  for (final id in incident.subjectIds) {
    if (character.bonds.characters.containsKey(id)) {
      final bond = character.bonds.characters[id]
      bond.memory[incident.index] = score
      bond.score += score
      // 评价发生了改变
      // if (oldScore < 0 && bond.score >= 0) {
      //   --subject.infamy
      // } else if (oldScore >= 0 && bond.score < 0) {
      //   ++subject.infamy
      // }
    } else {
      // 名声增加
      final subject = game.characters[id]
      ++subject.knownByPopulation
      final bond = Bond(id: id, name: subject.name)
      bond.memory[incident.index] = score
      bond.score += score
      character.bonds.characters[id] = bond
      // if (score < 0) {
      //   ++subject.infamy
      // }
    }
  }
  for (final id in incident.objectIds) {
    if (!character.bonds.characters.containsKey(id)) {
      // 名声增加
      final object = game.characters[id]
      ++object.knownByPopulation
      final bond = Bond(id: id, name: object.name)
      bond.memory[incident.index] = score
      bond.score += score
      character.bonds.characters[id] = bond
    }
  }
}

// fun getSpiritRankTitle(spiritRank) {
//   return getLocaleString('spiritRank${spiritRank}') + getLocaleString('sorcerer')
// }

fun removeCharacterHome(character) {
  if (!character.homeId) return

  final loc = game.locations[character.homeId]
  // loc.residingCharacterIds.remove(character.id)
  loc.residingWildCharacterIds.remove(character.id)
  loc.residingOrganizedCharacterIds.remove(character.id)
  character.homeId = null
}

fun setCharacterHome(character, location) {
  // 触发定居事件
  var incidentContent
  if (location.organizationId && character.organizationId == location.organizationId) {
    location.residingOrganizedCharacterIds.add(character.id)
    incidentContent = getLocaleString('incidentSettleOrganized', [
      character.name,
      location.name,
      game.organizations[location.organizationId].name,
    ])
  } else {
    location.residingWildCharacterIds.add(character.id)
    incidentContent = getLocaleString('incidentSettle', [
      character.name,
      location.name,
    ])
  }
  if (character.homeId != location.id) {
    Incident(
      content: incidentContent,
      subjectIds: [character.id],
    )
  }
  // 即便是同一个场景，也有可能是从在野变成加入组织，所以还是要执行下面的代码
  removeCharacterHome(character)
  character.homeId = location.id
}

fun setHeroId(id: str) {
  assert(game.characters.containsKey(id))
  engine.info('设置当前玩家人物为 [${game.characters[id].name}]。')
  game.heroId = id;
}

fun getHeroId() {
  return game.heroId
}

fun getHero() {
  return game.characters[game.heroId]
}

fun getCharacterWorldPosition(character) {
  return {
    left: character.worldPositionX,
    top: character.worldPositionY,
  }
}

fun addCharacter(char) {
  if (char.nameId) {
    char.name = getLocaleString(char.nameId)
  }
  if (char.artNameId) {
    char.artName = getLocaleString(char.artNameId)
  }
  game.characters[char.id] = char
}

fun addCharacters(chars: List) {
  engine.info('载入人物数据')
  for (final char in chars) {
    addCharacter(char)
  }
}

fun getCharacters([ids]) {
  if (ids != null) {
    assert(ids.isNotEmpty)
    return game.characters.values.where( (value) => value.id in ids )
  } else {
    return game.characters
  }
}

fun getCharacterById(id: str) {
  return game.characters[id]
}

fun haveMet(subject, target) {
  final bond = subject.bonds.characters[target.id]
  if (bond && bond.haveMet) {
    return true
  } else {
    return false
  }
}

fun getEquippedItem(equipData, character) {
  var item
  when (equipData.category) {
    kEntityCategoryWeapon -> {
      item = character.inventory[equipData.id]
    }
    kEntityCategoryMartialArts -> {
      item = character.skills[equipData.id]
    }
  }
  assert(item != null)
  return item
}

// 法宝和技能都可以装备，只要类型符合
// {
//   category,
//   id,
//   supports,
// }
fun equip(item, character, [index]) -> bool {
  if (item.isEquipped) return
  if (!character.inventory[item.id]) character.inventory[item.id] = item
  final equipData = {
    id: item.id,
    category: item.category, // 主类型：武器、斗技等
    kind: item.kind, // 次类型：剑、拳法等
  }
  when (item.equipType) {
    kEquipTypeOffense -> {
      if (!index) {
        // 如果有空位就装备在空位上
        for (final i in range(1, _kEquipmentMax)) {
          if (!character.equipments[kEquipTypeOffense][i]) {
            character.equipments[kEquipTypeOffense][i] = equipData
            item.isEquipped = true
            return true
          }
        }
        // 否则替换掉第一个空位
        index = 1
      }
      final oldEquipData = character.equipments[kEquipTypeOffense][index]
      final oldItem = getEquippedItem(equipData, character)
      oldItem.isEquipped = false
      character.equipments[kEquipTypeOffense][index] = equipData
      if (equipData.category == oldItem.category && equipData.kind == oldItem.kind) {
        equipData.supports = oldEquipData.supports
      }
      item.isEquipped = true
      return true
    }
    kEquipTypeSupport -> {
      if (!index) {
        for (final i in range(1, _kEquipmentMax)) {
          final oldEquipData = character.equipments[kEquipTypeOffense][i]
          if (oldEquipData && oldEquipData.category == data.category &&
              oldEquipData.kind == data.kind) {
            if (oldEquipData.supports.length < _kEquipmentMax - 1) {
              oldEquipData.supports.add(equipData)
            } else {
              oldEquipData.supports.first = equipData
            }
            item.isEquipped = true
            return true
          }
        }
        return false
      } else {
        final oldEquipData = character.equipments[kEquipTypeOffense][index]
        assert(oldEquipData.category == data.category &&
              oldEquipData.kind == data.kind)
        if (oldEquipData.supports.length < _kEquipmentMax - 1) {
          equipData.supports.add(equipData)
        } else {
          oldEquipData.supports.first = equipData
        }
        item.isEquipped = true
        return true
      }
    }
    kEquipTypeDefense -> {
      // 如果有空位就装备在空位上
      if (!index) {
        for (final i in range(1, _kEquipmentMax)) {
          if (!character.equipments[kEquipTypeDefense][i]) {
            character.equipments[kEquipTypeDefense][i] = equipData
            item.isEquipped = true
            return true
          }
        }
        // 否则替换掉第一个空位
        index = 1
      }
      final oldEquipData = character.equipments[kEquipTypeDefense][index]
      final oldItem = getEquippedItem(equipData, character)
      oldItem.isEquipped = false
      character.equipments[kEquipTypeDefense][index] = equipData
      if (equipData.category == oldItem.category && equipData.kind == oldItem.kind) {
        equipData.supports = oldEquipData.supports
      }
      item.isEquipped = true
      return true
    }
  }
}

fun handleCharacterTalk(subject, target) {
  if (!haveMet(subject, target)) {
    characterFirstMet(subject, target)
  }

}

fun handleCharacterInteraction(characterId) {
  assert(game.characters.containsKey(characterId))
  final character = game.characters[characterId]
  final hero = game.characters[game.heroId]
  final selections = {}
  if (characterId in! game.playerMonthly.talked) {
    selections.talk = getLocaleString('talk')
  }
  if (characterId in! game.playerMonthly.gifted) {
    selections.gift = getLocaleString('gift')
  }
  if (characterId in! game.playerMonthly.practiced) {
    selections.practice = getLocaleString('practice')
  }
  if (characterId in! game.playerMonthly.consulted) {
    selections.consult = getLocaleString('consult')
  }
  if (characterId in! game.playerMonthly.requested) {
    selections.request = getLocaleString('request')
  }
  if (characterId in! game.playerMonthly.insulted) {
    selections.insult = getLocaleString('insult')
  }
  if (characterId in! game.playerMonthly.stolen) {
    selections.steal = getLocaleString('steal')
  }
  selections.sneakAttack = getLocaleString('sneakAttack')
  selections.leave = getLocaleString('leave')
  showSelection(selections).then((key) {
    when (key) {
      'talk' -> {
        handleCharacterTalk(hero, character)
      }
      'gift' -> {
        
      }
      'practice' -> {
        showDuel(hero, character, type: 'practice')
      }
      'consult' -> {
        
      }
      'request' -> {
        
      }
      'insult' -> {
        
      }
      'steal' -> {
        
      }
      'sneakAttack' -> {
        showDuel(hero, character, type: 'sneakAttack')
      }
    }
  })
}
