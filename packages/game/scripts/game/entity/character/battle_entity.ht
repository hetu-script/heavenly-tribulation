import '../common.ht'
import '../../binding/worldmap.ht'
import 'status_effect.ht'

const _kCharacterAttributeMinValue = 1
const _kCharacterAttributeMaxValue = 100
const _kCharacterAttributeSumBase = 500
const _kCharacterAttributeSumDeviation = 300

const kEscapedLootProbability = 0.5

final kCharacterAttributeNames = [
  'strength',
  'constitution',
  'spirituality',
  'willpower',
  'dexterity',
  'intelligence',
  'perception',
  'charisma',
]

const kMajorAttributeFactor = 0.75

struct BattleEntity {
  construct ({
    attributes,
    attributeSum = _kCharacterAttributeSumBase,
    majorAttributes: List = [],
    generate = true,
    baseLife = 100,
    baseChi = 100,
    baseStamina = 100,
  }) {
    // 身上携带的金钱数量
    this.money = 0

    // 身上的普通物品，id相同的可以堆叠，宝物，技能，道具都在这里，每一个都是单独生成，无法堆叠
    this.inventory = {}

    // 技能，可以放在主位（斗技）、辅助位（玄功）、支持位（遁术）
    this.skills = {}

    // 随从，可以设置为战斗伙伴
    this.companions = {}

    // 装备栏的位置和数量是固定的
    // 每个位置都是一个EquipSlot形式的对象
    // 可以放在攻击位（武器）、防御位（护甲、靴子）、随从位
    this.equipments = {
      offense: {}, // 武器、斗技、进攻法宝总共可以装备 4 个
      defense: {}, // 防具、靴子、辅助法宝、内功、轻功总共可以装备 4 个
      companion: {}, // 随从总共可以装备 4 个
    }

    // 属性点数数值
    if (generate) {
      this.attributes = generateCharacterAttributes(
        attributesSum: Math.gaussianNoise(
            attributeSum,
            _kCharacterAttributeSumDeviation,
            min: kCharacterAttributeNames.length,
            max: kCharacterAttributeNames.length * 100,
            randomGenerator: random,
          ).toInt(),
        minValue: _kCharacterAttributeMinValue,
        maxValue: _kCharacterAttributeMaxValue,
        majorAttributes: majorAttributes,
      )
    } else {
      this.attributes = {}
    }

    if (attributes) {
      this.attributes.assign(attributes)
    }

    // 当前状态数值，由种族、天赋、属性点数、增益减损、物品、技能等计算得来
    this.stats = {}

    // 当前异常状态，包括 buff debuff 等等。
    this.statusEffects = {}

    generateCharacterStats(
      this,
      baseLife: baseLife,
      baseChi: baseChi,
      baseStamina: baseStamina,
    )
    rejuvenate(this)
  }
}

fun generateCharacterAttributes({
    attributesSum,
    minValue,
    maxValue,
    majorAttributes: List = [],
  }) {
  assert(attributesSum > 0)
  assert(minValue > 0)
  assert(maxValue > 0 && maxValue > minValue)

  final attributes = {}
  
  fun checkValue(value) {
    if (value < minValue) return minValue
    if (value > maxValue) return maxValue
    return value
  }
  
  for (final name in random.shuffle(kCharacterAttributeNames)) {
    if (name in majorAttributes) {
      minValue = attributesSum / kCharacterAttributeNames.length * kMajorAttributeFactor
    }
    final value = (
      Math.gaussianNoise(
        attributesSum / kCharacterAttributeNames.length * 0.6,
        20,
        min: minValue,
        max: maxValue,
        randomGenerator: random,
      )
    ).toInt()
    attributes[name] = checkValue(value)
  }
  return attributes
}

// 根据属性、装备、技能计算出当前状态
// 状态包括：生命、伤害、防御等。
fun generateCharacterStats(
    character, {
    baseLife = 100,
    baseChi = 100,
    baseStamina = 100,
  }) {
  character.attributes.life = baseLife + (character.attributes.constitution ~/ 5) * 5
  character.attributes.chi = baseChi + (character.attributes.superpower ~/ 5) * 5
  character.attributes.stamina = baseStamina + (character.attributes.strength ~/ 5) * 5

  character.stats = character.attributes.clone()

  character.stats.charisma = (character.attributes.charisma + character.looks) ~/ 2

  character.stats.lifeMax = character.stats.life
  character.stats.chiMax = character.stats.chi
  character.stats.staminaMax = character.stats.stamina
}

fun getCharacterStats(character) {
  final stats = {
    life: character.stats.life,
    lifeMax: character.stats.lifeMax,
    chi: character.stats.chi,
    chiMax: character.stats.chiMax,
    stamina: character.stats.stamina,
    staminaMax: character.stats.staminaMax,
    defense: {},
    offense: {},
    companion: {},
  }
  for (final i in range(1, kEquipmentMax.defense)) {
    final equipData = character.equipments.defense[i]
    if (equipData != null) {
      final item = getEquipped(equipData, character)
      stats.defense[i] = {
        life: item.stats.life,
        lifeMax: item.stats.lifeMax,
      }
    }
  }
  for (final i in range(1, kEquipmentMax.offense)) {
    final equipData = character.equipments.offense[i]
    if (equipData != null) {
      final item = getEquipped(equipData, character)
      stats.offense[i] = {
        life: item.stats.life,
        lifeMax: item.stats.lifeMax,
        damage: item.stats.damage,
      }
    }
  }
  for (final i in range(1, kEquipmentMax.companion)) {
    final equipData = character.equipments.companion[i]
    if (equipData != null) {
      final companion = getEquipped(equipData, character)
      stats.companion[i] = {
        life: companion.stats.life,
        lifeMax: companion.stats.lifeMax,
        damage: equipData.damage, // 在装备数据中已经提前计算了随从的攻击伤害
      }
    }
  }
  return stats
}


// 战斗，异步函数，如果获胜则返回 true
fun heroBattle (
  char2, {
  resolveResult = true,
  loot = true,
  takeAll = true,
  isInMaze = false,
  char1Resurrect = true,
  char2Resurrect = false,
  onWon,
  onLost,
}) -> Future async {
  final char1 = getHero()
  return showDuel(char1, char2).then((result) {
    if (result?.result) {
      if (resolveResult) resolveDuelResult(char1, char2, result)
      if (loot) characterLoot(char1, char2, takeAll: takeAll)
      
      final incidentContent = getLocaleString('duelVistory', [ char1.name, char2.name ] )
      Incident(
        content: incidentContent,
        subjectIds: [char1.id],
        isPrivate: true,
        isInMaze: isInMaze,
      )
      if (char2Resurrect && char2.isMajorCharacter) {
        final injury = StatusEffect.injury()
        char2.statusEffects[injury.kind] = injury
        char2.stats.life = 1
      } else {
        final incidentContent = getLocaleString('characterKill', [ char1.name, char2.name ] )
        Incident(
          content: incidentContent,
          subjectIds: [char1.id],
          isPrivate: true,
          isInMaze: isInMaze,
        )
        if (char2.isMajorCharacter) {
          char2.isDead = true
        } else {
          delete game.npcs[char2.id]
        }
      }
      if (onWon is function) {
        onWon()
      }
      return true
    } else {
      if (char1Resurrect) {
        final injury = StatusEffect.injury()
        char1.statusEffects[injury.kind] = injury
        char1.stats.life = 1
      }
      if (onLost is function) {
        onLost()
      }
      return false
    }
  })
}

fun characterCostStamina(character, value) {
  character.stats.stamina -= value
  if (character.stats.stamina < 0) character.stats.stamina = 0
}
