import '../common.ht'

final kCharacterAttributeNames = [
  'strength',
  'constitution',
  'spirituality',
  'willpower',
  'dexterity',
  'intelligence',
  'perception',
  'charisma',
]

const _kCharacterAttributeMinValue = 1
const _kCharacterAttributeMaxValue = 100
const _kCharacterAttributeSumBase = 400
const _kCharacterAttributeSumDeviation = 200

struct BattleEntity {
  construct ({
    attributes,
    attributeSum = _kCharacterAttributeSumBase,
  }) {
    // 身上携带的金钱数量
    this.money = 0

    // 身上的普通物品，id相同的可以堆叠，宝物，技能，道具都在这里，每一个都是单独生成，无法堆叠
    // 可以放在主位（武器）、支持位（护甲、靴子）
    this.inventory = {}

    // 技能，可以放在主位（斗技）、辅助位（玄功）、支持位（遁术）
    this.skills = {}

    // 装备栏的位置和数量是固定的
    // 每个位置都是一个EquipSlot形式的对象
    this.equipments = {
      defense: {}, // 防具、靴子、辅助法宝、内功、轻功总共可以装备 4 个
      offense: {}, // 武器、斗技、进攻法宝总共可以装备 4 个
      companion: {}, // 随从总共可以装备 4 个
    }

    // 属性点数数值
    this.attributes = generateRandomAttributes(
      Math.gaussianNoise(attributeSum, _kCharacterAttributeSumDeviation, min: 6, max: 600).toInt(),
      _kCharacterAttributeMinValue,
      _kCharacterAttributeMaxValue,
    )

    if (attributes) {
      this.attributes.assign(attributes)
    }

    // 当前状态数值，由种族、天赋、属性点数、增益减损、物品、技能等计算得来
    this.stats = {}

    calculateCharacterStats(this)
    rejuvenate(this)
  }
}

fun generateRandomAttributes(maxStats, minValue, maxValue, [majorAttr]) {
  assert(maxStats != null)
  assert(minValue != null)
  assert(maxValue != null)

  final attributes = {}
  
  fun checkValue(value) {
    if (value < minValue) return minValue
    if (value > maxValue) return maxValue
    return value
  }
  
  final list = kCharacterAttributeNames.toList()
  list.shuffle()
  for (var i = 0; i < list.length; ++i) {
    final name = list[i]
    var min = minValue
    if (majorAttr && name == majorAttr) {
      min = maxStats / list.length * 0.75
    }
    final value = (Math.gaussianNoise(maxStats / list.length * 0.6, 20, min: min, max: maxValue)).toInt()
    attributes[name] = checkValue(value)
  }
  return attributes
}

// 根据属性、装备、技能计算出当前状态
// 状态包括：生命、伤害、防御等。
fun calculateCharacterStats(character) {

  character.attributes.life = 100 + (character.attributes.constitution ~/ 5) * 5
  character.attributes.chi = 100 + (character.attributes.superpower ~/ 5) * 5
  character.attributes.stamina = 100 + (character.attributes.strength ~/ 5) * 5
  // character.attributes.speed = ((character.attributes.dexterity + character.attributes.strength) ~/ 10) * 5

  character.stats = character.attributes.clone()

  character.stats.charisma = (character.attributes.charisma + character.looks) ~/ 2

  character.stats.lifeMax = character.stats.life
  character.stats.chiMax = character.stats.chi
  character.stats.staminaMax = character.stats.stamina
}

fun getCharacterStats(character) {
  final stats = {
    life: character.stats.life,
    lifeMax: character.stats.lifeMax,
    chi: character.stats.chi,
    chiMax: character.stats.chiMax,
    stamina: character.stats.stamina,
    staminaMax: character.stats.staminaMax,
    defense: {},
    offense: {},
    companion: {},
  }
  for (var i = 1; i < kEquipmentMax.defense; ++i) {
    final equipData = character.equipments.defense[i]
    if (equipData != null) {
      final item = getEquippedEntity(equipData, character)
      stats.defense[i] = {
        life: item.stats.life,
        lifeMax: item.stats.lifeMax,
      }
    }
  }
  for (var i = 1; i < kEquipmentMax.offense; ++i) {
    final equipData = character.equipments.offense[i]
    if (equipData != null) {
      final item = getEquippedEntity(equipData, character)
      stats.offense[i] = {
        life: item.stats.life,
        lifeMax: item.stats.lifeMax,
        damage: item.stats.damage,
      }
    }
  }
  for (var i = 1; i < kEquipmentMax.companion; ++i) {
    final equipData = character.equipments.companion[i]
    if (equipData != null) {
      final companion = getEquippedEntity(equipData, character)
      stats.companion[i] = {
        life: companion.stats.life,
        lifeMax: companion.stats.lifeMax,
        damage: equipData.damage, // 在装备数据中已经提前计算了随从的攻击伤害
      }
    }
  }
  return stats
}

fun getEquippedItem(equipData, character) {
  var item
  when (equipData.entityType) {
    kEntityTypeItem -> {
      item = character.inventory[equipData.id]
    }
    kEntityTypeSkill -> {
      item = character.skills[equipData.id]
    }
  }
  assert(item != null)
  return item
}