import '../../game.ht'
import '../character/character.ht'
import '../../dialog.ht'
import '../../name/name.ht'
import '../../l10n.ht'
import '../common.ht'
import '../../tile/hexagonal_tile.ht'
import 'site.ht'

const _kLocationInitialStabilityMax = 50

struct Location {
  construct ({
    terrainIndex,
    left,
    top,
    category,
    name,
    isHidden = false,
  }) {
    assert(terrainIndex != null)
    assert(left != null && top !=)
    this.terrainIndex = terrainIndex
    this.tilePosition = Tile(
      left,
      top,
      index: terrainIndex,
      mapWidth: game.world.width,
    )
    this.index = game.locations.length
    if (name) {
      this.name = name
    } else {
      var conflict = false
      do {
        final r = nameGenerator.getLocation(1, category: category)
        this.name = r.first.name
        conflict = game.locations.values.where((element) =>
          element.name == this.name).isNotEmpty
      } while (conflict)
    }
    this.category = category
    this.id = 'location_${this.index}_${this.name}'
    game.locations[this.id] = this
    
    this.isHidden = isHidden

    // 据点稳定度，最高100，初始随机0-49
    // 稳定度决定了盗贼和动乱事件的可能性。
    this.stability = random.nextInt(_kLocationInitialStabilityMax)
    
    // 据点发展度，最高20，初始0
    // 发展度决定了据点所能拥有的普通居民人口上限，所能拥有建筑的数量，以及能产生的悬赏任务上限等
    // 发展度需要花费银两、矿石和木料来升级
    this.development = 0

    // 据点和人物类似，也具有金钱和物品栏
    this.money = 0
    this.inventory = {}

    // 当前处于这个场景的角色
    this.dwellingCharacterIds = []

    // 居住在这个场景的角色
    // this.residingCharacterIds = Set()

    // 在野角色
    this.residingCharacterIds = []

    // 大牢中的角色
    // 如果主角自己进入了监牢，则要通过监牢副本才能离开，并且离开后会进入本据点的敌对名单。
    // 另外两种选择是通过诉讼，或者贿赂离开
    this.jailedCharacterIds = []
    
    // 这个据点的建筑
    this.sites = {}

    // 这个地点的组织
    this.organizations = {}

    // 如果是盗贼营地或者洞天福地，则默认不会显示在地图上，并且也不会默认添加民居
    // 隐藏的洞天会显示为山峰，但隐藏的福地只有被发现后才会出现岛屿，之前就是普通的水面
    if (!isHidden) {
      Site(category: kSiteResidence, locationId: this.id)
      // 普通居民决定了税收收入，以及外门弟子的数量
      // final minP = maxPopulationOfLocationDevelopment(this.development - 1)
      // final maxP = maxPopulationOfLocationDevelopment(this.development)
      // this.population = random.nextInt(maxP - minP) + minP
    }

    // 被禁止进入的名单，名单可能重叠
    // 一个人本身在名单上，但他的国家也可能在名单上，并且互相独立
    this.banLists = {
      characterIds: [],
      organizationIds: [],
      nationIds: [],
    }

    // 敌对名单，遇到后将会直接开始战斗，战败会被投入监牢
    this.enemyLists = {
      characterIds: [],
      organizationIds: [],
      nationIds: [],
    }
  }
}

fun getLocationDistance(loc1, loc2) {
  return getTileDistance(loc1.tilePosition, loc2.tilePosition)
}

// 每个城市发展度，都会产生新的带有灵根的角色
// 但这些角色并不会立即出现，而是只能依靠探查搜寻的方式找到
// 并且每次找到的数量是有上限的
// fun maxPopulationOfLocationDevelopment(n: int) {
//   final base = (n - 1) * (n - 1) * (n - 1) * 50 + 100

//   return base
// }

fun maxSiteNumberOfLocationDevelopment(n: int) {
  return n + 2
}

/// 定期产生可供选择的有名有姓的人物作为内门弟子
/// 第一次出现时通常为练气境界
/// 产生的内门弟子数量，一开始是 1 个，最高是 8 个
/// 这个数量和外门弟子数量，修炼场的等级
/// 执行训练任务的长老属性和技能，等等都有关系
fun maxNumberOfWildCharacterPerDevelopment() {
  return n * n - n * 2 + 2
}

// 每个据点，每个月会自然增加人口，直到达到上限
// 人口上限会受到掌门的技能，门派的发展度和价值观，以及据点的发展度和建筑所影响
fun increaseLocationPopulationPerMonth(location) {

}

fun addLocation(loc) {
  game.locations[loc.id] = loc
}

fun addLocations(locs: List) {
  engine.info('载入地点数据')
  for (final loc in locs) {
    if (loc.nameId) {
      loc.name = getLocaleString(loc.nameId)
    }
    game.locations[loc.id] = loc
  }
}

fun setCharacterLocationId(character, locationId: str) {
  assert(game.locations.containsKey(locationId))
  if (character.locationId != null) {
    final oldLocation = game.locations[character.locationId]
    oldLocation.dwellingCharacterIds.remove(character.id)
  }
  final location = game.locations[locationId]
  location.dwellingCharacterIds.add(character.id)
  character.locationId = locationId
  character.tilePosition = {}
}

fun getLocationById(id: str) {
  return game.locations[id]
}

fun getLocations() {
  return game.locations
}

fun getLocationByPosition(left, top) {
  final tile = game.world.terrains[tilePos2Index(left, top, game.world.width)]
  if (tile.locationId)
  return game.locations[tile.locationId]
}

fun getLocationSiteById(location, siteId: str) {
  assert(location.sites.containsKey(siteId))
  return location.sites[siteId]
}

fun onEnteredLocation(id: str) {
  final entity = getEntityById(id)
  if (entity != null) {
    final handler = entity.onEntered
    if (handler is function) {
      handler()
    }
  }
}

fun onEnteredScene(id: str, [extra: str]) {
  final entity = getEntityById(id)
  if (entity != null) {
    final handler = entity.onEntered
    if (handler is function) {
      handler()
    }
  }
}
