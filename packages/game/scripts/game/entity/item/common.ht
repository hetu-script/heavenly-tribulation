import '../common.ht'
import '../effect.ht'

const kItemDefaultIcon = 'assets/images/unknown_item.png'
// final kDefaultItemDescription = getLocaleString('defaultItemDescription')

const kUnknownItemIcon = 'icon/unknown_item.png'

const kEquipTypeOffense = 'offense'
const kEquipTypeSupport = 'support'
const kEquipTypeDefense = 'defense'
const kEquipTypeCompanion = 'companion'
// const kEquipTypeArmor = 'armor'
// const kEquipTypeBoots = 'boots'
// const kEquipTypeManeuver = 'maneuver'

final kEquipmentMax = {
  offense: 5,
  support: 5,
  defense: 4,
  companion: 4,
}

final kRarity2ItemLevels = {
  common: 10, // common 白
  uncommon: 20, // uncommon 灰
  rare: 30, // rare 蓝
  epic: 40, // epic 紫
  legendary: 50, // legendary 橙
  mythic: 60, // mythic 金
  exotic: 70, // exotic 虹
}

fun calculateItemStats(item) {
  item.stats = item.attributes.clone()
}

fun characterAcquireMoney(character, value) {
  assert(value > 0)
  character.money += value
  final incidentContent = getLocaleString('characterAcquireMoney', [ character.name, value ])
  Incident(
    content: incidentContent,
    subjectIds: character.isMajorCharacter ? [character.id] : null,
    isPrivate: true,
  )
}

// 角色获得物品，此函数并不检查物品本身是否在其他角色的物品栏中
// 主要用于获取一个本来不存在的物品
// 如果数量大于1，则必须指定获取数量，item的stackSize将会被忽略
fun characterAcquire(character, item, [n = 1]) {
  if (item.stackSize > 1) {
    engine.warning('物品对象的数量[${item.stackSize}]将会被忽略。实际获取数值应该由[characterAcquire]函数的第三个参数指定。')
  }
  var incidentContent
  if (item.rarity == kCommon) {
    if (character.inventory.containsKey(item.id)) {
      // 因为普通物品可以堆叠，也可以重复存在，因此这里要从inventory取，而不要直接修改item
      character.inventory[item.id].stackSize += n
    } else {
      item.stackSize = n
      character.inventory[item.id] = item
    }
    incidentContent = getLocaleString('characterAcquireCommonItem', [
      character.name,
      n,
      item.name,
    ])
  } else {
    assert(n == 1)
    item.stackSize = n
    character.inventory[item.id] = item
    incidentContent = getLocaleString('characterAcquireItem', [
      character.name,
      item.name,
    ])
  }
  Incident(
    content: incidentContent,
    subjectIds: character.isMajorCharacter ? [character.id] : null,
    isPrivate: true,
  )
}

fun characterGiveMoney(char1, char2, value) {
  assert(char1.money >= value && value > 0)
  char1.money -= value
  char2.money += value
  final incidentContent = getLocaleString('characterGiveMoney', [
    char1.name,
    value,
    char2.name,
  ])
  Incident(
    content: incidentContent,
    subjectIds: char1.isMajorCharacter ? [char1.id] : null,
    objectIds: char2.isMajorCharacter ? [char2.id] : null,
    isPrivate: true,
  )
}

fun characterGive(char1, char2, item, [n = 1]) {
  assert(char1.inventory.containsKey(item.id))
  final char1Item = char1.inventory[item.id]
  if (char1Item.equippedPosition) characterUnequip(char1Item, char1)
  var incidentContent
  if (char1Item.rarity == kCommon) {
    var actualNumber = n
    if (char1Item.stackSize > n) {
      char1Item.stackSize -= n
    } else if (char1Item.stackSize <= n) {
      // char1身上的数量不够支付n
      actualNumber = char1Item.stackSize
      engine.warning('${char1.name} 身上的 ${item.name} 数量不够 ${n}，实际交付数量：${actualNumber}')
      delete char1.inventory[item.id]
    }
    if (char2.inventory.containsKey(item.id)) {
      char2.inventory[item.id].stackSize += n
    } else {
      final itemCopy = char1Item.clone()
      itemCopy.stackSize = actualNumber
      char2.inventory[itemCopy.id] = itemCopy
    }
    incidentContent = getLocaleString('characterGiveCommonItem', [
      char1.name,
      n,
      item.name,
      char2.name,
    ])
  } else {
    assert(n == 1)
    delete char1.inventory[item.id]
    char2.inventory[item.id] = item
    incidentContent = getLocaleString('characterGiveItem', [
      char1.name,
      item.name,
      char2.name,
    ])
  }
  Incident(
    content: incidentContent,
    subjectIds: char1.isMajorCharacter ? [char1.id] : null,
    objectIds: char2.isMajorCharacter ? [char2.id] : null,
    isPrivate: true,
  )
}

fun characterLearn(character, skill) {
  character.skills[skill.id] = skill
}

// 使用食物或者丹药
// 返回值代表是否使用成功
// 此函数允许对一个不在物品栏中的物品调用
fun characterConsume(character, item) {
  if (!item.isConsumable) {
    engine.warning('${item.name} 无法食用。')
    return false
  }

  if (character.inventory.containsKey(item.id)) {
    if (item.rarity == kCommon) {
      if (item.stackSize > 1) {
        --item.stackSize
      }
    } else {
      delete character.inventory[item.id]
    }
  }

  if (item.effects) {
    for (final effect in item.effects) {
      when (effect.name) {
        kEffectRestoreLife -> {
          character.stats.life += effect.values.first.value
        }
        kEffectRestoreChi -> {
          character.stats.chi += effect.values.first.value
        }
        kEffectRestoreStamina -> {
          character.stats.stamina += effect.values.first.value
        }
      }
    }
  }

  var incidentContent
  when (item.kind) {
    kEntityConsumableKindBeverage -> {
      incidentContent = getLocaleString('characterDrankBeverage', [
        character.name,
        item.name,
      ])
    }
    kEntityConsumableKindMedicine -> {
      incidentContent = getLocaleString('characterTakeMedicine', [
        character.name,
        item.name,
      ])
    }
    else -> {
      incidentContent = getLocaleString('characterAteFood', [
        character.name,
        item.name,
      ])
    }
  }

  Incident(
    content: incidentContent,
    subjectIds: [character.id],
    isPrivate: true,
  )
  
  return true
}

// 法宝和技能都可以装备，只要类型符合
// 返回值代表是否装备成功
// 如果对一个不在物品栏中的物品调用，会先将其加入物品栏
// 
// 装备并非直接将物品数据放在人物上，而是用下面的数据结构
// {
//   id,
//   entityType,
//   category,
//   kind,
//   equipType,
//   life,
//   supports,
// }
fun characterEquip(character, entity, { index }) -> bool {
  if (!entity.isEquippable) {
    engine.info('${entity.name} 无法装备。')
    return null
  }
  if (entity.equippedPosition) {
    engine.info('${entity.name} 已经在装备中了。')
    return null
  }
  var equipData = {
    id: entity.id,
    entityType: entity.entityType,
    category: entity.category, // 主类型：武器、斗技等
    kind: entity.kind, // 次类型：剑、拳法等
    equipType: entity.equipType,
  }
  when (entity.entityType) {
    kEntityTypeItem -> {
      if (!character.inventory[entity.id]) characterAcquire(character, entity)
      
      final incidentContent = getLocaleString('characterEquip', [
        character.name,
        entity.name,
      ])
      Incident(
        content: incidentContent,
        subjectIds: character.isMajorCharacter ? [character.id] : null,
        isPrivate: true,
      )
    }
    kEntityTypeSkill -> {
      if (!character.skills[entity.id]) characterLearn(character, entity)
      
      final incidentContent = getLocaleString('characterEquipSkill', [
        character.name,
        entity.name,
      ])
      Incident(
        content: incidentContent,
        subjectIds: character.isMajorCharacter ? [character.id] : null,
        isPrivate: true,
      )
    }
    kEntityTypeNpc, kEntityTypeCharacter -> {
      if (!entity.isBattleCompanion) {
        engine.warning('${entity.name} 不能设置为战斗伙伴。')
        return null
      }
      final companionData = character.companions.containsKey(entity.id) ?
        character.companions[entity.id] : characterGetCompanion(character, entity)
      // 战斗伙伴的装备数据中，对象类型和实际的对象类型不同
      equipData.entityType = kEntityTypeCompanion
      
      final incidentContent = getLocaleString('characterFollow', [
        entity.name,
        character.name,
      ])
      Incident(
        content: incidentContent,
        subjectIds: entity.isMajorCharacter ? [entity.id] : null,
        objectIds: character.isMajorCharacter ? [character.id] : null,
        isPrivate: true,
      )
    }
  }
  
  when (entity.equipType) {
    // 剑法、心诀等支持型技能
    kEquipTypeSupport -> {
      for (final i in range(1, kEquipmentMax.support)) {
        final oldEquipData = character.equipments[kEquipTypeOffense][i]
        if (oldEquipData && oldEquipData.category == data.category &&
            oldEquipData.kind == data.kind) {
          if (oldEquipData.supports.length < kEquipmentMax.support - 1) {
            oldEquipData.supports.add(equipData)
          } else {
            // 移除旧装备
            final oldEntity = getEquipped(oldEquipData.supports.first, character)
            delete oldEntity.equippedPosition
            oldEquipData.supports.first = equipData
          }
          entity.equippedPosition = i
          return true
        }
      }
      return false
    }
    // kEquipTypeOffense: 斗技、武器、攻击法宝等
    // kEquipTypeDefense: 内功、轻功、护甲、靴子、辅助法宝等
    kEquipTypeDefense, kEquipTypeOffense, kEquipTypeCompanion -> {
      equipData.supports = []
      // 如果有空位就装备在空位上
      if (!index) {
        for (final i in range(1, kEquipmentMax[entity.equipType])) {
          if (!character.equipments[entity.equipType][i]) {
            character.equipments[entity.equipType][i] = equipData
            entity.equippedPosition = i
            return true
          }
        }
        // 否则替换掉第一个空位
        index = 1
      }
      final oldEquipData = character.equipments[entity.equipType][1]
      final oldItem = getEquipped(equipData, character)
      delete oldItem.equippedPosition
      character.equipments[entity.equipType][index] = equipData
      if (equipData.category == oldItem.category && equipData.kind == oldItem.kind) {
        equipData.supports = oldEquipData.supports
      } else {
        for (final support in equipData.supports) {
          delete support.equippedPosition
        }
      }
      entity.equippedPosition = index
      return true
    }
  }

  return equipData
}

fun characterUnequip(character, entity) {
  assert(entity.equippedPosition != null)
  when (entity.equipType) {
    // 剑法、心诀等支持型技能
    kEquipTypeSupport -> {
      character.equipments[kEquipTypeOffense][entity.equippedPosition]
        .supports.removeWhere((equipData) => equipData.id == entity.id)
    }
    kEquipTypeCompanion -> {
      characterDismissCompanion(character, entity)
    }
    // 斗技、武器、法宝等
    kEquipTypeDefense, kEquipTypeOffense -> {
      delete character.equipments[entity.equipType][entity.equippedPosition]
    }
  }
}

fun getEquipped(equipData, character) {
  if (equipData == null) return null
  var entity
  when (equipData.entityType) {
    kEntityTypeItem -> {
      entity = character.inventory[equipData.id]
    }
    kEntityTypeSkill -> {
      entity = character.skills[equipData.id]
    }
    kEntityTypeCompanion -> {
      entity = character.companions[equipData.id]
    }
  }
  assert(entity != null)
  return entity
}

fun getFirstEquippedOffenseItem(character) {
  for (final i in range(1, kEquipmentMax.offense)) {
    final equipData = character.equipments.offense[i]
    if (equipData != null) {
      return getEquipped(equipData, character)
    }
  }
}
