import 'game.ht'
import 'names/names.ht' as names

external class MapComponent {
  static fun fromJson

  fun removeEntity(left: int, top: int) -> bool

  fun lightUpAroundTerrain(left: int, top: int)

  fun moveToTerrain(left: int, top: int)
}

fun loadWorldMap(jsonData) {
  print('河图: 载入世界地图数据 ...')
  final data = prototype.fromJson(jsonData)
  game.world = data
}

/// 生成世界地图的算法
///
/// spritesheet上不同地形对应的编号：
/// 0：虚空
/// 1：浅海
/// 2：深海
/// 3：陆地（草原）
///
/// 算法思路：
///
/// 先用海面填满整个地图空间
///
/// 根据地图大小以及陆地和水面的比例，得到应该生成多少块陆地
///
/// 找到一个出发点，通常在地图中间部分
///
/// 找到出发点周围的方块，将其加入一个数组，作为当前陆地的边界
///
/// 将当前方块变成陆地，检查陆地比例，如果不够，就从当前陆地边界中随机挑选一个方块，将其变成陆地，同时重新计算边界。

const _defaultWorldWidth = 16
const _defaultWorldHeight = 16
const _kSea = 1;
const _kShelf = 2;
const _kLand = 3;

fun createWorldMap({
      terrainSpriteSheet: str,
      tileShape = 'hexagonalVertical',
      width = _defaultWorldWidth,
      height = _defaultWorldHeight,
      style = 'island',
      landProportion = 0.35}) {

  final terrains = [];

  for (var j = 0; j < height; ++j) {
    for (var i = 0; i < width; ++i) {
      terrains.add({
        left: i + 1,
        top: j + 1,
        spriteIndex: _kSea,
      })
    }
  }

  // 坐标是否在地图范围内
  fun isPositionWithinMap(left, top) {
    return (left > 0 && top > 0 && left <= width && top <= height);
  }

  // 索引是否在地图范围内
  fun isIndexWithinMap(index) {
    return 0 <= index && index < terrains.length
  }

  // 从坐标得到索引
  fun tilePos2Index(left, top) {
    return left - 1 + (top - 1) * width
  }

  // 从索引得到坐标
  fun index2TilePos(index: str) {
    final i = int.parse(index)
    final left = i % width + 1
    final top = i ~/ width + 1
    return { left, top }
  }

  // 设置当前地块图像索引
  fun setSpriteIndex(index, value) {
    if (isIndexWithinMap(index)) {
      terrains[index]['spriteIndex'] = value;
    }
  }
  
  final shelf = {};
  
  fun getNeighbors(left, top) {
    final neighbors = []
    if (isPositionWithinMap(left - 1, top)) {
      neighbors.add({left: left - 1, top, index: tilePos2Index(left - 1, top)})
    }
    if (isPositionWithinMap(left, top - 1)) {
      neighbors.add({left, top: top - 1, index: tilePos2Index(left, top - 1)})
    }
    if (isPositionWithinMap(left + 1, top)) {
      neighbors.add({left: left + 1, top, index: tilePos2Index(left + 1, top)})
    }
    if (isPositionWithinMap(left, top + 1)) {
      neighbors.add({left, top: top + 1, index: tilePos2Index(left, top + 1)})
    }
    if (left % 2 == 0) {
      if (isPositionWithinMap(left + 1, top + 1)) {
        neighbors.add({left: left + 1, top: top + 1, index: tilePos2Index(left + 1, top + 1)})
      }
      if (isPositionWithinMap(left - 1, top + 1)) {
        neighbors.add({left: left - 1, top: top + 1, index: tilePos2Index(left - 1, top + 1)})
      }
    } else {
      if (isPositionWithinMap(left - 1, top - 1)) {
        neighbors.add({left: left - 1, top: top - 1, index: tilePos2Index(left - 1, top - 1)})
      }
      if (isPositionWithinMap(left + 1, top - 1)) {
        neighbors.add({left: left + 1, top: top - 1, index: tilePos2Index(left + 1, top - 1)})
      }
    }
    return neighbors
  }

  fun updateShelf(left, top) {
    final neighbors = getNeighbors(left, top)
    for (final pos in neighbors) {
      if (terrains[pos.index]['spriteIndex'] == 1) {
        shelf[pos.index] = true
      }
    }
  }

  final landArea = (width * height * landProportion).truncate()

  final minLeft = width ~/ 3
  final minTop = height ~/ 3
  final maxLeft = width ~/ 3 * 2
  final maxTop = height ~/ 3 * 2

  final startLeft = Math.randomInt(maxLeft - minLeft) + minLeft
  final startTop = Math.randomInt(maxTop - minTop) + minTop
  setSpriteIndex(tilePos2Index(startLeft, startTop), _kLand)
  updateShelf(startLeft, startTop)

  var currentLandSize = 1
  while (currentLandSize < landArea) {
    final shelfIndexes = shelf.keys;
    final randomIndex = shelfIndexes[Math.randomInt(shelfIndexes.length)]
    delete shelf[randomIndex]
    final pos = index2TilePos(randomIndex)
    final index = int.parse(randomIndex)
    setSpriteIndex(index, _kLand)
    updateShelf(pos.left, pos.top)
    ++currentLandSize
  }

  final zones = []

  // 新建一个区域，返回区域index，区域保存为一个列表
  fun newZone(kind) {
    final index = zones.length
    final zone = { index, kind, count: 1 }
    zones.add(zone)
    return zone
  }

  // 计算地图上的区域
  fun calculateZone(left, top) {
    final self = terrians[tilePos2Index(left, top)]
    final neighbors = getNeighbors(left, top)
    var isAdjacent = false
    for (final pos in neighbors) {
      final neighbor = terrains[pos.index]
      if (self.spriteIndex == tile.spriteIndex && tile.zoneIndex) {
        self.zoneIndex = tile.zoneIndex
        ++zones[tile.zoneIndex]['count']
        isAdjacent = true
        break;
      }
    }
    if (!isAdjacent) {
      final zone = newZone()
      self['zoneIndex'] = zone.index
    }
  }

  // for (final index in shelf.keys) {
  //   final i = int.parse(index)
  //   setTerrain(i, _kShelf)
  // }

  final data = {
    terrainSpriteSheet,
    tileShape,
    width,
    height,
    entry: {
      x: startLeft,
      y: startTop,
    },
    gridWidth: 32.0,
    gridHeight: 28.0,
    tileSpriteSrcWidth: 32.0,
    tileSpriteSrcHeight: 48.0,
    tileOffsetX: 0.0,
    tileOffsetY: 2.0,
    terrains,
    zones,
  }
  
  final future = MapComponent.fromJson(data.toJson())
  future.then((value) {
    game.world = value
  })
  return future
}

fun createMaze(data) {
  game.mazes.current = data
  final future = MapComponent.fromJson(data.toJson())
  future.then((value) {
    game.mazes.current.component = value
  })
  return future
}

fun addMazes(mazes) {
  if (game.debug) {
    print('河图: 载入副本数据 ...')
  }
  for (final maze in mazes) {
    game.mazes[maze.id] = maze
  }
}

fun getCurrentMaze() {
  return game.mazes.current;
}

fun getCurrentMazeComponent() {
  return game.mazes.current.component
}

fun getCurrentMazeData() {
  return game.mazes.current.toJson();
}

fun getMazeById(id: str) {
  return game.mazes[id]
}

fun getMazeDataById(id: str) {
  return game.mazes[id].toJson()
}

fun onEnteredMaze(id: str) {
  final maze = getMazeById(id)
  if (maze != null) {
    final handler = maze.onEntered
    if (handler is function) {
      handler()
    }
  }
}

fun handleTileInteraction(x: int, y: int) {
  final maze = getCurrentMaze()
  final component = getCurrentMazeComponent()

  final mapWidth = maze.width
  // print('mapWidth: ${mapWidth}')
  // print('x: ${x}')
  // print('y: ${y}')
  final tileIndex = x - 1 + (y - 1) * mapWidth
  // print('tileIndex: ${tileIndex}')
  // print('maze.terrains.length: ${maze.terrains.length}')
  final terrain = maze.terrains[tileIndex]
  final room = maze.rooms[tileIndex]
  final entity = maze.entities['${x},${y}']
  if (room > 0) {
    component.moveToTerrain(x, y)
    if (entity == null) {
      component.lightUpAroundTerrain(x, y)
    } else {
      final handler = entity.onTouched
      if (handler is function) {
        handler()
      }
    }
  }
}
