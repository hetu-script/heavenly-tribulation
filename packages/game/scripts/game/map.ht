import 'game.ht'
import 'random_names/random_names.ht' as random

external class MapComponent {
  static fun fromJson

  fun removeEntity(left: int, top: int) -> bool

  fun lightUpAroundTerrain(left: int, top: int)

  fun moveToTerrain(left: int, top: int)
}

const _defaultWorldWidth = 16
const _defaultWorldHeight = 16
const _kSea = 1;
const _kShelf = 2;
const _kLand = 3;


fun loadWorldMap(jsonData) {
  print('河图: 载入世界地图数据 ...')
  final data = prototype.fromJson(jsonData)
  game.world = data
}

/// 生成世界地图的算法
///
///
/// spritesheet上不同地形对应的编号：
/// 0：虚空
/// 1：浅海
/// 2：深海
/// 3：陆地（草原）
///
/// 算法思路：
///
/// 先用海面填满整个地图空间
///
/// 根据地图大小，计算出陆地和水面的比例，得到应该生成多少块陆地
///
/// 找到一个出发点，通常在地图中间部分
///
/// 找到出发点周围的方块，将其加入一个数组，作为当前陆地的边界
///
/// 将当前方块变成陆地。

fun createWorldMap({
      terrainSpriteSheet: str,
      tileShape = 'hexagonalVertical',
      width = _defaultWorldWidth,
      height = _defaultWorldHeight,
      style = 'island',
      landProportion = 0.35}) {

  final terrains = [];

  for (var j = 0; j < height; ++j) {
    for (var i = 0; i < width; ++i) {
      terrains.add(1)
    }
  }

  fun isPositionWithinMap(left, top) {
    return (left > 0 && top > 0 && left <= width && top <= height);
  }

  fun isIndexWithinMap(index) {
    return 0 <= index && index < terrains.length
  }

  fun tilePos2Index(left, top) {
    return left - 1 + (top - 1) * width
  }

  fun index2TilePos(index: str) {
    final i = int.parse(index)
    final left = i % width + 1
    final top = i ~/ width + 1
    return { left, top }
  }

  fun setTerrain(index, value) {
    if (isIndexWithinMap(index)) {
      terrains[index] = value;
    }
  }
  
  final landShelf = {};
  
  fun getNeighbors(left, top) {
    final neighbors = []
    if (isPositionWithinMap(left - 1, top)) {
      neighbors.add({left: left - 1, top})
    }
    if (isPositionWithinMap(left, top - 1)) {
      neighbors.add({left, top: top - 1})
    }
    if (isPositionWithinMap(left + 1, top)) {
      neighbors.add({left: left + 1, top})
    }
    if (isPositionWithinMap(left, top + 1)) {
      neighbors.add({left, top: top + 1})
    }
    if (left % 2 == 0) {
      if (isPositionWithinMap(left + 1, top + 1)) {
        neighbors.add({left: left + 1, top: top + 1})
      }
      if (isPositionWithinMap(left - 1, top + 1)) {
        neighbors.add({left: left - 1, top: top + 1})
      }
    } else {
      if (isPositionWithinMap(left - 1, top - 1)) {
        neighbors.add({left: left - 1, top: top - 1})
      }
      if (isPositionWithinMap(left + 1, top - 1)) {
        neighbors.add({left: left + 1, top: top - 1})
      }
    }
    return neighbors
  }

  fun updateNeighbors(left, top) {
    final neighbors = getNeighbors(left, top)
    for (final pos in neighbors) {
      final index = tilePos2Index(pos.left, pos.top)
      if (terrains[index] == 1) {
        landShelf[index] = true
      }
    }
  }

  final landArea = (width * height * landProportion).truncate()

  final minLeft = width ~/ 3
  final minTop = height ~/ 3
  final maxLeft = width ~/ 3 * 2
  final maxTop = height ~/ 3 * 2

  final startLeft = Math.randomInt(maxLeft - minLeft) + minLeft
  final startTop = Math.randomInt(maxTop - minTop) + minTop
  setTerrain(tilePos2Index(startLeft, startTop), _kLand)
  updateNeighbors(startLeft, startTop)

  var currentLandSize = 1
  while (currentLandSize < landArea) {
    final shelfIndexes = landShelf.keys;
    final randomIndex = shelfIndexes[Math.randomInt(shelfIndexes.length)]
    delete landShelf[randomIndex]
    final pos = index2TilePos(randomIndex)
    final index = int.parse(randomIndex)
    setTerrain(index, _kLand)
    updateNeighbors(pos.left, pos.top)
    ++currentLandSize
  }

  for (final index in landShelf.keys) {
    final i = int.parse(index)
    setTerrain(i, _kShelf)
  }

  final zones = []

  fun newZone() {
    final id = zones.length
    final zone = {}
    zones.add(zone)
    return id
  }

  fun checkZone(left, top) {
    final neighbors = getNeighbors(left, top)
    for (final pos in neighbors) {
      
    }
  }

  for (var i = 0; i < terrains.length; ++i) {
    
  }

  final data = {
    terrainSpriteSheet,
    tileShape,
    width,
    height,
    entry: {
      x: startLeft,
      y: startTop,
    },
    gridWidth: 32.0,
    gridHeight: 28.0,
    tileSpriteSrcWidth: 32.0,
    tileSpriteSrcHeight: 48.0,
    tileOffsetX: 0.0,
    tileOffsetY: 2.0,
    terrains,
    zones,
  }
  
  final future = MapComponent.fromJson(data.toJson())
  future.then((value) {
    game.world = value
  })
  return future
}

fun createMaze(data) {
  game.mazes.current = data
  final future = MapComponent.fromJson(data.toJson())
  future.then((value) {
    game.mazes.current.component = value
  })
  return future
}

fun addMazes(mazes) {
  if (game.debug) {
    print('河图: 载入副本数据 ...')
  }
  for (final maze in mazes) {
    game.mazes[maze.id] = maze
  }
}

fun getCurrentMaze() {
  return game.mazes.current;
}

fun getCurrentMazeComponent() {
  return game.mazes.current.component
}

fun getCurrentMazeData() {
  return game.mazes.current.toJson();
}

fun getMazeById(id: str) {
  return game.mazes[id]
}

fun getMazeDataById(id: str) {
  return game.mazes[id].toJson()
}

fun onEnteredMaze(id: str) {
  final maze = getMazeById(id)
  if (maze != null) {
    final handler = maze.onEntered
    if (handler is function) {
      handler()
    }
  }
}

fun handleTileInteraction(x: int, y: int) {
  final maze = getCurrentMaze()
  final component = getCurrentMazeComponent()

  final mapWidth = maze.width
  // print('mapWidth: ${mapWidth}')
  // print('x: ${x}')
  // print('y: ${y}')
  final tileIndex = x - 1 + (y - 1) * mapWidth
  // print('tileIndex: ${tileIndex}')
  // print('maze.terrains.length: ${maze.terrains.length}')
  final terrain = maze.terrains[tileIndex]
  final room = maze.rooms[tileIndex]
  final entity = maze.entities['${x},${y}']
  if (room > 0) {
    component.moveToTerrain(x, y)
    if (entity == null) {
      component.lightUpAroundTerrain(x, y)
    } else {
      final handler = entity.onTouched
      if (handler is function) {
        handler()
      }
    }
  }
}
