import 'game.ht'
import 'generator/tilemap/hexagonal_tile.ht'

export 'generator/tilemap/worldmap.ht'
export 'generator/tilemap/maze.ht'

fun loadWorldMap(jsonData) {
  print('河图: 载入世界地图数据 ...')
  final data = prototype.fromJson(jsonData)
  game.world = data
}

fun handleWorldEntityInteraction(x: int, y: int) {
  final component = game.world.component
}

fun addMazes(mazes) {
  if (game.debug) {
    print('河图: 载入副本数据 ...')
  }
  for (final maze in mazes) {
    game.mazes[maze.id] = maze
  }
}

fun getCurrentMazeData() {
  return game.mazes.current.toJson();
}

fun getMazeById(id: str) {
  return game.mazes[id]
}

fun getMazeDataById(id: str) {
  return game.mazes[id].toJson()
}

fun onEnteredMaze(id: str) {
  final maze = getMazeById(id)
  if (maze != null) {
    final handler = maze.onEntered
    if (handler is function) {
      handler()
    }
  }
}

fun handleMazeTileInteraction(x: int, y: int) {
  final maze = game.mazes.current
  final component = game.mazes.current.component

  final mapWidth = maze.width
  // print('mapWidth: ${mapWidth} ')
  // print('x: ${x}')
  // print('y: ${y}')
  final tileIndex = x - 1 + (y - 1) * mapWidth
  // print('tileIndex: ${tileIndex}')
  // print('maze.terrains.length: ${maze.terrains.length}')
  final terrain = maze.terrains[tileIndex]
  final room = maze.rooms[tileIndex]
  final entity = maze.entities['${x},${y}']
  if (room > 0) {
    component.moveToTerrain(x, y)
    if (entity == null) {
      component.lightUpAroundTerrain(x, y)
    } else {
      final handler = entity.onTouched
      if (handler is function) {
        handler()
      }
    }
  }
}

fun getZonesData() {
  return game.world.zones.toJson()
}

// 从 hexagonal 坐标得到索引
fun tilePos2Index(left, top, width) {
  return left - 1 + (top - 1) * width
}

// 从索引得到 hexagonal 坐标
fun index2TilePos(index: int, width: int) {
  final left = index % width + 1
  final top = index ~/ width + 1
  return Tile(left, top)
}

// 坐标是否在地图范围内
fun isPositionWithinMap(left, top, width, height) {
  return (left > 0 && top > 0 && left <= width && top <= height)
}

fun getTerrain(left, top, { data }) {
  data ??= game.world
  return data.terrains[tilePos2Index(left, top, data.width)]
}

// 获取相邻并且在地图范围内的格子
// 如果 [restrict2Zone] 为 true，则只会返回和起点所在 tile 具有相同 zoneIndex 的格子
// 如果指定了方向
// 必须 apply 或者 bind 到某个 world data 对象上才可以使用
fun getMapTileNeighbors(left: int, top: int, {restrict2Zone: bool = false, data}) {
  data ??= game.world
  assert(isPositionWithinMap(left, top, data.width, data.height))
  final origin = data.terrains[tilePos2Index(left, top, data.width)]
  final neighbors = []
  // 奇数列
  if (left % 2 != 0) {
    // 上面
    if (isPositionWithinMap(left, top - 1, data.width, data.height)) {
      final tile = data.terrains[tilePos2Index(left, top - 1, data.width)]
      if (!restrict2Zone || origin.zoneIndex == tile.zoneIndex) {
        neighbors.add(tile)
      }
    }
    // 下面
    if (isPositionWithinMap(left, top + 1, data.width, data.height)) {
      final tile = data.terrains[tilePos2Index(left, top + 1, data.width)]
      if (!restrict2Zone || origin.zoneIndex == tile.zoneIndex) {
        neighbors.add(tile)
      }
    }
    // 左上
    if (isPositionWithinMap(left - 1, top - 1, data.width, data.height)) {
      final tile = data.terrains[tilePos2Index(left - 1, top - 1, data.width)]
      if (!restrict2Zone || origin.zoneIndex == tile.zoneIndex) {
        neighbors.add(tile)
      }
    }
    // 左下
    if (isPositionWithinMap(left - 1, top, data.width, data.height)) {
      final tile = data.terrains[tilePos2Index(left - 1, top, data.width)]
      if (!restrict2Zone || origin.zoneIndex == tile.zoneIndex) {
        neighbors.add(tile)
      }
    }
    // 右上
    if (isPositionWithinMap(left + 1, top - 1, data.width, data.height)) {
      final tile = data.terrains[tilePos2Index(left + 1, top - 1, data.width)]
      if (!restrict2Zone || origin.zoneIndex == tile.zoneIndex) {
        neighbors.add(tile)
      }
    }
    // 右下
    if (isPositionWithinMap(left + 1, top, data.width, data.height)) {
      final tile = data.terrains[tilePos2Index(left + 1, top, data.width)]
      if (!restrict2Zone || origin.zoneIndex == tile.zoneIndex) {
        neighbors.add(tile)
      }
    }
  }
  // 欧数列
  else {
    // 上面
    if (isPositionWithinMap(left, top - 1, data.width, data.height)) {
      final tile = data.terrains[tilePos2Index(left, top - 1, data.width)]
      if (!restrict2Zone || origin.zoneIndex == tile.zoneIndex) {
        neighbors.add(tile)
      }
    }
    // 下面
    if (isPositionWithinMap(left, top + 1, data.width, data.height)) {
      final tile = data.terrains[tilePos2Index(left, top + 1, data.width)]
      if (!restrict2Zone || origin.zoneIndex == tile.zoneIndex) {
        neighbors.add(tile)
      }
    }
    // 左上
    if (isPositionWithinMap(left - 1, top, data.width, data.height)) {
      final tile = data.terrains[tilePos2Index(left - 1, top, data.width)]
      if (!restrict2Zone || origin.zoneIndex == tile.zoneIndex) {
        neighbors.add(tile)
      }
    }
    // 左下
    if (isPositionWithinMap(left - 1, top + 1, data.width, data.height)) {
      final tile = data.terrains[tilePos2Index(left - 1, top + 1, data.width)]
      if (!restrict2Zone || origin.zoneIndex == tile.zoneIndex) {
        neighbors.add(tile)
      }
    }
    // 右上
    if (isPositionWithinMap(left + 1, top, data.width, data.height)) {
      final tile = data.terrains[tilePos2Index(left + 1, top, data.width)]
      if (!restrict2Zone || origin.zoneIndex == tile.zoneIndex) {
        neighbors.add(tile)
      }
    }
    // 右下
    if (isPositionWithinMap(left + 1, top + 1, data.width, data.height)) {
      final tile = data.terrains[tilePos2Index(left + 1, top + 1, data.width)]
      if (!restrict2Zone || origin.zoneIndex == tile.zoneIndex) {
        neighbors.add(tile)
      }
    }
  }
  return neighbors
}

// hScore(n) 是曼哈顿距离时的 A* 算法
fun calculateRoute(start, end, { data }) {
  data ??= game.world
  // print('calculating route: ${start.left},${start.top} to ${end.left},${end.top}')

  assert(start.zoneIndex > 0)
  assert(end.zoneIndex > 0)
  assert(start.index != end.index)
  final zone1 = data.zones[start.zoneIndex]
  final zone2 = data.zones[end.zoneIndex]

  // g(n): 原点到该点的距离
  final gScore = {}
  gScore[start.index] = 0
  // h(n): 该点到终点的距离
  final hScore = {}
  hScore[start.index] = getTileDistance(start, end)
  // f(n) = g(n) + h(n)
  final fScore = {}
  fScore[start.index] = hScore[start.index]

  // 节点返回路径，每个 key 对应的 value 代表了 key 的坐标的上一步骤的坐标
  final cameFrom = {}
  fun reconstructPath(cameFrom, current) {
    final from = cameFrom[current]
    if (from) {
      final path = reconstructPath(cameFrom, from)
      return [ ...path, current ]
    } else {
      return [ current ]
    }
  }
  // 已被计算的坐标
  final closed = []
  // 将要计算的坐标, key 是 tile index，value 是 离起点的距离
  final open = []
  open.add(start.index)
  final distance = getTileDistance(start, end)
  // 两个据点在相同地域
  if (zone1.index == zone2.index) {
    // route = {
    //   startLeft: start.left,
    //   startTop: start.top,
    //   path: []
    // }
    while (open.isNotEmpty) {
      // 找到 f(x) 最小的节点
      open.sort((t1, t2) => fScore[t1].compareTo(fScore[t2]))
      final nextIndex = open.first
      final next = index2TilePos(nextIndex, data.width)
      if (nextIndex == end.index) {
        // route.path = reconstructPath(cameFrom, end.index)
        final route = reconstructPath(cameFrom, end.index)
        // print(route)
        return route
      }
      open.remove(nextIndex)
      closed.add(nextIndex)
      final neighbors = getMapTileNeighbors(next.left, next.top, restrict2Zone: true, data: data)
      for (final neighbor in neighbors) {
        if (closed.contains(neighbor.index)) continue
        final tentetiveGScore = gScore[nextIndex] + 1
        var tentativelyBetter = false
        if (!open.contains(neighbor.index) || (tentetiveGScore < gScore[neighbor.index])) {
          tentativelyBetter = true
        }
        if (tentativelyBetter) {
          cameFrom[neighbor.index] = nextIndex
          gScore[neighbor.index] = tentetiveGScore
          hScore[neighbor.index] = getTileDistance(neighbor, end)
          fScore[neighbor.index] = gScore[neighbor.index] + hScore[neighbor.index]
          if (!open.contains(neighbor.index)) {
            open.add(neighbor.index)
          }
        }
      }
    }
  }
  return null
}
