import 'game.ht'

external class MapComponent {
  static fun fromJson

  fun removeEntity(left: int, top: int) -> bool

  fun lightUpAroundTerrain(left: int, top: int)

  fun moveToTerrain(left: int, top: int)
}

const _defaultWorldWidth = 24
const _defaultWorldHeight = 24
const _kSea = 1;
const _kShelf = 2;
const _kLand = 3;


fun loadWorldMap(jsonData) {
  print('河图: 载入世界地图数据 ...')
  final data = prototype.fromJson(jsonData)
  game.world = data
}

/// 生成世界地图的算法
///
///
/// spritesheet上不同地形对应的编号：
/// 0：虚空
/// 1：浅海
/// 2：深海
/// 3：陆地（草原）
///
/// 算法思路：
///
/// 先用海面填满整个地图空间
///
/// 根据地图大小，计算出陆地和水面的比例，得到应该生成多少块陆地
///
/// 找到一个出发点，通常在地图中间部分
///
/// 找到出发点周围的方块，将其加入一个数组，作为当前陆地的边界
///
/// 将当前方块变成陆地。

fun createWorldMap({
      terrainSpriteSheet: str,
      tileShape = 'hexagonalVertical',
      width = _defaultWorldWidth,
      height = _defaultWorldHeight,
      style = 'island',
      landProportion = 0.8}) {

  final terrains = [];

  for (var j = 0; j < height; ++j) {
    for (var i = 0; i < width; ++i) {
      terrains.add(1)
    }
  }

  fun isPositionWithinMap(left, top) {
    return (left > 0 && top > 0 && left <= width && top <= height);
  }

  fun tilePos2Index(left, top) {
    return left - 1 + (top - 1) * width
  }

  fun setTerrain(index, value) {
    if (0 < index && index < terrains.length) {
      terrains[index] = value;
    }
  }
  
  final neighbors = {};

  fun updateNeighbors(left, top) {
    if (isPositionWithinMap(left - 1, top)) {
      neighbors[tilePos2Index(left - 1, top)] = true
    }
    if (isPositionWithinMap(left, top - 1)) {
      neighbors[tilePos2Index(left, top - 1)] = true
    }
    if (isPositionWithinMap(left + 1, top)) {
      neighbors[tilePos2Index(left + 1, top)] = true
    }
    if (isPositionWithinMap(left, top + 1)) {
      neighbors[tilePos2Index(left, top + 1)] = true
    }
    if (isPositionWithinMap(left - 1, top + 1)) {
      neighbors[tilePos2Index(left - 1, top + 1)] = true
    }
    if (isPositionWithinMap(left + 1, top + 1)) {
      neighbors[tilePos2Index(left + 1, top + 1)] = true
    }
  }

  final landArea = (width * height * landProportion).truncate()

  final minLeft = width ~/ 3
  final minTop = height ~/ 3
  final maxLeft = width ~/ 3 * 2
  final maxTop = height ~/ 3 * 2

  final startLeft = Math.randomInt(maxLeft - minLeft) + minLeft
  final startTop = Math.randomInt(maxTop - minTop) + minTop
  setTerrain(tilePos2Index(startLeft, startTop), _kLand)
  updateNeighbors(startLeft, startTop)

  var currentLandSize = 1
  while (currentLandSize < landArea) {
    final neibhborIndexes = neighbors.keys;
    // print(neibhborIndexes)
    final randomIndex = neibhborIndexes[Math.randomInt(neibhborIndexes.length)]
    delete neighbors[randomIndex]
    final index = int.parse(randomIndex)
    final left = index % width + 1
    final top = index ~/ width + 1
    setTerrain(index, _kLand)
    updateNeighbors(left, top)
    ++currentLandSize
  }

  final data = {
    terrainSpriteSheet,
    tileShape,
    width,
    height,
    entry: {
      x: startLeft,
      y: startTop,
    },
    gridWidth: 32.0,
    gridHeight: 28.0,
    tileSpriteSrcWidth: 32.0,
    tileSpriteSrcHeight: 48.0,
    tileOffsetX: 0.0,
    tileOffsetY: 2.0,
    terrains,
    zones: {

    },
  }
  
  final future = MapComponent.fromJson(data.toJson())
  future.then((value) {
    game.world = value
  })
  return future
}

fun createMaze(data) {
  game.mazes.current = data
  final future = MapComponent.fromJson(data.toJson())
  future.then((value) {
    game.mazes.current.component = value
  })
  return future
}

fun addMazes(mazes) {
  if (game.debug) {
    print('河图: 载入副本数据 ...')
  }
  for (final maze in mazes) {
    game.mazes[maze.id] = maze
  }
}

fun getCurrentMaze() {
  return game.mazes.current;
}

fun getCurrentMazeComponent() {
  return game.mazes.current.component
}

fun getCurrentMazeData() {
  return game.mazes.current.toJson();
}

fun getMazeById(id: str) {
  return game.mazes[id]
}

fun getMazeDataById(id: str) {
  return game.mazes[id].toJson()
}

fun onEnteredMaze(id: str) {
  final maze = getMazeById(id)
  if (maze != null) {
    final handler = maze.onEntered
    if (handler is function) {
      handler()
    }
  }
}

fun handleTileInteraction(x: int, y: int) {
  final maze = getCurrentMaze()
  final component = getCurrentMazeComponent()

  final mapWidth = maze.width
  // print('mapWidth: ${mapWidth}')
  // print('x: ${x}')
  // print('y: ${y}')
  final tileIndex = x - 1 + (y - 1) * mapWidth
  // print('tileIndex: ${tileIndex}')
  // print('maze.terrains.length: ${maze.terrains.length}')
  final terrain = maze.terrains[tileIndex]
  final room = maze.rooms[tileIndex]
  final entity = maze.entities['${x},${y}']
  if (room > 0) {
    component.moveToTerrain(x, y)
    if (entity == null) {
      component.lightUpAroundTerrain(x, y)
    } else {
      final handler = entity.onTouched
      if (handler is function) {
        handler()
      }
    }
  }
}
