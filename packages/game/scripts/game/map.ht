import 'game.ht'
import 'generator/tilemap/hexagonal_tile.ht'

fun loadWorldMap(jsonData) {
  engine.info('载入世界地图数据')
  final data = prototype.fromJson(jsonData)
  game.world = data
}

fun handleWorldEntityInteraction(x: int, y: int) {
  final component = game.world.component
}

fun addMazes(mazes) {
  engine.info('载入副本数据')
  for (final maze in mazes) {
    game.mazes[maze.id] = maze
  }
}

fun getMazeById(id: str) {
  return game.mazes[id]
}

fun onEnteredMaze(id: str) {
  final maze = getMazeById(id)
  if (maze != null) {
    final handler = maze.onEntered
    if (handler is function) {
      handler()
    }
  }
}

fun handleMazeTileInteraction(x: int, y: int) {
  final maze = game.mazes.current
  final component = game.mazes.current.component

  final mapWidth = maze.width
  // print('mapWidth: ${mapWidth} ')
  // print('x: ${x}')
  // print('y: ${y}')
  final tileIndex = x - 1 + (y - 1) * mapWidth
  // print('tileIndex: ${tileIndex}')
  // print('maze.terrains.length: ${maze.terrains.length}')
  final terrain = maze.terrains[tileIndex]
  final room = maze.rooms[tileIndex]
  final entity = maze.entities['${x},${y}']
  if (room > 0) {
    component.moveToTerrain(x, y)
    if (entity == null) {
      component.lightUpAroundTerrain(x, y)
    } else {
      final handler = entity.onTouched
      if (handler is function) {
        handler()
      }
    }
  }
}

// 从 hexagonal 坐标得到索引
fun tilePos2Index(left, top) {
  return left - 1 + (top - 1) * game.world.width
}

// 从索引得到 hexagonal 坐标
fun index2TilePos(index: int) {
  final left = index % game.world.width + 1
  final top = index ~/ game.world.width + 1
  return Tile(left, top)
}

// 坐标是否在地图范围内
fun isPositionWithinMap(left, top) {
  return (left > 0 && top > 0 && left <= game.world.width && top <= game.world.height)
}

fun getWorld() {
  return game.world
}

fun getTerrain(left, top) {
  return game.world.terrains[tilePos2Index(left, top, game.world.width)]
}

fun getZoneByIndex(index: int) {
  return game.world.zones[index]
}

// 获取相邻并且在地图范围内的格子
// 如果 [restricted2Zone] 为 true，则只会返回和起点所在 tile 具有相同 zoneIndex 的格子
// 如果指定了方向
// 必须 apply 或者 bind 到某个 world data 对象上才可以使用
fun getMapTileNeighbors(left: int, top: int, {restricted2Zone}) {
  assert(isPositionWithinMap(left, top, game.world.width, game.world.height))
  final origin = game.world.terrains[tilePos2Index(left, top, game.world.width)]
  final neighbors = []

  fun add2Neighbors(tile) {
    if (!restricted2Zone || tile.zoneIndex == restricted2Zone ||
      (tile.isHarbor && tile.harborOfZoneIndex == origin.zoneIndex) || 
      (origin.isHarbor && origin.harborOfZoneIndex == tile.zoneIndex)) {
      neighbors.add(tile)
    }
  }

  // 奇数列
  if (left % 2 != 0) {
    // 上面
    if (isPositionWithinMap(left, top - 1, game.world.width, game.world.height)) {
      final tile = game.world.terrains[tilePos2Index(left, top - 1, game.world.width)]
      add2Neighbors(tile)
    }
    // 下面
    if (isPositionWithinMap(left, top + 1, game.world.width, game.world.height)) {
      final tile = game.world.terrains[tilePos2Index(left, top + 1, game.world.width)]
      add2Neighbors(tile)
    }
    // 左上
    if (isPositionWithinMap(left - 1, top - 1, game.world.width, game.world.height)) {
      final tile = game.world.terrains[tilePos2Index(left - 1, top - 1, game.world.width)]
      add2Neighbors(tile)
    }
    // 左下
    if (isPositionWithinMap(left - 1, top, game.world.width, game.world.height)) {
      final tile = game.world.terrains[tilePos2Index(left - 1, top, game.world.width)]
      add2Neighbors(tile)
    }
    // 右上
    if (isPositionWithinMap(left + 1, top - 1, game.world.width, game.world.height)) {
      final tile = game.world.terrains[tilePos2Index(left + 1, top - 1, game.world.width)]
      add2Neighbors(tile)
    }
    // 右下
    if (isPositionWithinMap(left + 1, top, game.world.width, game.world.height)) {
      final tile = game.world.terrains[tilePos2Index(left + 1, top, game.world.width)]
      add2Neighbors(tile)
    }
  }
  // 欧数列
  else {
    // 上面
    if (isPositionWithinMap(left, top - 1, game.world.width, game.world.height)) {
      final tile = game.world.terrains[tilePos2Index(left, top - 1, game.world.width)]
      add2Neighbors(tile)
    }
    // 下面
    if (isPositionWithinMap(left, top + 1, game.world.width, game.world.height)) {
      final tile = game.world.terrains[tilePos2Index(left, top + 1, game.world.width)]
      add2Neighbors(tile)
    }
    // 左上
    if (isPositionWithinMap(left - 1, top, game.world.width, game.world.height)) {
      final tile = game.world.terrains[tilePos2Index(left - 1, top, game.world.width)]
      add2Neighbors(tile)
    }
    // 左下
    if (isPositionWithinMap(left - 1, top + 1, game.world.width, game.world.height)) {
      final tile = game.world.terrains[tilePos2Index(left - 1, top + 1, game.world.width)]
      add2Neighbors(tile)
    }
    // 右上
    if (isPositionWithinMap(left + 1, top, game.world.width, game.world.height)) {
      final tile = game.world.terrains[tilePos2Index(left + 1, top, game.world.width)]
      add2Neighbors(tile)
    }
    // 右下
    if (isPositionWithinMap(left + 1, top + 1, game.world.width, game.world.height)) {
      final tile = game.world.terrains[tilePos2Index(left + 1, top + 1, game.world.width)]
      add2Neighbors(tile)
    }
  }
  return neighbors
}

// hScore(n) 是曼哈顿距离时的 A* 算法
fun calculateRoute(start, end, { zoneIndex }) {
  // print('calculating route: ${start.left},${start.top} to ${end.left},${end.top}')

  assert(start.zoneIndex > 0)
  assert(end.zoneIndex > 0)
  assert(start.index != end.index)
  final zone1 = game.world.zones[start.zoneIndex]
  final zone2 = game.world.zones[end.zoneIndex]

  // g(n): 原点到该点的距离
  final gScore = {}
  gScore[start.index] = 0
  // h(n): 该点到终点的距离
  final hScore = {}
  hScore[start.index] = getTileDistance(start, end)
  // f(n) = g(n) + h(n)
  final fScore = {}
  fScore[start.index] = hScore[start.index]

  // 节点返回路径，每个 key 对应的 value 代表了 key 的坐标的上一步骤的坐标
  final cameFrom = {}
  fun reconstructPath(cameFrom, current) {
    final from = cameFrom[current]
    if (from) {
      final path = reconstructPath(cameFrom, from)
      return [ ...path, current ]
    } else {
      return [ current ]
    }
  }
  // 已被计算的坐标
  final closed = []
  // 将要计算的坐标, key 是 tile index，value 是 离起点的距离
  final open = []
  open.add(start.index)
  final distance = getTileDistance(start, end)
  var restricted2Zone
  // if (start.zoneIndex == end.zoneIndex) {
  //   // 两个据点在相同地域
  //   // print('same zone: ${start.zoneIndex}')
    // restricted2Zone = start.zoneIndex
  // } else if (start.isHarbor && start.harborOfZoneIndex == end.zoneIndex) {
  //   // 起点是港口
  //   // print('start is harbor of zone: ${end.zoneIndex}')
  //   restricted2Zone = end.zoneIndex
  // } else if (end.isHarbor && end.harborOfZoneIndex == start.zoneIndex) {
  //   // 终点是港口
  //   // print('end is harbor of zone: ${start.zoneIndex}')
  //   restricted2Zone = start.zoneIndex
  // } else {
  //   // 不是相同地域并且终点和起点都不是港口
  //   return null
  // }
  // route = {
  //   startLeft: start.left,
  //   startTop: start.top,
  //   path: []
  // }
  while (open.isNotEmpty) {
    // 找到 f(x) 最小的节点
    open.sort((t1, t2) => fScore[t1].compareTo(fScore[t2]))
    final nextIndex = open.first
    final next = index2TilePos(nextIndex, game.world.width)
    if (nextIndex == end.index) {
      // route.path = reconstructPath(cameFrom, end.index)
      final route = reconstructPath(cameFrom, end.index)
      // print(route)
      return route
    }
    open.remove(nextIndex)
    closed.add(nextIndex)
    final neighbors = getMapTileNeighbors(next.left, next.top, restricted2Zone: restricted2Zone)
    for (final neighbor in neighbors) {
      if (closed.contains(neighbor.index)) continue
      final tentetiveGScore = gScore[nextIndex] + 1
      var tentativelyBetter = false
      if (!open.contains(neighbor.index) || (tentetiveGScore < gScore[neighbor.index])) {
        tentativelyBetter = true
      }
      if (tentativelyBetter) {
        cameFrom[neighbor.index] = nextIndex
        gScore[neighbor.index] = tentetiveGScore
        hScore[neighbor.index] = getTileDistance(neighbor, end)
        fScore[neighbor.index] = gScore[neighbor.index] + hScore[neighbor.index]
        if (!open.contains(neighbor.index)) {
          open.add(neighbor.index)
        }
      }
    }
  }
  return null
}

/// 刷新地图地域上色信息
fun updateWorldMapZoneColors {
  final zoneColors = Map()
  for (final zone in game.world.zones) {
    zoneColors[zone.index] = zone.color
  }
  engine.updateZoneColors(zoneColors)
}
  
/// 刷新地图疆域上色信息
fun updateWorldMapNationColors {
  final nationColors = Map()
  for (final nation of game.nations) {
    nationColors[nation.id] = nation.color
  }
  engine.updateNationColors(nationColors)
}