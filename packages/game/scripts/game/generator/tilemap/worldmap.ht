import '../random_names/random_names.ht' as randomNames
import '../../game.ht'
import '../../location.ht'
import '../../character.ht'
import 'hexagonal_tile.ht'
import 'component.ht'
import {
  tilePos2Index,
  getMapTileNeighbors,
  calculateRoute } from '../../map.ht'

/// 生成世界地图的算法
///
/// spritesheet上不同地形对应的编号：
/// 0：虚空
/// 1：浅海
/// 2：深海
/// 3：陆地（草原）
///
/// 算法思路：
///
/// 用海面填满整个地图空间
///
/// 找到一个出发点，通常在地图中间部分
///
/// 找到出发点周围的方块，将其加入一个数组，作为当前陆地的边界
///
/// 将当前方块变成陆地，检查陆地比例，如果不够，就从当前陆地边界中随机挑选一个方块，将其变成陆地，同时重新计算边界。
///
/// 循环上述步骤，直到陆地和海水的比例达到预设值
///
/// 为陆地所属的整个大地块命名，然后找到尚未命名的地块，将所有相连的地块作为一个整体命名，直到所有的地块都有名字，根据地块大小有不同命名方式
///
/// 根据城市密度，生成城市，并根据城市位于陆地、海边还是海中，对其进行特殊命名
///
/// 对于每个城市，链接最近的另外两个城市，使用 A* 寻路算法，标记经过的地块
///
/// 对于没有道路经过的地块，随机填充山脉和树林

const _defaultWorldWidth = 12
const _defaultWorldHeight = 12
const _kSpriteWater = 1
const _kSpriteShelf = 2
const _kSpriteLand = 3
const _kSpriteCity = 4
const _kSpriteForest = 5
const _kSpriteMountain = 6
const _kLocationCategoryCity = 'city'
const _kLocationCategoryIsland = 'island'
const _kLocationCategoryShore = 'shore'
const _kZoneVoid = 'void'
const _kZoneWater = 'water'
const _kZoneContinent = 'continent'
const _kZoneLake = 'lake'
const _kMinZoneSizeForLocation = 9 // 最大据点密度
const _kMaxZoneSizeForLocation = 18 // 最小据点密度
const _kMinZoneSizeForSea = 8
const _kZoneSizeForHarbor = 18
const _kForestThreshold = 0.5
const _kMountainThreshold = 0.2
const _kMinLocationNumberForOrganization = 0.5 // 最大组织密度
const _kMaxLocationNumberForOrganization = 8 // 最小组织密度
const _kMinNpcNumberForOrganization = 3
const _kMaxNpcNumberForOrganization = 18

struct Zone {
  var index: int
  var name: str
  var category: str
  var count = 0
  var tileIndexes = Set()

  construct ({index, name, category}) {
    assert(index != null)
    this.index = index
    this.name = name
    this.category = category
  }
}

fun createWorldMap({
    terrainSpriteSheet: str,
    tileShape = 'hexagonalVertical',
    width = _defaultWorldWidth,
    height = _defaultWorldHeight,
    style = 'island',
    landProportion = 0.55,
    gridWidth = 32.0,
    gridHeight = 28.0,
    tileSpriteSrcWidth = 32.0,
    tileSpriteSrcHeight = 48.0,
    tileOffsetX = 0.0,
    tileOffsetY = 2.0,
  }) {

  final data = {
    terrainSpriteSheet,
    tapSelect: true,
    tileShape,
    width,
    height,
    gridWidth,
    gridHeight,
    tileSpriteSrcWidth,
    tileSpriteSrcHeight,
    tileOffsetX,
    tileOffsetY,
    zones: [],
    terrains: [],
    interactables: [],
  }

  for (var j in range(height)) {
    for (var i in range(width)) {
      data.terrains.add(
        {
          ...Tile(i + 1, j + 1),
          index: tilePos2Index(i + 1, j + 1, data.width),
          spriteIndex: _kSpriteWater,
        }
      )
    }
  }

  // 新建一个区域
  fun createZone({name: str, category: str}) {
    assert(category != null)
    final zone = Zone(index: data.zones.length, name: name, category: category)
    data.zones.add(zone)
    return zone
  }

  // 没有区域，也是一个区域
  createZone(name: '无', category: _kZoneVoid)

  fun addTile2Zone(zoneIndex, tile) {
    assert(0 <= zoneIndex && zoneIndex < data.zones.length)
    if (tile.zoneIndex != null && tile.zoneIndex >= 0) {
      final oldZone = data.zones[tile.zoneIndex]
      --oldZone.count
      oldZone.tileIndexes.remove(tile.index)
    }
    final zone = data.zones[zoneIndex]
    tile.zoneIndex = zoneIndex
    tile.zoneCategory = zone.category
    ++zone.count
    zone.tileIndexes.add(tile.index)
  }

  // 当前地域的边缘格子坐标
  final shelf = Set()

  // 刷新当前地域的边缘格子坐标
  fun updateShelf(left, top) {
    shelf.remove(tilePos2Index(left, top, data.width))
    final neighbors = getMapTileNeighbors(left, top, restricted2Zone: false, data: data)
    for (final tile in neighbors) {
      if (tile.spriteIndex == _kSpriteWater) {
        shelf.add(tile.index)
      }
    }
  }

  // 生成地域
  final landArea = (width * height * landProportion).floor()

  final minLeft = width ~/ 3
  final minTop = height ~/ 3
  final maxLeft = width ~/ 3 * 2
  final maxTop = height ~/ 3 * 2

  final startLeft = Math.randomInt(maxLeft - minLeft) + minLeft
  final startTop = Math.randomInt(maxTop - minTop) + minTop
  data.heroX = startLeft
  data.heroY = startTop
  // print('start: ${startLeft},${startTop}')
  final startIndex = tilePos2Index(startLeft, startTop, data.width)
  final firstTile = data.terrains[startIndex]
  firstTile.spriteIndex = _kSpriteLand
  final landZone = createZone(category: _kZoneContinent)
  addTile2Zone(landZone.index, firstTile)
  updateShelf(startLeft, startTop)

  var currentLandSize = 1
  while (currentLandSize < landArea) {
    // print('expanding land')
    ++currentLandSize
    final tile = data.terrains[shelf.random]
    updateShelf(tile.left, tile.top)
    tile.spriteIndex = _kSpriteLand
    addTile2Zone(landZone.index, tile)
  }

  // 生成地图上的不同地域
  // 根据相邻的格子的地域，分配地域索引
  fun updateZone(tile, [spriteIndex, unzonedNeighbors]) {
    assert(tile.zoneIndex == null)
    var willCreateZone = true
    if (spriteIndex != null) {
      willCreateZone = false
    } else {
      spriteIndex = tile.spriteIndex
    }
    unzonedNeighbors ??= {}
    // print('processing: ${tile.left},${tile.top}, spriteIndex: ${tile.spriteIndex}')
    tile.zoneIndex = -1 // mark this tile is being processed, will skip it when process others
    final neighbors = getMapTileNeighbors(tile.left, tile.top, data: data)
    var foundAdjacentZone = false
    for (final neighbor in neighbors) {
      // skip tiles that has diffrent spriteIndex and those still being processed
      if (spriteIndex != neighbor.spriteIndex) continue
      if (neighbor.zoneIndex == null) {
        updateZone(neighbor, spriteIndex, unzonedNeighbors)
      }
      if (neighbor.zoneIndex == -1) {
        unzonedNeighbors[neighbor.index] = neighbor
        continue
      }
      addTile2Zone(neighbor.zoneIndex, tile)
      foundAdjacentZone = true
      // print('Found neighbor: ${neighbor.left},${neighbor.top}, zoneIndex: ${neighbor.zoneIndex}')
      break
    }
    if (!foundAdjacentZone && willCreateZone) {
      var category = tile.spriteIndex == _kSpriteLand ? _kZoneContinent : _kZoneWater
      final zone = createZone(category: category)
      // print('Created zone! left: ${tile.left}, top: ${tile.top} spriteIndex: ${tile.spriteIndex}, zoneIndex: ${zone.index}')
      addTile2Zone(zone.index, tile)
      // print('processing previoused stored unzoned tiles: ${unzonedNeighbors}')
      for (final unzonedTile of unzonedNeighbors) {
        if (unzonedTile.zoneIndex == -1) {
          addTile2Zone(zone.index, unzonedTile)
        }
      }
    }
  }

  var unzonedTile

  while (
    unzonedTile = data.terrains.firstWhere((tile) {
        tile.zoneIndex == null
      }, orElse: () {})
  ) {
    // print('updating unzoned tile')
    updateZone(unzonedTile)
  }

  for (final zone in data.zones) {
    if (zone.name) {
      continue
    }
    late names
    late category
    if (zone.category == _kZoneWater) {
      category = zone.count < _kMinZoneSizeForSea ? _kZoneLake : _kZoneWater
    } else {
      category = zone.category
    }
    names = randomNames.getZone(1, category: category)
    zone.name = names.first.name
  }

  // 根据 tile 的所在位置的类型，获取据点类型
  fun getLocationCategory(tile) {
    if (tile.spriteIndex == _kSpriteLand) {
      return { zoneIndex: tile.zoneIndex, category: _kLocationCategoryCity }
    } else {
      final neighbors = getMapTileNeighbors(tile.left, tile.top, data: data)
      for (final neighbor in neighbors) {
        if (neighbor.spriteIndex == _kSpriteLand) {
          return { zoneIndex: neighbor.zoneIndex, category: _kLocationCategoryShore }
        }
      }
      return { zoneIndex: tile.zoneIndex, category: _kLocationCategoryIsland }
    }
  }

  fun find2NearestLocation(origin, {restricted2Zone: bool = true}) {
    assert(game.locations.length > 0)
    var nearest
    var nearestDistance
    var secondNearest
    var secondNearestDistance
    for (final location of game.locations) {
      if (location.index == origin.index) {
        continue
      } else {
        final distance = getTileDistance(origin, location)
        if (!restricted2Zone || location.zoneIndex == origin.zoneIndex) {
          if (!location.destinations || !location.destinations[origin.index]) {
            if (nearestDistance == null || distance < nearestDistance) {
              nearestDistance = distance
              nearest = location
            } else if (secondNearestDistance == null || distance < secondNearestDistance) {
              secondNearestDistance = distance
              secondNearest = location
            } else {
              continue
            }
          }
        }
      }
    }
    return { nearest, secondNearest }
  }

  // var harborCount = landZone.count ~/ _kZoneSizeForHarbor
  // if (harborCount == 0) {
  //   harborCount = 1
  // }
  final locationIndexes = Set()
  // final harborIndexes = Set()
  // 生成据点
  for (final zone in data.zones) {
    if (zone.count < _kMinZoneSizeForLocation) continue
    // print('processing zone: ${zone.name} count: ${zone.count}')
    final minLocNum = zone.count ~/ _kMaxZoneSizeForLocation
    final maxLocNum = zone.count ~/ _kMinZoneSizeForLocation
    final locationNumber = Math.randomInt(maxLocNum - minLocNum) + minLocNum
    final zoneLocationIndexes = Set()
    while (zoneLocationIndexes.length < locationNumber) {
      var index
      do {
        // print('generating location index')
        index = zone.tileIndexes.random
      } while (locationIndexes.contains(index))
      final tile = data.terrains[index]
      final categoryInfo = getLocationCategory(tile)
      final location = Location(category: categoryInfo.category)
      zoneLocationIndexes.add(index)
      locationIndexes.add(index)
      print(categoryInfo.category)
      if (categoryInfo.category == _kLocationCategoryShore) {
        // print('processing harbor: ${tile.left},${tile.top}')
        // harborIndexes.add(index)
        // 将港口的地域改成相邻的陆地
        tile.isHarbor = true
        tile.harborOfZoneIndex = tile.zoneIndex
        addTile2Zone(categoryInfo.zoneIndex, tile)
      }
      data.interactables.add(
        {
          ...Tile(tile.left, tile.top),
          index,
          zoneIndex: tile.zoneIndex,
          zoneCategory: tile.zoneCategory,
          locationId: location.id,
          shape: tileShape,
          srcWidth: tileSpriteSrcWidth,
          srcHeight: tileSpriteSrcHeight,
          gridWidth,
          gridHeight,
          spriteIndex: _kSpriteCity,
          offsetX: tileOffsetX,
          offsetY: tileOffsetY,
        }
      )
    }
  }

  // 检查港口数量是否足够，否则补充港口
  // while (harborIndexes.length < harborCount) {
  //   var index
  //   do {
  //     index = shelf.random
  //   } while (locationIndexes.contains(index))
  //   final tile = data.terrains[index]
  //   final location = Location(category: _kLocationCategoryShore)
  //   harborIndexes.add(index)
  //   // 将港口的地域改成相邻的陆地
  //   final categoryInfo = getLocationCategory(tile)
  //   final neighborZone = data.zones[categoryInfo.zoneIndex]
  //   ++neighborZone.count
  //   final thisZone = data.zones[tile.zoneIndex]
  //   --thisZone.count
  //   tile.isHarbor = true
  //   tile.harborOfZoneIndex = tile.zoneIndex
  //   tile.zoneIndex = neighborZone.index
  //   tile.zoneCategory = neighborZone.category
  //   data.interactables.add(
  //     {
  //       ...Tile(tile.left, tile.top),
  //       index,
  //       zoneIndex: tile.zoneIndex,
  //       zoneCategory: tile.zoneCategory,
  //       locationId: location.id,
  //       shape: tileShape,
  //       srcWidth: tileSpriteSrcWidth,
  //       srcHeight: tileSpriteSrcHeight,
  //       gridWidth,
  //       gridHeight,
  //       spriteIndex: _kSpriteCity,
  //       offsetX: tileOffsetX,
  //       offsetY: tileOffsetY,
  //     }
  //   )
  // }

  // 标记属于水面的 tile
  for (final terrain in data.terrains) {
    if (terrain.spriteIndex == _kSpriteWater) {
      terrain.isWater = true
    }
  }
  
  // 将大陆和海洋接触的地方填充为大陆架
  for (final index in shelf) {
    final tile = data.terrains[index]
    tile.spriteIndex = _kSpriteShelf
  }

  for (final location of game.locations) {
    // 确保陆地上的每个城市至少可以链接到另外两个城市
    if (location.zoneCategory == _kZoneContinent) {
      final tiles = find2NearestLocation(location, restricted2Zone: true)
      if (tiles.nearest) {
        final start = game.terrains[location.index]
        final end = game.terrains[tiles.nearest.index]
        final route = calculateRoute(start, end, data: data)
        if (route) {
          // routes.add(route)
          for (final index in route) {
            final terrain = data.terrains[index]
            terrain.isRoute = true
          }
        }
      }
      if (tiles.secondNearest) {
        final start = game.terrains[location.index]
        final end = game.terrains[tiles.secondNearest.index]
        final route = calculateRoute(start, end, data: data)
        if (route) {
          // routes.add(route)
          for (final index in route) {
            final terrain = data.terrains[index]
            terrain.isRoute = true
          }
        }
      }
    }
  }

  // 将大陆上没有道路的方格，随机填充为平原、森林、山地
  for (final index in landZone.tileIndexes) {
    final terrain = data.terrains[index]
    if (!terrain.isRoute) {
      final r = Math.random()
      if (r < _kMountainThreshold) {
        terrain.spriteIndex = _kSpriteMountain
      } else if (r < _kForestThreshold) {
        terrain.spriteIndex = _kSpriteForest
      }
    }
  }

  // 向世界中填充NPC
  var minOrgNum = game.locations.length ~/ _kMaxLocationNumberForOrganization
  final maxOrgNum = game.locations.length ~/ _kMinLocationNumberForOrganization
  if (minOrgNum < 2) {
    minOrgNum = 2
  }
  if (maxOrgNum < minOrgNum) {
    maxOrgNum = minOrgNum
  }
  final orgNum = Math.randomInt(maxOrgNum - minOrgNum) + minOrgNum
  var advancedOrgNum = orgNum * _kAdvancedAIOrganizationOpponentProportion
  if (advancedOrgNum == 0) {
    advancedOrgNum = 1
  }
  
  for (var i in range(orgNum)) {
    final org = Clan()
    iter.moveNext()
    org.headquarterLocationId = locationIndexes.random
    // 在这个据点生成组织相关的场景，总堂，士宅等等。并根据组织类型，生成一些功能性建筑
    final loc = game.locations[org.headquarterLocationId]
    loc.rulingOrganizationId ??= org.id
    // loc.scenes.add

    final npcCount = Math.randomInt(_kMaxNpcNumberForOrganization - _kMinNpcNumberForOrganization) + _kMinNpcNumberForOrganization
    final leader = Character()
    leader.organization.id = org.id
    leader.organization.rank = 0
    for (var i in range(npcCount - 1)) {
      final char = Character()
      char.organization.id = org.id
    }
  }
  
  game.world = data
  final future = MapComponent.fromJson(data.toJson())
  future.then((value) {
    game.world.component = value
  })
  return future
}
