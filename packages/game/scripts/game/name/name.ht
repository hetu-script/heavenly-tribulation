import 'shared/common.json' as commonNames
import 'shared/strange.json' as strangeNames
import 'shared/color.json' as colorPrefix
import 'shared/spirit.json' as spiritPrefix
import 'character/family.json' as family
import 'character/female.json' as female
import 'character/male.json' as male
import 'character/middle.json' as middle
import 'skill/skill.json' as skill
import 'skill/extra.json' as skillExtra
import 'skill/numfix.json' as skillNumfix
import 'book/prefix.json' as bookPrefix
import 'book/book.json' as book
import 'book/postfix.json' as bookPostfix
import 'spell/spell.json' as spell
import 'talisman/talisman.json' as talisman
import 'talisman/material.json' as talismanMaterial
import 'talisman/postfix.json' as talismanPostfix
import 'organization/organization.json' as organization
import 'place/place.json' as place
import 'place/prefix.json' as placePrefix
import 'place/postfix.json' as placePostfix
import 'place/location.json' as location
import 'place/zone.json' as zone
import 'material/material.json' as material
import 'creature/creature.json' as creature
import 'creature/prefix.json' as creaturePrefix
import 'creature/strange.json' as strangeCreature
import 'consumable/consumable.json' as consumable
import 'consumable/medicine.json' as medicine
import 'consumable/beverage.json' as beverage
import '../entity/common.ht'
import { random } from '../game.ht'

export {
  getCharacter,
  getSkill,
  getBook,
  getSpell,
  getCreature,
  getMaterial,
  getConsumable,
  getTalisman,
  getOrganization,
  getNation,
  getLocationKind,
  getLocation,
  getZoneKind,
  getZone,
}

final common = [
  ...commonNames.dao,
  ...commonNames.budda,
  ...commonNames.emotion,
  ...commonNames.creature,
  ...commonNames.object,
  ...commonNames.color,
  ...commonNames.place,
  ...commonNames.number,
  ...commonNames.action,
  ...commonNames.target,
];

final kLocationCategories = location.keys

final kOrganizationCategories = organization.keys

final kZoneCategories = zone.keys

const _kLinkWord = '之'

fun getCharacter(number: int, {isFemale, familyName, middleCharacter}) {
  final names = []
  for (var i in range(number)) {
    var theFamilyName
    if (!familyName) {
      theFamilyName = random.nextIterable(family)
    } else {
      theFamilyName = familyName
    }
    final f = isFemale ?? random.nextBool()
    final namesOfASex = f ? female : male
    final r = random.nextDouble()
    var name = ''
    // 单字的名字
    if (r < 0.33333333) {
      if (middleCharacter) {
        name = middleCharacter
      } else {
        name = random.nextIterable(namesOfASex)
      }
    }
    // 两个实字
    else if (r < 0.66666666) {
      final theMiddleCharacter
      if (middleCharacter) {
        theMiddleCharacter = middleCharacter
      } else {
        theMiddleCharacter = random.nextIterable(namesOfASex)
      }
      final theLastCharacter = random.nextIterable(namesOfASex)
      name = theMiddleCharacter + theLastCharacter
    }
    // 中间是虚字
    else {
      final theMiddleCharacter
      if (middleCharacter) {
        theMiddleCharacter = middleCharacter
      } else {
        theMiddleCharacter = random.nextIterable(middle)
      }
      final theLastCharacter = random.nextIterable(namesOfASex)
      name = theMiddleCharacter + theLastCharacter
    }
    names.add({ familyName: theFamilyName, shortName: name, name: theFamilyName + name, isFemale: f })
  }
  return names
}

const _kNumberBeginSupplement = '路'
const _kNumberEndSupplement = '式'

const _kBookLeft = "《";
const _kBookRight = "》";

const _kSkillExtraProbability = 0.075
const _kSkillNumfixProbability = 0.075
const _kSkillWithThreeElementsProbability = 0.15
const _kSkillWithTwoElementsProbability = 0.35

fun _getSkillName({length, category, kind}) {
  var l = length ?? 1
  var rarity = 'common'
  if (!length) {
    final r = getRarity()
    if (r.rarityLevel > kRarity.epic.rarityLevel) {
      l = 3
    } else if (r.rarityLevel > kRarity.uncommon.rarityLevel) {
      l = 2
    }
    rarity = r.rarity
  }
  var name = ''
  for (var i in range(l)) {
    name += random.nextIterable(common)
  }
  var e = ''
  var n = ''
  final c = category ?? random.nextIterable(skill.keys)
  final k = kind ?? random.nextIterable(skill[c])
  if (random.nextDouble() < _kSkillExtraProbability) {
    e = random.nextIterable(skillExtra)
  }
  if (random.nextDouble() < _kSkillNumfixProbability) {
    n = random.nextIterable(skillNumfix)
  }
  if (random.nextDouble() < 0.5) {
    name = (n != '' ? n + _kNumberBeginSupplement : '') + e + name + k
  } else {
    if (k.length > 1) {
      name = e + name + k + (n != '' ? n + _kNumberEndSupplement : '')
    } else {
      name = e + name + n + k
    }
  }
  return { name, category: c, rarity }
}

fun getSkill(number, {length, category, kind}) {
  var names = [];
  for (let i = 0; i < number; ++i) {
    var name = _getSkillName(
      length: length,
      category: category,
      kind: kind,
    );
    names.add(name);
  }
  return names;
}

fun getBook(number: int, {length, category, kind}) {
  final names = []
  for (var i in range(number)) {
    final c = category ?? random.nextIterable(skill.keys)
    final skillname = _getSkillName(length: length, category: c, kind: kind)
    var rarity = skillname.rarity
    var pre = ''
    var post = ''
    if (skillname.rarity == 'exotic') {
      pre = random.nextIterable(bookPrefix.exotic)
    } else if (skillname.rarity == 'mythic') {
      pre = random.nextIterable(bookPrefix.mythic)
    } else if (skillname.rarity == 'legendary') {
      pre = random.nextIterable(bookPrefix.legendary)
    } else if (skillname.rarity == 'epic') {
      pre = random.nextIterable(bookPrefix.epic)
    }
    if (pre) {
      post = random.nextIterable(book)
    }
    names.add({
      name: _kBookLeft + skillname.name + pre + post + _kBookRight,
      skillName: skillName.name
      category: c,
      rarity: rarity,
    })
  }
  return names
}

fun getSpell(number: int) {
  final names = []
  for (var i in range(number)) {
    final name = random.nextIterable(common) + random.nextIterable(spell)
    names.add(name)
  }
  return names
}

final commonCreatureNames = [
  ...commonNames.dao,
  ...commonNames.place,
  ...commonNames.number,
  ...commonNames.action,
]

fun getCreature(number: int, {category, rarity}) {
  final names = []
  for (var i in range(number)) {
    var name = ''
    final pre = random.nextIterable(commonCreatureNames)
    final cp = random.nextIterable(colorPrefix)
    final s = random.nextIterable(creaturePrefix)
    final c = category ?? random.nextIterable(creature.keys)
    final k = random.nextIterable(creature[c])
    final r = rarity ?? getRarity().rarity
    if (r == 'exotic') {
      name = random.nextIterable(strangeCreature)
    } else if (r == 'mythic') {
      name = pre + cp + s + k
    } else if (r == 'legendary') {
      name = pre + s + k
    } else if (r == 'epic') {
      name = pre + cp + k
    } else if (r == 'rare') {
      name = pre + k
    } else if (r == 'uncommon') {
      name = cp + s + k
    } else if (r == 'common') {
      name = cp + k
    }
    names.add({ name, rarity: r, category: c })
  }
  return names
}

fun getMaterial(number: int, {category, kind, rarity}) {
  final names = []
  for (var i in range(number)) {
    var name = ''
    final pre = random.nextIterable(common)
    final cp = random.nextIterable(colorPrefix)
    final s = random.nextIterable(spiritPrefix)
    var c = category
    var k = kind
    if (!k) {
      if (c) {
        assert(material.keys.contains(c))
        k = random.nextIterable(material[c])
      } else {
        c = random.nextIterable(material.keys)
        k = random.nextIterable(material[c])
      }
    }
    final r = rarity ?? getRarity().rarity
    if (r == 'exotic') {
      name = pre + cp + s + k
    } else if (r == 'mythic') {
      name = pre + cp + s + k
    } else if (r == 'legendary') {
      name = pre + s + k
    } else if (r == 'epic') {
      name = pre + s + k
    } else if (r == 'rare') {
      name = cp + s + k
    } else if (r == 'uncommon') {
      name = cp + s + k
    } else if (r == 'common') {
      name = cp + k
    }
    names.add({ name, category: c, rarity: r })
  }
  return names
}

final commonElixirNames = [
  ...commonNames.dao,
  ...commonNames.budda,
  ...commonNames.emotion,
  ...commonNames.color,
  ...commonNames.number,
  ...commonNames.action,
  // ...commonNames.target,
]

fun getConsumable(number: int, {category: str, kind: str, rarity: str}) {
  final names = []
  for (var i in range(number)) {
    var s = ''
    final r = rarity ?? getRarity().rarity
    if (r != kCommon) {
      s = random.nextIterable(spiritPrefix)
    }
    var c = category
    if (c) {
      assert(consumable.keys.contains(c))
      c = category
    } else {
      c = random.nextIterable(consumable.keys)
    }
    var pre
    if (r == 'common') {
      if (c == 'medicine') {
        pre = random.nextIterable(medicine)
      } else if (c == 'beverage') {
        pre = random.nextIterable(beverage)
      } else {
        pre = random.nextIterable(commonElixirNames)
      }
    } else {
      pre = random.nextIterable(commonElixirNames)
    }
    var k = kind ?? random.nextIterable(consumable[c])
    names.add({ name: pre + s + k, category: c, rarity: r })
  }
  return names
}

fun getTalisman(number: int, {category, kind, rarity}) {
  final names = []
  for (var i in range(number)) {
    var name = ''
    final prefix = random.nextIterable(common)
    final cp = random.nextIterable(colorPrefix)
    final m = random.nextIterable(talismanMaterial)
    final s = random.nextIterable(spiritPrefix)
    var c = category
    var k = kind
    if (!k) {
      if (c) {
        assert(talisman.keys.contains(c))
        k = random.nextIterable(talisman[c])
      } else {
        c = random.nextIterable(talisman.keys)
        k = random.nextIterable(talisman[c])
      }
    }
    final r = rarity ?? getRarity().rarity
    if (r == 'exotic') {
      name = prefix + s + k
    } else if (r == 'mythic') {
      name = prefix + s + k
    } else if (r == 'legendary') {
      name = prefix + cp + m + k
    } else if (r == 'epic') {
      name = prefix + m + k
    } else if (r == 'rare') {
      name = prefix + k
    } else if (r == 'uncommon') {
      name = cp + m + k
    } else if (r == 'common') {
      name = m + k
    }
    names.add({ name, category: c, rarity: r })
  }
  return names
}

fun getOrganizationKind([category: str]) {
  if (category != null) {
    assert(kOrganizationCategories.contains(category))
  } else {
    category = random.nextIterable(kOrganizationCategories)
  }
  return random.nextIterable(organization[category])
}

fun getOrganization(number: int, {kind: str, category: str}) {
  final names = []
  for (var i in range(number)) {
    final name = random.nextIterable(common)
    final c = category ?? random.nextIterable(kOrganizationCategories)
    final k = kind ?? getOrganizationKind(c);
    names.add({ name: name + k, category: c })
  }
  return names
}

const _kNation = '国'

const _kStrangeNameProbability = 0.15
const _kXianXiaNameProbability = 0.35
const _kNameWithDirectionProbability = 0.5
const _kNameWithLinkWordProbability = 0.15

fun getNation(number: int) {
  final names = []
  for (var i in range(number)) {
    var name = ''
    var rarity = 'common'
    final r = random.nextDouble()
    if (r < _kStrangeNameProbability) {
      name = random.nextIterable(strangeNames)
      rarity = 'rare'
    } else if (r < _kXianXiaNameProbability) {
      name = random.nextIterable(common)
      rarity = 'uncommon'
    } else {
      var prefix = ''
      if (random.nextDouble() < _kNameWithDirectionProbability) {
        prefix = random.nextIterable(placePrefix)
      }
      name = prefix + random.nextIterable(place)
    }
    names.add({ name: name + _kNation, rarity })
  }
  return names
}

fun getLocationKind([category: str]) {
  if (category != null) {
    assert(kLocationCategories.contains(category))
  } else {
    category = random.nextIterable(kLocationCategories)
  }
  return random.nextIterable(location[category])
}

fun getLocation(number: int, {kind: str, category: str}) {
  final names = []
  for (var i in range(number)) {
    var name = ''
    var c = category ?? random.nextIterable(kLocationCategories)
    var k = kind ?? getLocationKind(c);
    var rarity = 'common'
    final r = random.nextDouble()
    if (r < _kStrangeNameProbability) {
      name = random.nextIterable(strangeNames)
      rarity = 'rare'
    } else if (r < _kXianXiaNameProbability) {
      name = random.nextIterable(common)
      rarity = 'uncommon'
    } else {
      var postfix = ''
      if (random.nextDouble() < _kNameWithDirectionProbability) {
        postfix = random.nextIterable(placePostfix)
      }
      name = random.nextIterable(place) + postfix
    }
    names.add({ name: name + k, category: c, rarity })
  }
  return names
}

fun getZoneKind([category: str]) {
  if (category != null) {
    assert(kZoneCategories.contains(category))
  } else {
    category = random.nextIterable(kZoneCategories)
  }
  return random.nextIterable(zone[category])
}

fun getZone(number: int, {kind: str, category: str}) {
  final names = []
  for (var i in range(number)) {
    var name = ''
    final c = category ?? random.nextIterable(kZoneCategories)
    final k = kind ?? getZoneKind(c);
    var rarity = 'common'
    final r = random.nextDouble()
    if (r < _kStrangeNameProbability) {
      name = random.nextIterable(strangeNames)
      rarity = 'rare'
    } else if (r < _kXianXiaNameProbability) {
      name = random.nextIterable(common)
      rarity = 'uncommon'
    } else {
      var prefix = ''
      if (random.nextDouble() < _kNameWithDirectionProbability) {
        prefix = random.nextIterable(placePrefix)
      }
      name = prefix + random.nextIterable(place)
      if (name.length == 1) {
        if (k.length > 1) {
          name += _kLinkWord;
        } else {
          if (random.nextDouble() < _kNameWithLinkWordProbability) {
            name += _kLinkWord;
          }
        }
      }
    }
    names.add({ name: name + k, category: c, rarity })
  }
  return names
}
