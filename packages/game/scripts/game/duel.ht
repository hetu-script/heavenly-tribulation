import 'game.ht'
import 'l10n.ht'
import 'entity/common.ht'
import 'entity/character/character.ht'

/// 战斗模块
/// 输入战斗相关角色的对象
/// 生成战斗过程的文字描述，以及最终结果

external fun _showDuel(context, char1, char2, [ type, data ])

fun showDuel(char1, char2, { type, onCallback: ( any ) -> any }) -> Future {
  final duelResult = Duel(char1, char2, type: type);
  return _showDuel(buildContext, char1, char2, type, duelResult)
}

// damage = ((1 / (Math.log((victim.defense + 5) / 100) + 5)) * 2 * attacker._attack)

const kDuelTypePractice = 'practice'
const kDuelTypeSneakAttack = 'sneakAttack'
const _kDuelticksLimit = 500

// fun _attack(offenseItem, defenseItem, log) {
  // var offset = 0
  // final defenseValue = defenseItem.stats.defense ?? 0
  // if (defenseValue > 0) {
  //   offset = Math.gaussianNoise(defenseValue, defenseValue * 0.25, min: defenseValue * 0.5 max: defenseValue)
  // }
  // final damage = offenseItem.stats.damage - offset
  // return damage
// }

struct Log {
  construct ({
    message,
    activatedOffenseIndex = 0,
    speed,
    damage = 0,
    targetIndex,
  }) {
    assert(message != null)
    this.activatedOffenseIndex = activatedOffenseIndex
    this.speed = speed
    this.damage = damage
    this.message = message
    this.targetIndex = targetIndex
  }
}

struct Duel {
  construct(char1, char2, { type }) {
    this.messages = []
    this.actions = {
      char1: [],
      char2: [],
    }

    // 保存战斗开始时双方的初始状态
    this.initialStats = {
      char1: getCharacterStats(char1),
      char2: getCharacterStats(char2),
    }
    
    final char1info = {
      ticks: 0,
      activatedDefenseIndex: 0, // 当前激活的防御单位，0代表英雄本身，1-3代表防具，4-6代表随从
      activatedOffenseIndex: 1, // 当前激活的进攻手段，1代表第一个武器或斗技
      // 复制出来的人物当前状态，包括生命值等
      stats: this.initialStats.char1.clone(),
    }
    final char2info = {
      ticks: 0,
      activatedDefenseIndex: 0,
      activatedOffenseIndex: 1,
      stats: this.initialStats.char2.clone(),
    }

    this.started = false
    if (char1.equipments.offense.isEmpty) {
      // 如果没有装备任何武器或者战斗技能，则直接判负
      engine.info(getLocaleString('无法开始战斗：${char1.name} 没有装备武器。'))
      this.result = false
    } else if (char2.equipments.offense.isEmpty) {
      engine.info(getLocaleString('无法开始战斗：${char2.name} 没有装备武器。'))
      this.result = true
    } else {
      this.result = false
      this.tied = false
      // 战斗本身的客观时间，不会受任何因素影响
      this.frames = 0
      char1info.activatedOffense = getEquippedEntity(char1info.offenseItems.values.first, char1)
      char2info.activatedOffense = getEquippedEntity(char2info.offenseItems.values.first, char2)

      // 设置人物当前防护物品位置，0 = 无防护物品
      // fun setNextActivatedDefenseItem(info, character) {
      //   for (final i = 1; i < _kDefenseEquipmentMax) {
      //     final item = 
      //     if (item.stats.life > 0) {
      //       info.activatedDefense = item
      //       return i + 1
      //     }
      //   }
      //   // 没有找到防护装备，伤害会直接作用于人物本身
      //   info.activatedDefense = info.entity
      //   return 0
      // }
      
      // char1info.targetIndex = setNextActivatedDefenseItem(char2info, char2)
      // char2info.targetIndex = setNextActivatedDefenseItem(char1info, char1)
      this.started = true

      fun checkIfEnd {
        final char1Life = type == kDuelTypePractice ? char1info.stats.life : char1.stats.life
        if ( char1Life <= 0) {
          engine.info('${char1.name} 和 ${char2.name} 的战斗结束了。${char2.name} 获胜。')
          return true
        }
        final char2Life = type == kDuelTypePractice ? char2info.stats.life : char2.stats.life
        if (char2Life <= 0) {
          engine.info('${char1.name} 和 ${char2.name} 的战斗结束了。${char1.name} 获胜。')
          this.result = true
          return true
        }
        return false
      }

      if (type == kDuelTypeSneakAttack) {
        final initiativeSum = char1.attributes.perception + char2.attributes.perception
        final initiativeValue = initiativeSum * Math.random()
        if (char1.attributes.perception > initiativeValue) {
          // this.messages.add(getLocaleString('sneakAttackSuccess', [char1.name]))
          // final damage = _attack(char1info.activatedOffense, char2)
          final damage = char1info.activatedOffense.stats.damage
          entityTakeDamage(type == kDuelTypePractice ? char2info : char2, damage)
          final message = getLocaleString('attackInfo', [
            char1.name,
            char1info.activatedOffense.name,
            char2.name,
            damage.truncate(),
          ])
          this.messages.add(message)
          this.actions.char1.add(Log(damage: damage, message: message))
          if (checkIfEnd()) this.started = false
        } else {
          // this.log.add(getLocaleString('sneakAttackFail', [char1.name, char2.name]))
        }
      }

      if (this.started) {
        fun _nextTick({ enemyTurn = false }) {
          final info = enemyTurn ? char2info : char1info
          final actions = enemyTurn ? this.actions.char2 : this.actions.char1
          final subject = enemyTurn ? char2 : char1
          final target = enemyTurn ? char1 : char2
          final targetInfo = enemyTurn ? char1info : char2info
          // 出招等待阶段
          if (info.ticks >= info.activatedOffense.stats.speed) {
            // 出招
            // final damage = _attack(info.activatedOffense, target)
            final damage = info.activatedOffense.stats.damage
            final message = getLocaleString('attackInfo', [
              subject.name, 
              info.activatedOffense.name,
              target.name,
              damage.truncate(),
            ])
            this.messages.add(message)
            actions.add(Log(
              activatedOffenseIndex: info.activatedOffenseIndex,
              speed: info.activatedOffense.stats.speed,
              damage: damage,
              message: message,
              // protected: info.activatedDefense.entityType != kEntityTypeCharacter,
              // targetIndex: info.activatedDefense.id,
            ))
            info.ticks = 0
            // 计算伤害
            entityTakeDamage(type == kDuelTypePractice ? targetInfo : target, damage)
            // if (info.activatedDefense.stats.life <= 0) {
            //   info.targetIndex = setNextActivatedDefenseItem(info, target)
            // }
            // 收招
            ++info.activatedOffenseIndex
            if (info.activatedOffenseIndex > info.offenseItems.length) {
              info.activatedOffenseIndex = 1
            }
            info.activatedOffense =
              getEquippedEntity(info.offenseItems[info.activatedOffenseIndex], subject)
          } else {
            ++info.ticks
          }
        }

        while (true) {
          if (this.frames >= _kDuelticksLimit) {
            // this.messages.add(getLocaleString('drawGame'))
            this.tied = true
            break
          }

          _nextTick(char1info)
          if (checkIfEnd()) break
          _nextTick(char2info, enemyTurn: true)
          if (checkIfEnd()) break

          ++this.frames
        }
      }
    }

    // 双方结束时的状态
    this.resultStats = {
      char1: type == kDuelTypePractice ? char1info.stats : char1.stats,
      char2: type == kDuelTypePractice ? char2info.stats : char2.stats,
    }
    
    // if (config.debug) {
    //   engine.info(this)
    // }
  }
}
