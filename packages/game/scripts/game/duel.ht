import 'game.ht'
import 'l10n.ht'
import 'entity/common.ht'
import 'entity/item/common.ht'
import 'entity/character/character.ht'
import 'entity/effect/effect.ht'
import 'binding/dialog.ht'

/// 战斗模块
/// 输入战斗相关角色的对象
/// 生成战斗过程的文字描述，以及最终结果

fun showDuel(char1, char2, { type, onCallback: ( any ) -> any }) -> Future {
  final duelResult = Duel(char1, char2, type: type);
  return Dialog.showDuel(buildContext, char1, char2, type, duelResult)
}

// damage = ((1 / (Math.log((victim.defense + 5) / 100) + 5)) * 2 * attacker._attack)

const kDuelTypePractice = 'practice'
const kDuelTypeSneakAttack = 'sneakAttack'
const _kDuelticksLimit = 500

// fun _attack(offenseItem, defenseItem, log) {
  // var offset = 0
  // final defenseValue = defenseItem.stats.defense ?? 0
  // if (defenseValue > 0) {
  //   offset = Math.gaussianNoise(defenseValue, defenseValue * 0.25, min: defenseValue * 0.5 max: defenseValue)
  // }
  // final damage = offenseItem.stats.damage - offset
  // return damage
// }

struct Action {
  construct ({
    message,
    activatedOffenseIndex = 0,
    speed,
    damage = 0,
    equipmentIndex,
    shareDamage = 0,
  }) {
    assert(message != null)
    this.activatedOffenseIndex = activatedOffenseIndex
    this.speed = speed
    this.damage = damage
    this.message = message
    this.equipmentIndex = equipmentIndex
    this.shareDamage = shareDamage
  }
}

struct Duel {
  construct(char1, char2, { type }) {
    this.type = type;
    this.messages = []
    this.char1Name = char1.name
    this.char2Name = char2.name
    this.actions = {
      char1: [],
      char2: [],
    }

    // 保存战斗开始时双方的初始状态
    this.initialStats = {
      char1: getCharacterStats(char1),
      char2: getCharacterStats(char2),
    }
    
    final char1info = {
      ticks: 0,
      // 复制出来的人物当前状态，包括生命值等
      stats: this.initialStats.char1.clone(),
    }
    final char2info = {
      ticks: 0,
      activatedOffenseIndex: 1,
      stats: this.initialStats.char2.clone(),
    }

    this.started = false
    if (char1.equipments.isEmpty) {
      // 如果没有装备任何武器或者战斗技能，则直接判负
      engine.warning(getLocaleString('无法开始战斗：${char1.name} 没有装备武器或技能。'))
      this.result = false
    } else if (char2.equipments.isEmpty) {
      engine.warning(getLocaleString('无法开始战斗：${char2.name} 没有装备武器或技能。'))
      this.result = true
    } else {
      this.result = false
      this.tied = false
      // 战斗本身的客观时间，不会受任何因素影响
      this.frames = 0
      // 当前激活的进攻手段，1代表第一个武器或斗技
      char1info.activatedOffense = getFirstEquippedOffenseItem(char1)
      char1info.activatedOffenseIndex = char1info.activatedOffense.equippedPosition
      char2info.activatedOffense = getFirstEquippedOffenseItem(char2)
      char2info.activatedOffenseIndex = char1info.activatedOffense.equippedPosition

      this.started = true
      
      // 如果目标声明小于0，返回true
      fun nextTick({ enemyTurn = false, sneakAttack = false }) {
        final actions = enemyTurn ? this.actions.char2 : this.actions.char1
        final subject = enemyTurn ? char2 : char1
        final subjectInfo = enemyTurn ? char2info : char1info
        final target = enemyTurn ? char1 : char2
        final targetInfo = enemyTurn ? char1info : char2info

        // 出招等待阶段
        if (subjectInfo.ticks >= subjectInfo.activatedOffense.stats.speed) {
          // 出招
          final baseDamage = subjectInfo.activatedOffense.stats.damage

          // 战斗文字信息
          var message
          // 是否被某个防御物品或者战斗伙伴分担伤害
          var shareDamage
          var assistDamage

          // 处理道具防御效果
          fun handleDefendEffect({effect, item, index}) {
            if (effect.handlerType != kEffectCategoryDefend) return false
            final effectHandler = getEffectHandlerById(effect.id)
            if (effectHandler == null) {
              engine.error('找不到效果 ${effect.id} 对应的处理函数。')
              return false
            }
            assert(effectHandler is function)
            shareDamage = effectHandler(effect, baseDamage)
            if (shareDamage) {
              message = getLocaleString(sneakAttack ? 'sneakShareDamageInfo' : 'shareDamageInfo',
                interpolations: [
                subject.name,
                subjectInfo.activatedOffense.name,
                target.name,
                (baseDamage - shareDamage).truncate(),
                item.name,
                shareDamage.truncate(),
              ])
              final action = Action(
                activatedOffenseIndex: subjectInfo.activatedOffenseIndex,
                speed: subjectInfo.activatedOffense.stats.speed,
                damage: baseDamage - shareDamage,
                message: message,
                shareDamage: shareDamage,
              )
              action.equipmentIndex = index
              actions.add(action)
              entityLifeChange(targetInfo, -(baseDamage - shareDamage))
              final equipItemStats = targetInfo.stats.equipments[index]
              entityLifeChange(equipItemStats, -shareDamage)
              return true
            }
            return false
          }

          // 处理道具增强伤害
          fun handleAssistEffect({effect, item, index}) {
            if (effect.handlerType != kEffectCategoryHit) return false
            final effectHandler = getEffectHandlerById(effect.id)
            if (effectHandler == null) {
              engine.error('找不到效果 ${effect.id} 对应的处理函数。')
              return false
            }
            assert(effectHandler is function)
            assistDamage = effectHandler(effect, baseDamage)
            if (assistDamage) {
              message = getLocaleString('assistDamageInfo',
                interpolations: [
                subject.name,
                subjectInfo.activatedOffense.name,
                target.name,
                item.name,
                assistDamage.truncate(),
              ])
              actions.add(Action(
                activatedOffenseIndex: subjectInfo.activatedOffenseIndex,
                speed: subjectInfo.activatedOffense.stats.speed,
                damage: assistDamage,
                message: message,
              ))
              entityLifeChange(targetInfo, -assistDamage)
              return true
            }
            return false
          }
          
          // 遍历进攻方装备，检查是否有增强伤害效果
          for (final i in range(1, kEquipmentMax)) {
            final equipData = subject.equipments[i]
            if (!equipData) continue
            final item = getEquipped(equipData, subject)
            for (final effect of item.effects) {
              final assisted = handleAssistEffect(
                effect: effect,
                item: item,
                index: i,
              )
              if (assisted) break
            }
          }
          
          // 遍历防守方装备，检查是否有分担伤害效果
          for (final i in range(1, kEquipmentMax)) {
            final equipData = target.equipments[i]
            if (!equipData) continue
            final item = getEquipped(equipData, target)
            for (final effect of item.effects) {
              final defended = handleDefendEffect(
                effect: effect,
                item: item,
                index: i,
              )
              if (defended) break
            }
          }

          // 没有额外效果的进攻
          if (!shareDamage && !assistDamage) {
            message = getLocaleString(sneakAttack ? 'sneakDamageInfo' : 'damageInfo',
              interpolations: [
              subject.name,
              subjectInfo.activatedOffense.name,
              target.name,
              baseDamage.truncate(),
            ])
            actions.add(Action(
              activatedOffenseIndex: subjectInfo.activatedOffenseIndex,
              speed: subjectInfo.activatedOffense.stats.speed,
              damage: baseDamage,
              message: message,
            ))
            entityLifeChange(targetInfo, -baseDamage)
          }

          this.messages.add(message)
          // engine.info(message)
          
          subjectInfo.ticks = 0
          // if (info.activatedDefense.stats.life <= 0) {
          //   info.targetIndex = setNextActivatedDefenseItem(info, target)
          // }
          // 收招
          subjectInfo.activatedOffense = getNextEquippedOffenseItem(subject, subjectInfo.activatedOffenseIndex)
          subjectInfo.activatedOffenseIndex = subjectInfo.activatedOffense.equippedPosition
        } else {
          ++subjectInfo.ticks
        }

        if (targetInfo.stats.life <= 0) {
          return true
        }
      }

      var firstMove = true

      while (true) {
        if (this.frames >= _kDuelticksLimit) {
          engine.warning('战斗超时，未产生结果！')
          // this.messages.add(getLocaleString('drawGame'))
          this.tied = true
          break
        }
        ++this.frames

        var r
        if (firstMove) {
          firstMove = false
          final initiativeSum = char1.attributes.perception + char2.attributes.perception
          final initiativeValue = initiativeSum * random.nextDouble()
          if (char1.attributes.perception > initiativeValue) {
            r = nextTick(char1info, sneakAttack: type == kDuelTypeSneakAttack)
          }
        } else {
          r = nextTick(char1info)
        }
        if (r) {
          engine.info('${char1.name} 击败了 ${char2.name}。')
          final incidentContent = getLocaleString('characterDefeat', interpolations: [
            char1.name,
            char2.name,
          ])
          Incident(
            subjectIds: char1.isMajorCharacter ? [char1.id] : null,
            objectIds: char2.isMajorCharacter ? [char2.id] : null,
            content: incidentContent,
            isPrivate: true,
          )

          this.result = true
          break
        }

        r = nextTick(char2info, enemyTurn: true)
        if (r) {
          engine.info('${char2.name} 击败了 ${char1.name}。')
          final incidentContent = getLocaleString('characterDefeat', interpolations: [
            char2.name,
            char1.name,
          ])
          Incident(
            subjectIds: char2.isMajorCharacter ? [char2.id] : null,
            objectIds: char1.isMajorCharacter ? [char1.id] : null,
            content: incidentContent,
            isPrivate: true,
          )
          
          break
        }
      }
    }

    // 双方结束时的状态
    this.resultStats = {
      result: this.result,
      // 因为这里的数据用于界面显示，会包括物品、随从等额外的数据
      // 所以复制一份，而之后直接赋值给人物时会删掉额外数据
      char1: char1info.stats.clone(),
      char2: char2info.stats.clone(),
    }
    
    // if (config.debug) {
    //   engine.info(this)
    // }
  }
}

fun resolveDuelResult(char1, char2, resultStats) {
  for (final i in range(1, kEquipmentMax)) {
    final char1EquippedItem = char1.equipments[i]
    if (char1EquippedItem) {
      char1EquippedItem.stats = resultStats.char1.equipments[i]
    }
    final char2EquippedItem = char2.equipments[i]
    if (char2EquippedItem) {
      char2EquippedItem.stats = resultStats.char2.equipments[i]
    }
  }
  delete resultStats.char1.equipments
  delete resultStats.char2.equipments

  // for (final i in range(1, kEquipmentMax.defense)) {
  //   final char1EquippedItem = char1.equipments.defense[i]
  //   if (char1EquippedItem) {
  //     final char1ItemStats = resultStats.char1.defense[i]
  //     char1EquippedItem.stats = char1ItemStats
  //   }
  //   final char2EquippedItem = char2.equipments.defense[i]
  //   if (char2EquippedItem) {
  //     final char2ItemStats = resultStats.char2.defense[i]
  //     char2EquippedItem.stats = char2ItemStats
  //   }
  // }
  // delete resultStats.char1.defense
  // delete resultStats.char2.defense


  // for (final i in range(1, kEquipmentMax.companion)) {
  //   final char1EquippedItem = char1.equipments.companion[i]
  //   if (char1EquippedItem) {
  //     final char1ItemStats = resultStats.char1.companion[i]
  //     char1EquippedItem.stats = char1ItemStats
  //   }
  //   final char2EquippedItem = char2.equipments.companion[i]
  //   if (char2EquippedItem) {
  //     final char2ItemStats = resultStats.char2.companion[i]
  //     char2EquippedItem.stats = char2ItemStats
  //   }
  // }
  // delete resultStats.char1.companion
  // delete resultStats.char2.companion


  char1.stats = resultStats.char1
  char2.stats = resultStats.char2
}
