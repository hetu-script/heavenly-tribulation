import 'game.ht'
import 'l10n.ht'

/// 战斗模块
/// 输入战斗相关角色的对象
/// 生成战斗过程的文字描述，以及最终结果

external fun _showDuel(context, char1, char2, [ type, data ])

fun showDuel(char1, char2, { type }) -> Future {
  final duelResult = Duel(char1, char2, type: type);
  if (duelResult.started) {
    _showDuel(buildContext, char1, char2, type, duelResult)
  } else {
    if (duelResult.result) {
      final message = getLocaleString('enemyEmptyHands', [char2.name])
      showDialogByStrings(message, character: char2)
    } else {
      final messages = getLocaleString('emptyHands').split('\n')
      showDialogByStrings(messages, character: char1)
    }
  }
  return duelResult
}

// damage = ((1 / (Math.log((victim.defense + 5) / 100) + 5)) * 2 * attacker._attack)

const kDuelTypePractice = 'practice'
const kDuelTypeSneakAttack = 'sneakAttack'
const _kDuelticksLimit = 500

fun _attack(attacker, wielding, victim, log) {
  var offset = 0
  final defense = victim.stats.defense ?? 0
  if (defense > 0) {
    offset = Math.gaussianNoise(defense, defense * 0.25, min: defense * 0.5 max: defense)
  }
  final damage = wielding.stats.damage - offset
  return damage
}

struct Log {
  construct ({
    index = 0,
    startUp = 0,
    damage = 0,
    recovery = 0,
    message,
  }) {
    assert(message != null)
    this.index = index
    this.startUp = startUp
    this.damage = damage
    this.recovery = recovery
    this.message = message
  }
}

struct Duel {
  construct(char1, char2, { type = 'normal' }) {
    this.messages = []
    this.actions = {
      char1: [],
      char2: [],
    }

    final char1info = {
      ticks: 0,
      inRecovery: false,
      index: 1,
      wieldings: char1.equipments.offense,
      life: char1.stats.life,
    }
    final char2info = {
      ticks: 0,
      inRecovery: false,
      index: 1,
      wieldings: char2.equipments.offense,
      life: char1.stats.life,
    }
    
    this.started = false
    if (char1info.wieldings.isEmpty) {
      // 如果没有装备任何武器或者战斗技能，则直接判负
      // this.messages.add(getLocaleString('emptyHands', [char1.name]))
      this.result = false
    } else if (char2info.wieldings.isEmpty) {
      // this.messages.add(getLocaleString('enemyEmptyHands', [char2.name]))
      this.result = true
    } else {
      this.result = false
      this.started = true
      // 战斗本身的客观时间，不会受任何因素影响
      this.frames = 0
      char1info.wielding = char1info.wieldings.values.first
      char2info.wielding = char2info.wieldings.values.first

      if (type == kDuelTypeSneakAttack) {
        final initiativeSum = char1.attributes.perception + char2.attributes.perception
        final initiativeValue = initiativeSum * Math.random()
        if (char1.attributes.perception > initiativeValue) {
          // this.messages.add(getLocaleString('sneakAttackSuccess', [char1.name]))
          final damage = _attack(char1, char1info.wielding, char2)
          life -= damage
          if (life < 0) life = 0
          final message = getLocaleString('attackInfo', [
            char1.name,
            char1info.wielding.name,
            char2.name,
            damage.truncate(),
          ])
          this.messages.add(message)
          this.actions.char1.add(Log(damage: damage, message: message))
        } else {
          // this.log.add(getLocaleString('sneakAttackFail', [char1.name, char2.name]))
        }
      }
      
      fun _nextTick({ enemyTurn = false }) {
        final info = enemyTurn ? char2info : char1info
        final actions = enemyTurn ? this.actions.char2 : this.actions.char1
        final subject = enemyTurn ? char2 : char1
        final target = enemyTurn ? char1 : char2
        if (!info.inRecovery) {
          // 出招等待阶段
          if (info.ticks >= info.wielding.stats.startUp) {
            // 出招
            final damage = _attack(subject, info.wielding, target)
            if (enemyTurn) {
              char1info.life -= damage
              if (char1info.life < 0) char1info.life = 0
            } else {
              char2info.life -= damage
              if (char2info.life < 0) char2info.life = 0
            }
            final message = getLocaleString('attackInfo', [
              subject.name, 
              info.wielding.name,
              target.name,
              damage.truncate(),
            ])
            this.messages.add(message)
            actions.add(Log(
              index: info.index,
              startUp: info.wielding.stats.startUp,
              damage: damage,
              recovery: info.wielding.stats.recovery,
              message: message,
            ))
            info.ticks = 0
            info.inRecovery = true
          } else {
            ++info.ticks
          }
        } else {
          // 收招等待阶段
          if (info.ticks >= info.wielding.stats.recovery) {
            info.ticks = 0
            info.inRecovery = false
            // 收招
            ++info.index
            if (info.index >= info.wieldings.length) {
              info.index = 1
            }
            info.wielding = info.wieldings[info.index]
          } else {
            ++info.ticks
          }
        }
      }

      while (true) {
        if (this.frames >= _kDuelticksLimit) {
          // this.messages.add(getLocaleString('drawGame'))
          this.tied = true
          break
        }

        if (char1info.life <= 0) {
          // this.messages.add(getLocaleString('duelVictory', [char1.name, char2.name]))
          this.result = true
          break
        }
        
        if (char2info.life <= 0) {
          // this.messages.add(getLocaleString('duelVictory', [char2.name, char1.name]))
          break
        }

        _nextTick(char1info)
        _nextTick(char2info, enemyTurn: true)

        ++this.frames
      }
    }

    this.stats = {
      char1: {
        life: char1info.life,
      },
      char2: {
        life: char2info.life,
      }
    }
    
    if (config.debug) {
      // engine.info(this)
      engine.info('${char1.name} 和 ${char2.name} 的战斗结束了')
    }
  }
}
