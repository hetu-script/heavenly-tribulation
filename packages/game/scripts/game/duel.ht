import 'game.ht'
import 'l10n.ht'
import 'entity/common.ht'
import 'entity/item/common.ht'
import 'entity/character/character.ht'
import 'entity/effect.ht'

/// 战斗模块
/// 输入战斗相关角色的对象
/// 生成战斗过程的文字描述，以及最终结果

external fun _showDuel(context, char1, char2, [ type, data ])

fun showDuel(char1, char2, { type, onCallback: ( any ) -> any }) -> Future {
  final duelResult = Duel(char1, char2, type: type);
  return _showDuel(buildContext, char1, char2, type, duelResult)
}

// damage = ((1 / (Math.log((victim.defense + 5) / 100) + 5)) * 2 * attacker._attack)

const kDuelTypePractice = 'practice'
const kDuelTypeSneakAttack = 'sneakAttack'
const _kDuelticksLimit = 500

// fun _attack(offenseItem, defenseItem, log) {
  // var offset = 0
  // final defenseValue = defenseItem.stats.defense ?? 0
  // if (defenseValue > 0) {
  //   offset = Math.gaussianNoise(defenseValue, defenseValue * 0.25, min: defenseValue * 0.5 max: defenseValue)
  // }
  // final damage = offenseItem.stats.damage - offset
  // return damage
// }

struct Action {
  construct ({
    message,
    activatedOffenseIndex = 0,
    speed,
    damage = 0,
    itemIndex,
    companionIndex,
    shareDamage = 0,
  }) {
    assert(message != null)
    this.activatedOffenseIndex = activatedOffenseIndex
    this.speed = speed
    this.damage = damage
    this.message = message
    this.itemIndex = itemIndex
    this.companionIndex = companionIndex
    this.shareDamage = shareDamage
  }
}

struct Duel {
  construct(char1, char2, { type }) {
    this.messages = []
    this.actions = {
      char1: [],
      char2: [],
    }

    // 保存战斗开始时双方的初始状态
    this.initialStats = {
      char1: getCharacterStats(char1),
      char2: getCharacterStats(char2),
    }
    
    final char1info = {
      ticks: 0,
      activatedOffenseIndex: 1, // 当前激活的进攻手段，1代表第一个武器或斗技
      // 复制出来的人物当前状态，包括生命值等
      stats: this.initialStats.char1.clone(),
    }
    final char2info = {
      ticks: 0,
      activatedOffenseIndex: 1,
      stats: this.initialStats.char2.clone(),
    }

    this.started = false
    if (char1.equipments.offense.isEmpty) {
      // 如果没有装备任何武器或者战斗技能，则直接判负
      engine.info(getLocaleString('无法开始战斗：${char1.name} 没有装备武器。'))
      this.result = false
    } else if (char2.equipments.offense.isEmpty) {
      engine.info(getLocaleString('无法开始战斗：${char2.name} 没有装备武器。'))
      this.result = true
    } else {
      this.result = false
      this.tied = false
      // 战斗本身的客观时间，不会受任何因素影响
      this.frames = 0
      char1info.activatedOffense = getFirstEquippedOffenseItem(char1)
      char2info.activatedOffense = getFirstEquippedOffenseItem(char2)

      // 设置人物当前防护物品位置，0 = 无防护物品
      // fun setNextActivatedDefenseItem(info, character) {
      //   for (final i = 1; i < _kDefenseEquipmentMax) {
      //     final item = 
      //     if (item.stats.life > 0) {
      //       info.activatedDefense = item
      //       return i + 1
      //     }
      //   }
      //   // 没有找到防护装备，伤害会直接作用于人物本身
      //   info.activatedDefense = info.entity
      //   return 0
      // }
      
      // char1info.targetIndex = setNextActivatedDefenseItem(char2info, char2)
      // char2info.targetIndex = setNextActivatedDefenseItem(char1info, char1)
      this.started = true

      if (this.started) {
        // 如果目标声明小于0，返回true
        fun _nextTick({ enemyTurn = false, sneakAttack = false }) {
          final actions = enemyTurn ? this.actions.char2 : this.actions.char1
          final subject = enemyTurn ? char2 : char1
          final subjectInfo = enemyTurn ? char2info : char1info
          final target = enemyTurn ? char1 : char2
          final targetInfo = enemyTurn ? char1info : char2info
          // 出招等待阶段
          if (subjectInfo.ticks >= subjectInfo.activatedOffense.stats.speed) {
            // 出招
            // final damage = _attack(info.activatedOffense, target)
            final baseDamage = subjectInfo.activatedOffense.stats.damage

            // 检查是否被某个道具分担伤害
            var message
            var splitDamage
            for (final i in range(1, kEquipmentMax.defense)) {
              final equipData = target.equipments.defense[i]
              if (equipData) {
                final item = getEquipped(equipData, target)
                if (item.effects.containsKey(kEffectDefendByChance)) {
                  if (Math.random() < item.effects[kEffectDefendByChance].values[0].value) {
                    splitDamage = true
                    final shareDamage = baseDamage * item.effects[kEffectDefendByChance].values[1].value
                    message = getLocaleString(sneakAttack ? 'sneakShareDamageInfo' : 'shareDamageInfo', [
                      subject.name,
                      subjectInfo.activatedOffense.name,
                      target.name,
                      (baseDamage - shareDamage).truncate(),
                      item.name,
                      shareDamage.truncate(),
                    ])
                    engine.info(message)
                    actions.add(Action(
                      activatedOffenseIndex: subjectInfo.activatedOffenseIndex,
                      speed: subjectInfo.activatedOffense.stats.speed,
                      damage: baseDamage - shareDamage,
                      message: message,
                      itemIndex: i,
                      shareDamage: shareDamage,
                    ))
                    entityTakeDamage(targetInfo, baseDamage - shareDamage)
                    entityTakeDamage(targetInfo.stats.defense[i], shareDamage)
                    break
                  }
                }
              }
            }
            if (!splitDamage) {
              for (final i in range(1, kEquipmentMax.companion)) {
                final equipData = target.equipments.companion[i]
                if (equipData) {
                  final companion = getEquipped(equipData, target)
                  // assert(shareDamageCompanion.effects.containsKey(kEffectDefendByChance))
                  if (Math.random() < companion.effects[kEffectDefendByChance].values[0].value) {
                    splitDamage = true
                    final shareDamage = baseDamage * companion.effects[kEffectDefendByChance].values[1].value
                    message = getLocaleString(sneakAttack ? 'sneakShareDamageInfo' : 'shareDamageInfo', [
                      subject.name,
                      subjectInfo.activatedOffense.name,
                      target.name,
                      (baseDamage - shareDamage).truncate(),
                      companion.name,
                      shareDamage.truncate(),
                    ])
                    engine.info(message)
                    actions.add(Action(
                      activatedOffenseIndex: subjectInfo.activatedOffenseIndex,
                      speed: subjectInfo.activatedOffense.stats.speed,
                      damage: baseDamage - shareDamage,
                      message: message,
                      companionIndex: i,
                      shareDamage: shareDamage,
                    ))
                    entityTakeDamage(targetInfo, baseDamage - shareDamage)
                    entityTakeDamage(targetInfo.stats.companion[i], shareDamage)
                    break
                  }
                }
              }
            }

            if (!splitDamage) {
              message = getLocaleString(sneakAttack ? 'sneakDamageInfo' : 'damageInfo', [
                subject.name, 
                subjectInfo.activatedOffense.name,
                target.name,
                baseDamage.truncate(),
              ])
              engine.info(message)
              actions.add(Action(
                activatedOffenseIndex: subjectInfo.activatedOffenseIndex,
                speed: subjectInfo.activatedOffense.stats.speed,
                damage: baseDamage,
                message: message,
              ))
              entityTakeDamage(targetInfo, baseDamage)
            }

            this.messages.add(message)
            
            subjectInfo.ticks = 0
            // if (info.activatedDefense.stats.life <= 0) {
            //   info.targetIndex = setNextActivatedDefenseItem(info, target)
            // }
            // 收招
            ++subjectInfo.activatedOffenseIndex
            if (subjectInfo.activatedOffenseIndex > subject.equipments.offense.length) {
              subjectInfo.activatedOffenseIndex = 1
            }
            subjectInfo.activatedOffense =
              getEquipped(subject.equipments.offense[subjectInfo.activatedOffenseIndex], subject)
          } else {
            ++subjectInfo.ticks
          }

          if (targetInfo.stats.life <= 0) {
            return true
          }
        }

        var firstMove = true

        while (true) {
          if (this.frames >= _kDuelticksLimit) {
            // this.messages.add(getLocaleString('drawGame'))
            this.tied = true
            break
          }

          var r
          if (firstMove) {
            firstMove = false
            final initiativeSum = char1.attributes.perception + char2.attributes.perception
            final initiativeValue = initiativeSum * Math.random()
            if (char1.attributes.perception > initiativeValue) {
              r = _nextTick(char1info, sneakAttack: type == kDuelTypeSneakAttack)
            }
          } else {
            r = _nextTick(char1info)
          }
          if (r) {
            engine.info('${char1.name} 和 ${char2.name} 的战斗结束了。${char1.name} 获胜。')
            this.result = true
            break
          }

          r = _nextTick(char2info, enemyTurn: true)
          if (r) {
            engine.info('${char1.name} 和 ${char2.name} 的战斗结束了。${char2.name} 获胜。')
            break
          }

          ++this.frames
        }
      }
    }

    // 双方结束时的状态
    this.resultStats = {
      char1: char1info.stats,
      char2: char2info.stats,
    }

    if (type != kDuelTypePractice) {
      char1.stats = char1info.stats
      char2.stats = char2info.stats
    }
    
    // if (config.debug) {
    //   engine.info(this)
    // }
  }
}
