import 'game.ht'
import 'l10n.ht'
import 'entity/common.ht'
import 'entity/item/common.ht'
import 'entity/character/character.ht'
import 'effect.ht'

/// 战斗模块
/// 输入战斗相关角色的对象
/// 生成战斗过程的文字描述，以及最终结果

external fun _showDuel(context, char1, char2, [ type, data ])

fun showDuel(char1, char2, { type, onCallback: ( any ) -> any }) -> Future {
  final duelResult = Duel(char1, char2, type: type);
  return _showDuel(buildContext, char1, char2, type, duelResult)
}

// damage = ((1 / (Math.log((victim.defense + 5) / 100) + 5)) * 2 * attacker._attack)

const kDuelTypePractice = 'practice'
const kDuelTypeSneakAttack = 'sneakAttack'
const _kDuelticksLimit = 500

// fun _attack(offenseItem, defenseItem, log) {
  // var offset = 0
  // final defenseValue = defenseItem.stats.defense ?? 0
  // if (defenseValue > 0) {
  //   offset = Math.gaussianNoise(defenseValue, defenseValue * 0.25, min: defenseValue * 0.5 max: defenseValue)
  // }
  // final damage = offenseItem.stats.damage - offset
  // return damage
// }

struct Action {
  construct ({
    message,
    activatedOffenseIndex = 0,
    speed,
    damage = 0,
    itemIndex,
    companionIndex,
    shareDamage = 0,
  }) {
    assert(message != null)
    this.activatedOffenseIndex = activatedOffenseIndex
    this.speed = speed
    this.damage = damage
    this.message = message
    this.itemIndex = itemIndex
    this.companionIndex = companionIndex
    this.shareDamage = shareDamage
  }
}

struct Duel {
  construct(char1, char2, { type }) {
    this.messages = []
    this.actions = {
      char1: [],
      char2: [],
    }

    // 保存战斗开始时双方的初始状态
    this.initialStats = {
      char1: getCharacterStats(char1),
      char2: getCharacterStats(char2),
    }
    
    final char1info = {
      ticks: 0,
      activatedOffenseIndex: 1, // 当前激活的进攻手段，1代表第一个武器或斗技
      // 复制出来的人物当前状态，包括生命值等
      stats: this.initialStats.char1.clone(),
    }
    final char2info = {
      ticks: 0,
      activatedOffenseIndex: 1,
      stats: this.initialStats.char2.clone(),
    }

    this.started = false
    if (char1.equipments.offense.isEmpty) {
      // 如果没有装备任何武器或者战斗技能，则直接判负
      engine.info(getLocaleString('无法开始战斗：${char1.name} 没有装备武器。'))
      this.result = false
    } else if (char2.equipments.offense.isEmpty) {
      engine.info(getLocaleString('无法开始战斗：${char2.name} 没有装备武器。'))
      this.result = true
    } else {
      this.result = false
      this.tied = false
      // 战斗本身的客观时间，不会受任何因素影响
      this.frames = 0
      char1info.activatedOffense = getFirstEquippedOffenseItem(char1)
      char2info.activatedOffense = getFirstEquippedOffenseItem(char2)

      // 设置人物当前防护物品位置，0 = 无防护物品
      // fun setNextActivatedDefenseItem(info, character) {
      //   for (final i = 1; i < _kDefenseEquipmentMax) {
      //     final item = 
      //     if (item.stats.life > 0) {
      //       info.activatedDefense = item
      //       return i + 1
      //     }
      //   }
      //   // 没有找到防护装备，伤害会直接作用于人物本身
      //   info.activatedDefense = info.entity
      //   return 0
      // }
      
      // char1info.targetIndex = setNextActivatedDefenseItem(char2info, char2)
      // char2info.targetIndex = setNextActivatedDefenseItem(char1info, char1)
      this.started = true

      if (this.started) {

        // 如果目标声明小于0，返回true
        fun nextTick({ enemyTurn = false, sneakAttack = false }) {
          final actions = enemyTurn ? this.actions.char2 : this.actions.char1
          final subject = enemyTurn ? char2 : char1
          final subjectInfo = enemyTurn ? char2info : char1info
          final target = enemyTurn ? char1 : char2
          final targetInfo = enemyTurn ? char1info : char2info

          // 出招等待阶段
          if (subjectInfo.ticks >= subjectInfo.activatedOffense.stats.speed) {
            // 出招
            final baseDamage = subjectInfo.activatedOffense.stats.damage

            // 战斗文字信息
            var message
            // 是否被某个防御物品或者战斗伙伴分担伤害
            var shareDamage
            var assistDamage

            // 处理分担伤害
            fun handleDefendEffect({effect, item, index, isCompanion = false}) {
              if (effect.category != kEffectCategoryDefend) return false
              final effectHandler = getEffectHandlerById(effect.id)
              if (effectHandler == null) {
                engine.error('找不到效果 ${effect.id} 对应的处理函数。')
                return false
              }
              assert(effectHandler is function)
              shareDamage = effectHandler(effect, baseDamage)
              if (shareDamage) {
                message = getLocaleString(sneakAttack ? 'sneakShareDamageInfo' : 'shareDamageInfo', [
                  subject.name,
                  subjectInfo.activatedOffense.name,
                  target.name,
                  (baseDamage - shareDamage).truncate(),
                  item.name,
                  shareDamage.truncate(),
                ])
                final action = Action(
                  activatedOffenseIndex: subjectInfo.activatedOffenseIndex,
                  speed: subjectInfo.activatedOffense.stats.speed,
                  damage: baseDamage - shareDamage,
                  message: message,
                  shareDamage: shareDamage,
                )
                if (isCompanion) {
                  action.companionIndex = index
                } else {
                  action.itemIndex = index
                }
                actions.add(action)
                entityTakeDamage(targetInfo, baseDamage - shareDamage)
                final equipItemStats = isCompanion ? targetInfo.stats.companion[index] : targetInfo.stats.defense[index]
                entityTakeDamage(equipItemStats, shareDamage)
                return true
              }
              return false
            }

            // 战斗伙伴的伤害增强效果，这里会直接修改baseDamage
            fun handleCompanionAssistEffect({effect, companion, index}) {
              if (effect.category != kEffectCategoryDamage) return false
              final effectHandler = getEffectHandlerById(effect.id)
              if (effectHandler == null) {
                engine.error('找不到效果 ${effect.id} 对应的处理函数。')
                return false
              }
              assert(effectHandler is function)
              assistDamage = effectHandler(effect, baseDamage)
              if (assistDamage) {
                message = getLocaleString('assistDamageInfo', [
                  subject.name,
                  companion.name,
                  target.name,
                  assistDamage.truncate(),
                ])
                actions.add(Action(
                  activatedOffenseIndex: subjectInfo.activatedOffenseIndex,
                  speed: subjectInfo.activatedOffense.stats.speed,
                  damage: assistDamage,
                  message: message,
                ))
                entityTakeDamage(targetInfo, assistDamage)
                return true
              }
              return false
            }
            
            // 遍历进攻方战斗伙伴，检查是否有协同进攻，增强伤害效果
            for (final i in range(1, kEquipmentMax.companion)) {
              final equipData = subject.equipments.companion[i]
              if (!equipData) continue
              final companion = getEquipped(equipData, subject)
              for (final effect of companion.effects) {
                final assisted = handleCompanionAssistEffect(
                  effect: effect,
                  companion: companion,
                  index: i,
                )
                if (assisted) break
              }
            }
            
            // 遍历防守方的物品和战斗伙伴，检查是否有分担伤害效果
            for (final i in range(1, kEquipmentMax.defense)) {
              final equipData = target.equipments.defense[i]
              if (!equipData) continue
              final item = getEquipped(equipData, target)
              for (final effect of item.effects) {
                final defended = handleDefendEffect(
                  effect: effect,
                  item: item,
                  index: i,
                )
                if (defended) break
              }
            }
            // 只有当物品没有防御住时，才会尝试触发战斗伙伴的分担伤害
            if (!assistDamage) {
              for (final i in range(1, kEquipmentMax.companion)) {
                final equipData = target.equipments.companion[i]
                if (!equipData) continue
                final companion = getEquipped(equipData, target)
                for (final effect of companion.effects) {
                  final defended = handleDefendEffect(
                    effect: effect,
                    item: companion,
                    index: i,
                    isCompanion: true,
                  )
                  if (defended) break
                }
              }
            }

            // 没有额外效果的进攻
            if (!shareDamage && !assistDamage) {
              message = getLocaleString(sneakAttack ? 'sneakDamageInfo' : 'damageInfo', [
                subject.name, 
                subjectInfo.activatedOffense.name,
                target.name,
                baseDamage.truncate(),
              ])
              actions.add(Action(
                activatedOffenseIndex: subjectInfo.activatedOffenseIndex,
                speed: subjectInfo.activatedOffense.stats.speed,
                damage: baseDamage,
                message: message,
              ))
              entityTakeDamage(targetInfo, baseDamage)
            }

            this.messages.add(message)
            // engine.info(message)
            
            subjectInfo.ticks = 0
            // if (info.activatedDefense.stats.life <= 0) {
            //   info.targetIndex = setNextActivatedDefenseItem(info, target)
            // }
            // 收招
            ++subjectInfo.activatedOffenseIndex
            if (subjectInfo.activatedOffenseIndex > subject.equipments.offense.length) {
              subjectInfo.activatedOffenseIndex = 1
            }
            subjectInfo.activatedOffense =
              getEquipped(subject.equipments.offense[subjectInfo.activatedOffenseIndex], subject)
          } else {
            ++subjectInfo.ticks
          }

          if (targetInfo.stats.life <= 0) {
            return true
          }
        }

        var firstMove = true

        while (true) {
          if (this.frames >= _kDuelticksLimit) {
            // this.messages.add(getLocaleString('drawGame'))
            this.tied = true
            break
          }
          ++this.frames

          var r
          if (firstMove) {
            firstMove = false
            final initiativeSum = char1.attributes.perception + char2.attributes.perception
            final initiativeValue = initiativeSum * Math.random()
            if (char1.attributes.perception > initiativeValue) {
              r = nextTick(char1info, sneakAttack: type == kDuelTypeSneakAttack)
            }
          } else {
            r = nextTick(char1info)
          }
          if (r) {
            engine.info('${char1.name} 和 ${char2.name} 的战斗结束了。${char1.name} 获胜。')
            this.result = true
            break
          }

          r = nextTick(char2info, enemyTurn: true)
          if (r) {
            engine.info('${char1.name} 和 ${char2.name} 的战斗结束了。${char2.name} 获胜。')
            break
          }
        }
      }
    }

    // 双方结束时的状态
    this.resultStats = {
      char1: char1info.stats,
      char2: char2info.stats,
    }

    if (type != kDuelTypePractice) {
      for (final i in range(1, kEquipmentMax.offense)) {
        final char1EquippedItem = char1.equipments.offense[i]
        if (char1EquippedItem) {
          final char1ItemStats = char1info.stats.offense[i]
          char1EquippedItem.stats = char1ItemStats
        }
        final char2EquippedItem = char2.equipments.offense[i]
        if (char2EquippedItem) {
          final char2ItemStats = char2info.stats.offense[i]
          char2EquippedItem.stats = char2ItemStats
        }
      }
      delete char1info.stats.offense

      for (final i in range(1, kEquipmentMax.defense)) {
        final char1EquippedItem = char1.equipments.defense[i]
        if (char1EquippedItem) {
          final char1ItemStats = char1info.stats.defense[i]
          char1EquippedItem.stats = char1ItemStats
        }
        final char2EquippedItem = char2.equipments.defense[i]
        if (char2EquippedItem) {
          final char2ItemStats = char2info.stats.defense[i]
          char2EquippedItem.stats = char2ItemStats
        }
      }
      delete char1info.stats.defense

      for (final i in range(1, kEquipmentMax.companion)) {
        final char1EquippedItem = char1.equipments.companion[i]
        if (char1EquippedItem) {
          final char1ItemStats = char1info.stats.companion[i]
          char1EquippedItem.stats = char1ItemStats
        }
        final char2EquippedItem = char2.equipments.companion[i]
        if (char2EquippedItem) {
          final char2ItemStats = char2info.stats.companion[i]
          char2EquippedItem.stats = char2ItemStats
        }
      }
      delete char1info.stats.companion

      char1.stats = char1info.stats
      char2.stats = char2info.stats
    }
    
    // if (config.debug) {
    //   engine.info(this)
    // }
  }
}
