import 'game.ht'
import 'generator/random_names/random_names.ht' as randomNames

struct Site {
  construct ({
    category,
    name,
    location,
    image,
  }) {
    assert(location != null)
    assert(category != null)

    this.index = location.sites.length
    this.category = category
    this.name ??= getLocaleString(category)

    this.locationId = location.id
    this.id = '${location.id}_site_${this.index}_${this.name}'
    this.image ??= 'location/site/${category}.png'

    location.sites[this.id] = this
  }
}

struct Location {
  construct ({
    terrainIndex,
    category,
    name,
    development,
  }) {
    assert(terrainIndex != null)
    this.terrainIndex = terrainIndex
    this.index = game.locations.length
    if (name) {
      this.name = name
    } else {
      final names = randomNames.getLocation(1, category: category)
      this.name = names.first.name
    }
    this.category = category
    this.id = 'location_${this.index}_${this.name}'
    
    // 据点发展度
    // 发展度决定了据点所能拥有的普通居民人口上限，以及所能拥有建筑的数量
    // 最少是 1，最多是 18
    this.development = development ?? 1

    // 在野修士
    this.wildCharacterIds = Set()
    // 门派修士
    this.organizedCharacterIds = Set()

    // 普通居民决定了税收收入，以及外门弟子的数量
    final minP = maxPopulationOfLocationDevelopment(this.development - 1)
    final maxP = maxPopulationOfLocationDevelopment(this.development)
    this.population = Math.randomInt(maxP - minP) + minP
    
    // 外门弟子数量，记录在据点数据中，不算做门派属性
    this.disciple = 0
  
    this.sites = {}
    Site(category: 'residence', location: this)

    // 当地居民的稳定度，0 ~ 100
    this.stable = 100

    game.locations[this.id] = this
  }
}

// 每个城市发展度，都会产生新的带有灵根的角色
// 但这些角色并不会立即出现，而是只能依靠探查搜寻的方式找到
// 并且每次找到的数量是有上限的
fun maxPopulationOfLocationDevelopment(n: int) {
  final base = (n - 1) * (n - 1) * (n - 1) * 50 + 100

  return base
}

fun maxSiteNumberOfLocationDevelopment(n: int) {
  return n + 2
}

/// 定期产生可供选择的有名有姓的人物作为内门弟子
/// 第一次出现时通常为练气境界
/// 产生的内门弟子数量，一开始是 1 个，最高是 8 个
/// 这个数量和外门弟子数量，修炼场的等级
/// 执行训练任务的长老属性和技能，等等都有关系
fun maxNumberOfWildCharacterPerDevelopment() {
  return n * n - n * 2 + 2
}

// 每个据点，每个月会自然增加人口，直到达到上限
// 人口上限会受到掌门的技能，门派的发展度和价值观，以及据点的发展度和建筑所影响
fun increaseLocationPopulationPerMonth(location) {

}

fun addLocation(loc) {
  game.locations[loc.id] = loc
}

fun addLocations(locs: List) {
  if (game.debug) {
    print('河图: 载入地点数据 ...')
  }
  for (final loc in locs) {
    if (loc.nameId) {
      loc.name = getLocaleString(loc.nameId)
    }
    game.locations[loc.id] = loc
  }
}

fun setHeroLocationId(id: str) {
  assert(game.locations.containsKey(id))
  if (game.debug) {
    print('河图: 设置玩家当前地点为 [${id}] ...')
  }
  final hero = game.characters[game.heroId]
  hero.currentLocationId = id
}

fun getLocationById(id: str) {
  return game.locations[id]
}

fun getLocations() {
  return game.locations
}

fun getSiteById(siteId: str, locationId: str) {
  assert(game.locations.containsKey(locationId))
  final location = game.locations[locationId]
  assert(location.sites.containsKey(siteId))
  return location.sites[siteId]
}

fun onEnteredLocation(id: str) {
  final entity = getEntityById(id)
  if (entity != null) {
    final handler = entity.onEntered
    if (handler is function) {
      handler()
    }
  }
}

fun onEnteredScene(id: str, [extra: str]) {
  final entity = getEntityById(id)
  if (entity != null) {
    final handler = entity.onEntered
    if (handler is function) {
      handler()
    }
  }
}

fun handleSiteInteraction(siteId: str, locationId: str) {
  final site = getSiteById(siteId, locationId)
  if (site != null) {
    when (site.category) {
      'residence' -> _handleResidenceInteraction(site)
      'headquarters' -> _handleHeadquartersInteraction(site)
      'advancedResidence' -> _handleAdvancedResidenceInteraction(site)
      'library' -> _handleLibraryInteraction(site)
      'farmland' -> _handleFarmlandInteraction(site)
      'mine' -> _handleMineInteraction(site)
      'timberland' -> _handleMineInteraction(site)
      'market' -> _handleMarketInteraction(site)
      'shop' -> _handleShopInteraction(site)
      'restaurant' -> _handleRestaurantInteraction(site)
      'arena' -> _handleArenaInteraction(site)
      'nursery' -> _handleNurseryInteraction(site)
      'workshop' -> _handleWorkshopInteraction(site)
      'alchemylab' -> _handleAlchemylabInteraction(site)
      'smithshop' -> _handleSmithshopInteraction(site)
      'zenyard' -> _handleZenroomInteraction(site)
      'zoo' -> _handleZooInteraction(site)
      'maze' -> _handleMazeInteraction(site)
      else -> {
        print('河图: 错误: 未知的地区类型。')
      }
    }
  }
}

fun searchCharactersAtSite(siteId: str) {
  return game.characters.where((siteId) {
    char.currentSiteId == currentSiteId
  })
}

fun _handleResidenceInteraction(scn) {

}

fun _handleHeadquartersInteraction(scn) {
  // final characters = searchCharactersAtScene(scn.id)
  // if (characters.isNotEmpty) {
  //   handleCharacterInteraction(characters.first)
  // }
}

fun _handleAdvancedResidenceInteraction(scn) {

}

fun _handleLibraryInteraction(scn) {

}

fun _handleFarmlandInteraction(scn) {

}

fun _handleMineInteraction(scn) {

}

fun _handleMarketInteraction(scn) {

}

fun _handleShopInteraction(scn) {

}

fun _handleRestaurantInteraction(scn) {

}

fun _handleArenaInteraction(scn) {

}

fun _handleNurseryInteraction(scn) {

}

fun _handleWorkshopInteraction(scn) {

}

fun _handleAlchemylabInteraction(scn) {

}

fun _handleSmithshopInteraction(scn) {

}

fun _handleZenroomInteraction(scn) {

}

fun _handleZooInteraction(scn) {

}

fun _handleMazeInteraction(scn) {

}