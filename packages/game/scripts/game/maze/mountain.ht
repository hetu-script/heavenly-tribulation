import '../tile/hexagonal_tile.ht'
import '../tile/tilemap.ht'
import '../game.ht'
import '../tile/object.ht'
import '../entity/character/enemy/bandit.ht'
import '../entity/character/enemy/beast.ht'
import '../entity/constants.ht'
import '../binding/maze.ht'

final _kLandSprites = [
  kSpriteLand,
  kSpriteGrassLand,
]

const _kDefaultBlockWidth = 4
const _kDefaultBlockHeight = 4
const _kDefaultMazeScale = 3
final _kDefaultBlockNumber = _kDefaultMazeScale * _kDefaultMazeScale

const _kEncounterProbability = 0.5

final _kEncounterTypes = [
  'bandit',
  'beast',
  // 'pileOfBones',
  // 'chest',
  // 'lostTraveller',
  // 'ancientTree',
  // 'woodcutter',
  // 'fisherman',
  // 'hunter',
  // 'peddler',
]

final _kUniqueEncounterTypes = [
  'trappedAdventurer',
  'anotherAdventurer',
  'vigilantePeasant',
  'uniqueTreasure',
  'undercoverCaptor',
  'undercoverRoyalGuard',
]

final _kUniqueScene = [
  'restaurant',
  'inn',
  'teaShop',
  'hotel',
  'buddaTemple',
  'taoistTemple',
  'lake',
  'waterfall',
  'cliffBridge',
  'riverBridge',
]

final _kBlockTypes = [
  // 'empty',
  'bush',
  'rock',
]

// 所有路径名字
final _kRoutes = [
  'topLeft',
  'topRight',
  'leftTop',
  'centerTop',
  'rightTop',
  'centerLeft',
  'centerRight',
  'leftBottom',
  'centerBottom',
  'rightBottom',
  'bottomLeft',
  'bottomRight',
]

// 每个锚点所连接的路径
final _kRoutesOfAnchor = {
  '1': ['topLeft', 'topRight'],
  '2': ['topLeft', 'topRight', 'centerTop'],
  '3': ['topRight', 'rightTop'],
  '4': ['leftTop', 'centerLeft', 'leftBottom'],
  '5': ['centerTop', 'centerLeft', 'centerRight', 'centerBottom'],
  '6': ['rightTop', 'centerRight', 'rightBottom'],
  '7': ['leftBottom', 'bottomLeft'],
  '8': ['bottomLeft', 'bottomRight', 'centerBottom'],
  '9': ['rightBottom', 'bottomRight'],
}

fun _random2(list) {
  final l = list.toList()
  l.shuffle()
  return [l.first, l.last]
}

// 执行这个函数时地图尚未生成，因此不需要考虑zone，所以无需使用真正的terrain来计算
fun _generateRoute(index1, index2, map) {
  final tile1 = index2TilePos(index1, map.width)
  final tile2 = index2TilePos(index2, map.width)
  // print('generate route from ${tile1} to ${tile2}')
  final route = calculateRoute(tile1, tile2, map)
  // print(route)
  if (route) {
    for (final index in route) {
      final terrain = map.terrains[index]
      terrain.isRoute = true
    }
  } else {
    final terrain = map.terrains[index1]
    terrain.isRoute = true
  }
}

fun generateRoute(name, anchors, map) {
  when (name) {
    'topLeft' -> _generateRoute(anchors[1].index, anchors[2].index, map)
    'topRight' -> _generateRoute(anchors[2].index, anchors[3].index, map)
    'leftTop' -> _generateRoute(anchors[1].index, anchors[4].index, map)
    'centerTop' -> _generateRoute(anchors[2].index, anchors[5].index, map)
    'rightTop' -> _generateRoute(anchors[3].index, anchors[6].index, map)
    'centerLeft' -> _generateRoute(anchors[4].index, anchors[5].index, map)
    'centerRight' -> _generateRoute(anchors[5].index, anchors[6].index, map)
    'leftBottom' -> _generateRoute(anchors[4].index, anchors[7].index, map)
    'centerBottom' -> _generateRoute(anchors[5].index, anchors[8].index, map)
    'rightBottom' -> _generateRoute(anchors[6].index, anchors[9].index, map)
    'bottomLeft' -> _generateRoute(anchors[7].index, anchors[8].index, map)
    'bottomRight' -> _generateRoute(anchors[8].index, anchors[9].index, map)
  }
}

// fun addMazeObject(object, map) {
//   if (object.entityId) {
//     final tileIndex = tilePos2Index(object.left, object.top, map.width)
//     final tile = map.terrains[tileIndex]
//     tile.objectIndex = map.objects.length
//   }
//   map.objects.add(object)
// }

/// 生成Roguelike副本的算法
fun createMaze ({
    id = 'unknown_maze',
    levelNumber = 1,
    isOnWorldMap = true,
    tileset = 'mountain',
    encounters = _kEncounterTypes,
  }) {
  engine.info('开始生成副本: ${id}')

  final maze = {
    levels: [], // 每一层是一个单独的 tilemap
    currentLevel: 0,
    entities: {}, // 包含所有显示在地图上的可互动对象，包括NPC、敌人、宝箱、陷阱、机关等等。
    history: [], // 本次副本中发生的事件记录，这些事件不会计入世界历史
  }

  // 已经被分配了的地块
  final occupied = Set()

  fun randomPosition(width, height, mapWidth, [offsetX = 0, offsetY = 0]) {
    assert(width > 2)
    assert(height > 2)
    // if (occupied.length >= (width * height - width * 2 - (height - 2) * 2)) {
    //   throw 'all tiles have been occupied!'
    // }
    var left
    var top
    var index
    do {
      left = Math.randomInt(width) + 1 + offsetX
      top = Math.randomInt(height) + 1 + offsetY
      index = tilePos2Index(left, top, mapWidth)
    } while (occupied.contains(index))
    occupied.add(index)
    return { index, left, top }
  }

  for (final levelIndex in range(levelNumber)) {
    final [ width, height ] = [ _kDefaultBlockWidth * _kDefaultMazeScale, _kDefaultBlockHeight * _kDefaultMazeScale ]
    final terrainSize = width * height

    final currentLevel = TileMap(
      scene: 'maze_${id}_${levelIndex}',
      width: width,
      height: height,
    )

    engine.info('生成迷宫地块')
    final landZone = Zone(index: currentLevel.zones.length, category: kZoneContinent)
    currentLevel.zones.add(landZone)
    for (var j in range(height)) {
      for (var i in range(width)) {
        // final isVoid = (i == 0) || (i == width - 1) || (j == 0) || (j == height - 1)
        final terrain = {
          ...Tile(i + 1, j + 1, mapWidth: width),
          isVisible: false,
          isSelectable: true,
          showGrid: true,
          // spriteIndex: isVoid ? null : _kLandSprites.random,
          spriteIndex: _kLandSprites.random,
          overlaySprite: {},
        }
        currentLevel.terrains.add(terrain)
        addTerrainToZone(terrain, landZone.index, currentLevel)
      }
    }
    
    engine.info('计算出入口')
    // 可能的出入口
    final possibleEntries = [
      { ...Tile(1, 1, mapWidth: width) },
      { ...Tile(width, 1, mapWidth: width) },
      { ...Tile(1, height, mapWidth: width) },
      { ...Tile(width, height, mapWidth: width) },
    ]
    possibleEntries.shuffle()
    final entry = possibleEntries.first
    occupied.add(entry.index)
    currentLevel.entryX = entry.left
    currentLevel.entryY = entry.top
    final entryEntity = TileMapObject(
      terrainIndex: entry.index,
      left: entry.left,
      top: entry.top,
      spriteSrc: 'maze/roadsign01.png',
      srcWidth: 32.0,
      srcHeight: 32.0,
    )
    currentLevel.objects.add(entryEntity)
    final exit = possibleEntries.last
    occupied.add(exit.index)
    currentLevel.exitX = exit.left
    currentLevel.exitX = exit.top
    final exitEntity = TileMapObject(
      terrainIndex: exit.index,
      left: exit.left,
      top: exit.top,
      spriteSrc: 'maze/roadsign01.png',
      srcWidth: 32.0,
      srcHeight: 32.0,
    )
    currentLevel.objects.add(exitEntity)

    engine.info('计算随机遭遇的位置')
    final blockSize = terrainSize / 9
    var isOnCorner = false
    // 迷宫中的主要roguelike元素的可能位置锚点，分布在横三竖三的9个区块中
    // 四个角的锚点需要避免位于可能的出入口上
    final anchors = {}
    // 左上角
    anchors[1] = randomPosition(_kDefaultBlockWidth, _kDefaultBlockHeight, width, 0, 0)
    // 正上方
    anchors[2] = randomPosition(_kDefaultBlockWidth, _kDefaultBlockHeight, width, _kDefaultBlockWidth, 0)
    // 右上角
    anchors[3] = randomPosition(_kDefaultBlockWidth, _kDefaultBlockHeight, width, _kDefaultBlockWidth * 2, 0)
    // 左边
    anchors[4] = randomPosition(_kDefaultBlockWidth, _kDefaultBlockHeight, width, 0, _kDefaultBlockHeight)
    // 正中
    anchors[5] = randomPosition(_kDefaultBlockWidth, _kDefaultBlockHeight, width, _kDefaultBlockWidth, _kDefaultBlockHeight)
    // 右边
    // 正中
    anchors[6] = randomPosition(_kDefaultBlockWidth, _kDefaultBlockHeight, width, _kDefaultBlockWidth * 2, _kDefaultBlockHeight)
    // 左下角
    anchors[7] = randomPosition(_kDefaultBlockWidth, _kDefaultBlockHeight, width, 0, _kDefaultBlockHeight * 2)
    // 正下方
    anchors[8] = randomPosition(_kDefaultBlockWidth, _kDefaultBlockHeight, width, _kDefaultBlockWidth, _kDefaultBlockHeight * 2)
    // 右下角
    anchors[9] = randomPosition(_kDefaultBlockWidth, _kDefaultBlockHeight, width, _kDefaultBlockWidth * 2, _kDefaultBlockHeight * 2)

    // print(anchors)

    possibleEntries[0].nearestAnchor = anchors[1].index
    possibleEntries[1].nearestAnchor = anchors[3].index
    possibleEntries[2].nearestAnchor = anchors[7].index
    possibleEntries[3].nearestAnchor = anchors[9].index
    
    engine.info('在锚点放置遭遇')
    for (final anchor of anchors) {
      final r = Math.random()
      if (r < _kEncounterProbability) {
        final encounterType = encounters.random
        when (encounterType) {
          'bandit' -> {
            final enemyEntity = Bandit()
            enemyEntity.encounterType = encounterType
            maze.entities[enemyEntity.id] = enemyEntity
            final enemyObject = TileMapObject(
              terrainIndex: anchor.index,
              left: anchor.left,
              top: anchor.top,
              spriteSrc: 'maze/enemy01.png',
              srcWidth: 32.0,
              srcHeight: 32.0,
              entityId: enemyEntity.id,
            )
            currentLevel.objects.add(enemyObject)
          }
          'beast' -> {
            final enemyEntity = Beast()
            enemyEntity.encounterType = encounterType
            maze.entities[enemyEntity.id] = enemyEntity
            final enemyObject = TileMapObject(
              terrainIndex: anchor.index,
              left: anchor.left,
              top: anchor.top,
              spriteSrc: enemyEntity.icon,
              srcWidth: 32.0,
              srcHeight: 32.0,
              entityId: enemyEntity.id,
            )
            currentLevel.objects.add(enemyObject)
          }
          // 'chest' -> {
          //   final chest = TileMapObject(
          //     terrainIndex: anchor.index,
          //     left: anchor.left,
          //     top: anchor.top,
          //     spriteSrc: 'maze/chest02.png',
          //     srcWidth: 32.0,
          //     srcHeight: 32.0,
          //   )
          //   currentLevel.objects.add(chest)
          // }
        }
      }
    }

    // 确保从任意一个角可以到达所有锚点的算法
    // 链接所有九个锚点的路径一共有9种（字母含义为left, right, top, bottom）：
    //
    //     1--tl--2--tr--3
    //     |      |      |
    //     lt     ct     rt
    //     |      |      |
    //     4--cl--5--cr--6
    //     |      |      |
    //     lb     cb     rb
    //     |      |      |
    //     7--bl--8--br--9
    //
    // 要想让一次可以经过所有的锚点，最少需要8个路径
    // 为了保证角落和中心必然可以到达，角落和中心会必然单独随机分配一个路径
    // 剩下的路径则随机分配
    engine.info('确保各个锚点之间的通路')
    final routes = Set() // 最终结果
    final middleAnchors = [2,4,6,8]
    middleAnchors.shuffle()
    for (final point in middleAnchors) {
      routes.addAll(_random2(_kRoutesOfAnchor[point]))
    }
    for (final name in routes) {
      // print('initial routes: ${name}')
      generateRoute(name, anchors, currentLevel)
    }
    // check if there's a unconnected
    if (!routes.contains('topLeft') && !routes.contains('centerLeft') && !routes.contains('bottomLeft')) {
      final name = ['topLeft', 'centerLeft', 'bottomLeft'].random
      // print('add route to blank parallel: ${name}')
      generateRoute(name, anchors, currentLevel)
    }
    if (!routes.contains('topRight') && !routes.contains('centerRight') && !routes.contains('bottomRight')) {
      final name = ['topRight', 'centerRight', 'bottomRight'].random
      // print('add route to blank parallel: ${name}')
      generateRoute(name, anchors, currentLevel)
    }
    if (!routes.contains('leftTop') && !routes.contains('centerTop') && !routes.contains('rightTop')) {
      final name = ['leftTop', 'centerTop', 'rightTop'].random
      // print('add route to blank parallel: ${name}')
      generateRoute(name, anchors, currentLevel)
    }
    if (!routes.contains('leftBottom') && !routes.contains('centerBottom') && !routes.contains('rightBottom')) {
      final name = ['leftBottom', 'centerBottom', 'rightBottom'].random
      // print('add route to blank parallel: ${name}')
      generateRoute(name, anchors, currentLevel)
    }
    // check if there's any anchor left as unconnected
    final restAnchors = [1,3,5,7,9]
    for (final anchor in restAnchors) {
      final index = anchors[anchor].index
      final tile = currentLevel.terrains[index]
      if (!tile.isRoute) {
        final name = _kRoutesOfAnchor[anchor].random
        // print('add name to empty anchor: ${name}')
        generateRoute(name, anchors, currentLevel)
      }
    }
    // 最后再联通到入口和出口上
    _generateRoute(entry.index, entry.nearestAnchor, currentLevel)
    _generateRoute(exit.index, exit.nearestAnchor, currentLevel)

    // 在非路径非锚点非出入点的地块上生成装饰物
    engine.info('生成装饰物')
    final blockZone = Zone(index: currentLevel.zones.length, category: 'block')
    currentLevel.zones.add(blockZone)
    for (final tile in currentLevel.terrains) {
      if (occupied.contains(tile.index)) continue
      if (tile.isRoute) continue
      // print('adding decor to ${tile.index}')
      tile.isSelectable = false
      addTerrainToZone(tile, blockZone.index, currentLevel)
      final blockType = _kBlockTypes.random
      when (blockType) {
        'bush' -> {
          final bush = TileMapObject(
            terrainIndex: tile.index,
            left: tile.left,
            top: tile.top,
            spriteSrc: 'maze/bush.png',
            srcWidth: 32.0,
            srcHeight: 48.0,
          )
          currentLevel.objects.add(bush)
        }
        'rock' -> {
          final rock = TileMapObject(
            terrainIndex: tile.index,
            left: tile.left,
            top: tile.top,
            spriteSrc: 'maze/rock.png',
            srcWidth: 32.0,
            srcHeight: 48.0,
          )
          currentLevel.objects.add(rock)
        }
      }
    }
    engine.info('生成路标')
    maze.levels.add(currentLevel)
  }
  
  engine.info('副本 ${id} 生成完毕')

  if (isOnWorldMap) {
    world.mazes[maze.id] = maze
  }

  return maze
}

// 返回布尔值，如果为真，则玩家控制角色会返回上一格，否则停在这一格
fun handleMazeEntityInteraction(entityId, left, top, maze) -> bool {
  final hero = getHero()
  final entity = maze.entities[entityId]
  assert(entity != null)
  engine.info('地图对象互动事件：[${entity.encounterType}: ${entity.id}]')
  when (entity.encounterType) {
    'bandit' -> {
      final messages = getLocaleString('mazeBandit01').split('/n')
      showDialogByStrings(messages).then((value) {
        final selections = [
          'handOver',
          'plead',
          'escape',
          'fight',
        ]
        showSelectionByLocaleKeys(selections).then((key) {
          when (key) {
            // 现实主义
            'handOver' -> {
              characterGiveMoneyTo(hero, hero.money, entity, maze.history)
              for (final item of hero.inventory) {
                characterGiveItemTo(hero, item, entity, maze.history)
              }
            }
            // 向盗贼求情，是否成功依赖于
            // 圆滑
            'plead' -> {
              if (hero.stats.charisma > kCharismaCheckThreshold) {
                showDialogByStrings([getLocaleString('pleadSuccess')])
                  .then((value) {
                    characterGiveMoneyTo(hero, hero.money, entity, maze.history)
                  })
              } else {
                showDialogByStrings([getLocaleString('pleadFailed')])
                .then( (value) =>
                  showDuel(hero, entity).then((value) {
                    if (value) {
                      removeEntity(left, top)
                    } else {
                      gameOver()
                    }
                  })
                )
              }
            }
            // 懦弱
            'escape' -> {
              if (hero.stats.dexterity > entity.stats.dexterity || hero.stats.strength > entity.stats.strength) {
                final incidentContent = getLocaleString('incidentEscapeSuccess', [ entity.name ] )
                Incident(
                  content: incidentContent,
                  subjectIds: [hero.id],
                  isPrivate: true,
                  localHistory: maze.history,
                )
              } else {
                showDialogByStrings([getLocaleString('escapeFailed')])
                .then( (value) => 
                  showDuel(hero, entity).then((value) {
                    if (value) {
                      removeEntity(left, top)
                    } else {
                      gameOver()
                    }
                  })
                )
              }
            }
            // 自信
            'fight' -> {
              showDialogByStrings([getLocaleString('fightBandit')], character: hero)
              .then( (value) => 
                showDuel(hero, entity).then((value) {
                  if (value) {
                    removeEntity(left, top)
                  } else {
                    gameOver()
                  }
                })
              )
            }
          }
        })
      })
    }
    'beast' -> {
      showDuel(hero, entity).then((value) {
        if (value) {
          removeEntity(left, top)
        } else {
          gameOver()
        }
      })
    }
  }
  return true
}
