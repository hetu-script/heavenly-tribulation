import '../tile/tilemap.ht'
import '../tile/hexagonal_tile.ht'
import '../tile/zone.ht'
import '../game.ht'
import '../tile/object.ht'
import '../entity/character/enemy/elder_cultivator.ht'
import '../entity/character/creature/beast.ht'
import '../entity/common.ht'
import '../entity/character/merchant/peddler.ht'
import '../l10n.ht'
import 'common.ht'
import '../binding/maze.ht'
import '../tile/common.ht'
import 'generation_algorithm.ht'

final _kLandSprites = [
  kSpriteLand,
  kSpriteGrassLand,
]

final _kEncounterTypes = [
]

final _kLevelUniqueEncounterTypes = [
]

final _kMazeUniqueEncounterTypes = [
]

final _kUniqueScenes = [
]

/// 生成Roguelike副本的算法
/// 一个Maze包含多个地图，每个地图是一个单独的tilemap
/// 地图之间通过出入口或者传送点互相连接
struct CultivationRecruitMaze {
  construct ({
    name = 'cultivation_recruit_maze',
    tileset = 'cliff',
    bossName,
  }) {
    this.name = name
    this.id = 'maze_${Hash.uid4(4)}_${name}'
    engine.info('开始生成副本: [${this.id}]')

    this.category = kMazeCategoryCultivationRecruit
    this.levels = [] // 每一层是一个单独的 tilemap
    this.currentLevel = 0
    this.entities = {} // 包含所有显示在地图上的可互动对象，包括NPC、敌人、宝箱、陷阱、机关等等。
    this.history = [] // 本次副本中发生的事件记录，这些事件不会计入世界历史
    this.flags = {} // 本次副本中的一些事件存档，用于脚本的一些逻辑判断，例如是否已经有过某种遭遇之类。

    // 创建副本过程中也会触发事件，因此这里要提前给localHistory赋值
    final savedLocalHistory = currentMazeHistory
    currentMazeHistory = this.history

    // 已经被分配了的地块
    final occupied = Set()

    fun randomPosition(width, height, mapWidth, [offsetX = 0, offsetY = 0]) {
      assert(width >= 2)
      assert(height >= 2)
      // if (occupied.length >= (width * height - width * 2 - (height - 2) * 2)) {
      //   throw 'all tiles have been occupied!'
      // }
      var left
      var top
      var index
      do {
        left = random.nextInt(width) + 1 + offsetX
        top = random.nextInt(height) + 1 + offsetY
        index = tilePos2Index(left, top, mapWidth)
      } while (occupied.contains(index))
      occupied.add(index)
      return { index, left, top }
    }

    final [ width, height ] = [ kDefaultBlockWidth * kDefaultMazeScale, kDefaultBlockHeight * kDefaultMazeScale ]
    this.width = width
    this.height = height
    this.currentLevelIndex = 0

    final currentLevel = TileMap(
      id: '${this.id}',
      name: getLocaleString('level', [1]),
      width: width,
      height: height,
    )

    // engine.info('生成迷宫地块')
    final landZone = Zone(index: currentLevel.zones.length, category: kZoneLand)
    currentLevel.zones.add(landZone)
    for (var j in range(height)) {
      for (var i in range(width)) {
        // final isVoid = (i == 0) || (i == width - 1) || (j == 0) || (j == height - 1)
        final terrain = {
          ...Tile(i + 1, j + 1, mapWidth: width),
          isVisible: false,
          isSelectable: true,
        }
        currentLevel.terrains.add(terrain)
        addTerrainToZone(terrain, landZone.index, currentLevel)
      }
    }

    final centerX = width.isOdd ? (width + 1) ~/ 2 : width ~/ 2
    final centerY = height.isOdd ? (height + 1) ~/ 2 : height ~/ 2
    
    // engine.info('计算出入口')
    final entry = Tile(centerX, height, mapWidth: width)
    occupied.add(entry.index)
    currentLevel.entryX = entry.left
    currentLevel.entryY = entry.top
    final entryEntity = {
      id: 'levelEntry',
      encounterType: 'levelEntry',
    }
    this.entities[entryEntity.id] = entryEntity
    currentLevel.terrains[entry.index].entityId = entryEntity.id
    final entryObject = TileMapObject(
      id: entryEntity.id,
      terrainIndex: entry.index,
      left: entry.left,
      top: entry.top,
      spriteSrc: 'maze/roadsign01.png',
      srcWidth: 32.0,
      srcHeight: 32.0,
    )
    currentLevel.objects.add(entryObject)

    final exit = Tile(centerX, 1, mapWidth: width)
    occupied.add(exit.index)
    currentLevel.exitX = exit.left
    currentLevel.exitX = exit.top
    final exitEntity = {
      id: 'levelExit',
      encounterType: 'levelExit',
    }
    this.entities[exitEntity.id] = exitEntity
    currentLevel.terrains[exit.index].entityId = entryEntity.id
    final exitObject = TileMapObject(
      id: exitEntity.id,
      terrainIndex: exit.index,
      left: exit.left,
      top: exit.top,
      spriteSrc: 'maze/roadsign01.png',
      srcWidth: 32.0,
      srcHeight: 32.0,
    )
    currentLevel.objects.add(exitObject)

    // engine.info('计算随机遭遇的位置')
    final blockSize = (width * height) ~/ 9
    var isOnCorner = false
    // 迷宫中的主要roguelike元素的可能位置锚点，分布在横三竖三的9个区块中
    // 四个角的锚点需要避免位于可能的出入口上
    final anchors = {}
    final halfBlockWidth = kDefaultBlockWidth ~/ 2
    final halfBlockHeight = kDefaultBlockHeight ~/ 2
    // 左上角
    anchors[1] = randomPosition(halfBlockWidth, halfBlockHeight, width, 0, 0)
    // 正上方
    anchors[2] = randomPosition(halfBlockWidth, halfBlockHeight, width, kDefaultBlockWidth + halfBlockWidth ~/ 2, 0)
    // 右上角
    anchors[3] = randomPosition(halfBlockWidth, halfBlockHeight, width, kDefaultBlockWidth * 2 + halfBlockWidth ~/ 2, 0)
    // 左边
    anchors[4] = randomPosition(halfBlockWidth, halfBlockHeight, width, 0, kDefaultBlockHeight + halfBlockHeight ~/ 2)
    // 正中
    anchors[5] = Tile(centerX, centerY, mapWidth: width)
    // 右边
    anchors[6] = randomPosition(halfBlockWidth, halfBlockHeight, width, kDefaultBlockWidth * 2 + halfBlockWidth ~/ 2, kDefaultBlockHeight + halfBlockHeight ~/ 2)
    // 左下角
    anchors[7] = randomPosition(halfBlockWidth, halfBlockHeight, width, 0, kDefaultBlockHeight * 2)
    // 正下方
    anchors[8] = randomPosition(halfBlockWidth, halfBlockHeight, width, kDefaultBlockWidth + halfBlockWidth ~/ 2, kDefaultBlockHeight * 2 + halfBlockHeight ~/ 2)
    // 右下角
    anchors[9] = randomPosition(halfBlockWidth, halfBlockHeight, width, kDefaultBlockWidth * 2 + halfBlockWidth ~/ 2, kDefaultBlockHeight * 2 + halfBlockHeight ~/ 2)
    
    final senior = ElderCultivator()
    senior.encounterType = 'senior'
    this.entities[senior.id] = senior
    currentLevel.terrains[anchors[5].index].entityId = senior.id
    final object = TileMapObject(
      id: senior.id,
      terrainIndex: anchors[5].index,
      left: anchors[5].left,
      top: anchors[5].top,
      spriteSrc: 'maze/elder_cultivator.png',
      srcWidth: 32.0,
      srcHeight: 48.0,
    )
    currentLevel.objects.add(object)

    // engine.info('在锚点放置遭遇')

    // 确保从任意一个角可以到达所有锚点的算法
    // 链接所有九个锚点的路径一共有9种（字母含义为left, right, top, bottom）：
    //
    //     1--tl--2--tr--3
    //     |      |      |
    //     lt     ct     rt
    //     |      |      |
    //     4--cl--5--cr--6
    //     |      |      |
    //     lb     cb     rb
    //     |      |      |
    //     7--bl--8--br--9
    //
    // 要想让一次可以经过所有的锚点，最少需要8个路径
    // 为了保证角落和中心必然可以到达，角落和中心会必然单独随机分配一个路径
    // 剩下的路径则随机分配
    // engine.info('确保各个锚点之间的通路')
    final muscleRoutes = [
      'topLeft',
      'leftTop',
      'leftBottom',
      'bottomLeft',
    ]
    final battleRoutes = [
      'centerTop',
      'centerBottom',
    ]
    final spiritualityRoutes = [
      'topRight',
      'rightTop',
      'rightBottom',
      'bottomRight',
    ]
    
    for (final name in muscleRoutes) {
      generateRouteByName(name, anchors, currentLevel, spriteIndex: kRockyTrail)
    }
    for (final name in battleRoutes) {
      generateRouteByName(name, anchors, currentLevel)
    }
    for (final name in spiritualityRoutes) {
      generateRouteByName(name, anchors, currentLevel, spriteIndex: kPavedRockTile)
    }

    // 最后再联通到入口和出口上
    generateRouteByIndex(entry.index, anchors[5].index, currentLevel)
    generateRouteByIndex(exit.index, anchors[2].index, currentLevel)

    // 在非路径非锚点非出入点的地块上生成装饰物
    // engine.info('生成装饰物')
    final blockZone = Zone(index: currentLevel.zones.length, category: 'block')
    currentLevel.zones.add(blockZone)
    for (final tile in currentLevel.terrains) {
      if (tile.isRoute) {
        tile.isSelectable = true
        tile.spriteIndex ??= random.nextIterable(_kLandSprites)
      } else {
        tile.isVoid = true
        tile.isSelectable = false
        addTerrainToZone(tile, blockZone.index, currentLevel)
      }
    }
    
    this.levels.add(currentLevel)
    
    // engine.info('副本 ${this.id} 生成完毕')

    // 重置临时历史，需要在手动调用enterMaze时再赋值
    currentMazeHistory = savedLocalHistory
  }
}

// 返回布尔值，如果为真，则玩家控制角色会返回上一格，否则停在这一格
fun handleCultivationRecruitInteraction({entity, tile, maze, currentLevelIndex}) -> bool {

  when (entity.encounterType) {
    'senior' -> {
      return true
    }
  }
  
  return false
}
