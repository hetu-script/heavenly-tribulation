import '../binding/maze.ht'
import '../tile/hexagonal_tile.ht'
import '../tile/tilemap.ht'
import '../game.ht'

const kDefaultBlockWidth = 4
const kDefaultBlockHeight = 4
const kDefaultMazeScale = 3
final kDefaultBlockNumber = kDefaultMazeScale * kDefaultMazeScale

const kEncounterProbability = 0.5
const kLevelUniqueEncounterProbability = 0.15
const kMazeUniqueEncounterProbability = 0.075

// 所有路径名字
final kRoutes = [
  'topLeft',
  'topRight',
  'leftTop',
  'centerTop',
  'rightTop',
  'centerLeft',
  'centerRight',
  'leftBottom',
  'centerBottom',
  'rightBottom',
  'bottomLeft',
  'bottomRight',
]

// 每个锚点所连接的路径
final kRoutesOfAnchor = {
  '1': ['topLeft', 'topRight'],
  '2': ['topLeft', 'topRight', 'centerTop'],
  '3': ['topRight', 'rightTop'],
  '4': ['leftTop', 'centerLeft', 'leftBottom'],
  '5': ['centerTop', 'centerLeft', 'centerRight', 'centerBottom'],
  '6': ['rightTop', 'centerRight', 'rightBottom'],
  '7': ['leftBottom', 'bottomLeft'],
  '8': ['bottomLeft', 'bottomRight', 'centerBottom'],
  '9': ['rightBottom', 'bottomRight'],
}

// 执行这个函数时地图尚未生成，因此不需要考虑zone，所以无需使用真正的terrain来计算
fun generateRouteByIndex(index1, index2, map) {
  final tile1 = index2TilePos(index1, map.width)
  final tile2 = index2TilePos(index2, map.width)
  // print('generate route from ${tile1} to ${tile2}')
  final route = calculateRoute(tile1, tile2, map)
  // print(route)
  if (route) {
    for (final index in route) {
      final terrain = map.terrains[index]
      terrain.isRoute = true
    }
  } else {
    final terrain = map.terrains[index1]
    terrain.isRoute = true
  }
}

fun generateRouteByName(name, anchors, map) {
  when (name) {
    'topLeft' -> generateRouteByIndex(anchors[1].index, anchors[2].index, map)
    'topRight' -> generateRouteByIndex(anchors[2].index, anchors[3].index, map)
    'leftTop' -> generateRouteByIndex(anchors[1].index, anchors[4].index, map)
    'centerTop' -> generateRouteByIndex(anchors[2].index, anchors[5].index, map)
    'rightTop' -> generateRouteByIndex(anchors[3].index, anchors[6].index, map)
    'centerLeft' -> generateRouteByIndex(anchors[4].index, anchors[5].index, map)
    'centerRight' -> generateRouteByIndex(anchors[5].index, anchors[6].index, map)
    'leftBottom' -> generateRouteByIndex(anchors[4].index, anchors[7].index, map)
    'centerBottom' -> generateRouteByIndex(anchors[5].index, anchors[8].index, map)
    'rightBottom' -> generateRouteByIndex(anchors[6].index, anchors[9].index, map)
    'bottomLeft' -> generateRouteByIndex(anchors[7].index, anchors[8].index, map)
    'bottomRight' -> generateRouteByIndex(anchors[8].index, anchors[9].index, map)
  }
}

fun enterMaze(maze) {
  currentMaze = maze
  localHistory = maze.history
}

fun leaveMaze(maze) {
  currentMaze = null
  localHistory = null
  // 移除所有临时npc
  for (final entity of maze.entities) {
    if (!entity.isPermanent) {
      delete game.npcs[entity.id]
    }
  }
  disposeMaze()
}

fun mazeGameOver(maze) {
  showGameOver().then((value) {
    leaveMaze(maze)
  })
}

// 返回布尔值，如果为真，则玩家控制角色会返回上一格，否则停在这一格
fun handleMazeEntityInteraction({entityId, left, top, maze, currentLevelIndex}) -> bool {
  final index = tilePos2Index(left, top, maze.width)
  final tile = maze.levels[currentLevelIndex].terrains[index]
  final hero = getHero()
  final entity = maze.entities[entityId]
  assert(entity != null)
  engine.info('副本地图对象互动事件：[${entity.encounterType}: ${entity.id}](${left}, ${top})')

  // 战斗，异步函数，如果获胜则返回 true
  fun battle -> Future {
    return showDuel(hero, entity).then((result) {
      if (result?.result) {
        resolveDuelResult(hero, entity, result)
        characterLoot(hero, entity, takeAll: true)
        final incidentContent = getLocaleString('duelVistory', [ hero.name, entity.name ] )
        Incident(
          content: incidentContent,
          subjectIds: [hero.id],
          isPrivate: true,
          isLocal: true,
        )
        tile.objectId = null
        setMazeObject(left, top, null)
        delete game.npcs[entity.id]
        return true
      } else {
        mazeGameOver(maze)
      }
    })
  }

  // 盗贼，如果成功击败则返回true，否则返回false
  async banditEncounter {
    maze.flags.haveMetBandit = true
    final messages = getLocaleString('mazeBandit01').split('/n')
    return showDialogByStrings(messages, character: entity).then((value) {
      final selections = [
        'handOver',
        'plead',
        'escape',
        'fight',
      ]
      return showSelectionByLocaleKeys(selections).then((key) {
        when (key) {
          // 现实主义
          'handOver' -> {
            characterLoot(entity, hero, takeAll: true)
            return false
          }
          // 向盗贼求情，是否成功依赖于
          // 圆滑
          'plead' -> {
            if (hero.stats.charisma > kCharismaCheckThreshold) {
              showDialogByStrings([getLocaleString('pleadSuccess')], character: entity)
                .then((value) {
                  characterLoot(entity, hero, takeAll: false)
                })
              return false
            } else {
              showDialogByStrings([getLocaleString('pleadFailed')], character: entity)
              .then( (value) => battle() )
            }
          }
          // 懦弱
          'escape' -> {
            if (hero.stats.dexterity > entity.stats.dexterity || hero.stats.strength > entity.stats.strength) {
              final incidentContent = getLocaleString('incidentEscapeSuccess', [ entity.name ] )
              Incident(
                content: incidentContent,
                subjectIds: [hero.id],
                isPrivate: true,
                isLocal: true,
              )
              return false
            } else {
              return showDialogByStrings([getLocaleString('escapeFailed')], character: entity)
              .then( (value) => battle() )
            }
          }
          // 自信
          'fight' -> {
            return showDialogByStrings([getLocaleString('startFightBandit')], character: hero)
            .then( (value) => battle() )
          }
        }
      })
    })
  }

  when (entity.encounterType) {
    'banditMuscle' -> {
      if (!maze.flags.haveMetBandit) {
        banditEncounter().then((result) {
          if (result) {
            tile.objectId = levelExit0
            setMazeObject(left, top, 'levelExit0')
          }
        })
      }
      // 如果已经遇到过盗贼，不再对话，直接开始战斗
      else {
        battle().then((result) {
          if (result) {
            tile.objectId = levelExit0
            setMazeObject(left, top, 'levelExit0')
          }
        })
      }
      return true
    }
    'banditKiller' -> {
      if (!maze.flags.haveMetBandit) {
        banditEncounter().then((result) {
          if (result) {
            tile.objectId = levelExit0
            setMazeObject(left, top, 'levelExit0')
          }
        })
      }
      // 如果已经遇到过盗贼，不再对话，直接开始战斗
      else {
        battle().then((result) {
          if (result) {
            tile.objectId = levelExit0
            setMazeObject(left, top, 'levelExit0')
          }
        })
      }
      return true
    }
    'banditBoss' -> {
      if (!maze.flags.haveMetBandit) {
        banditEncounter().then((result) {
          if (result) {
            tile.objectId = levelExit0
            setMazeObject(left, top, 'levelExit0')
          }
        })
      }
      // 如果已经遇到过盗贼，不再对话，直接开始战斗
      else {
        battle().then((result) {
          if (result) {
            tile.objectId = levelExit0
            setMazeObject(left, top, 'levelExit0')
          }
        })
      }
      return true
    }
    'levelEntry' -> {
      var selections
      if (currentLevelIndex == 0) {
        selections = [
          'leaveMaze',
          'cancel',
        ]
      } else {
        selections = [
          'backToPreviousLevel',
          'cancel',
        ]
      }
      showSelectionByLocaleKeys(selections).then((key) =>
        when (key) {
          'leaveMaze' -> leaveMaze(maze)
          'backToPreviousLevel' -> backToPreviousLevel()
        }
      )
    }
    'levelExit' -> {
      var selections
      if (currentLevelIndex == maze.levels.length - 1) {
        selections = [
          'leaveMaze',
          'cancel',
        ]
      } else {
        selections = [
          'proceedToNextLevel',
          'cancel',
        ]
      }
      showSelectionByLocaleKeys(selections).then((key) =>
        when (key) {
          'proceedToNextLevel' -> proceedToNextLevel()
          'leaveMaze' -> leaveMaze(maze)
        }
      )
    }
    'banditMinion' -> {
      if (!maze.flags.haveMetBandit) {
        banditEncounter()
      }
      // 如果已经遇到过盗贼喽啰，不再对话，直接开始战斗
      else {
        battle()
      }
    }
    'beast' -> {
      battle()
    }
    'peddler' -> {
      final messages = getLocaleString('peddlerDialogIntro').split('/n')
      showDialogByStrings(messages, character: entity)
      .then((value) {
        final selections = [
          'askForDirections',
          'trade',
          'steal',
          'rob',
          'attack',
          'sneakAttack',
          'cancel',
        ]
        showSelectionByLocaleKeys(selections)
        .then((key) {
          when (key) {
            'trade' -> {
              showMerchant(entity)
            }
            'attack' -> {

            }
          }
        })
      })
    }
  }
  
  return false
}
