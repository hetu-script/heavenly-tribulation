import 'tile/hexagonal_tile.ht'
import 'tile/tilemap.ht'
import 'game.ht'
import 'tile/entity.ht'

final _kLandSprites = [
  kSpriteLand,
  kSpriteGrassLand,
]

const _kDefaultBlockWidth = 6
const _kDefaultBlockHeight = 6
const _kDefaultMazeScale = 3
final _kDefaultBlockNumber = _kDefaultMazeScale * _kDefaultMazeScale

final _kEncounterTypes = [
  'empty',
  'treasure',
  'enemy',
]

final _kBlockTypes = [
  // 'empty',
  'bush',
  'rock',
]

// 所有路径名字
final _kRoutes = [
  'topLeft',
  'topRight',
  'leftTop',
  'centerTop',
  'rightTop',
  'centerLeft',
  'centerRight',
  'leftBottom',
  'centerBottom',
  'rightBottom',
  'bottomLeft',
  'bottomRight',
]

// 每个锚点所连接的路径
final _kRoutesOfAnchor = {
  '1': ['topLeft', 'topRight'],
  '2': ['topLeft', 'topRight', 'centerTop'],
  '3': ['topRight', 'rightTop'],
  '4': ['leftTop', 'centerLeft', 'leftBottom'],
  '5': ['centerTop', 'centerLeft', 'centerRight', 'centerBottom'],
  '6': ['rightTop', 'centerRight', 'rightBottom'],
  '7': ['leftBottom', 'bottomLeft'],
  '8': ['bottomLeft', 'bottomRight', 'centerBottom'],
  '9': ['rightBottom', 'bottomRight'],
}

fun _random2(list) {
  final l = list.toList()
  l.shuffle()
  return [l.first, l.last]
}

fun _generateRoute(index1, index2, map) {
  final tile1 = index2TilePos(index1, map.width)
  final tile2 = index2TilePos(index2, map.width)
  final route = calculateRoute(tile1, tile2, map)
  if (route) {
    for (final index in route) {
      final terrain = map.terrains[index]
      terrain.isRoute = true
    }
  }
}

fun generateRoute(name, anchors, map) {
  when (name) {
    'topLeft' -> _generateRoute(anchors[1], anchors[2], map)
    'topRight' -> _generateRoute(anchors[2], anchors[3], map)
    'leftTop' -> _generateRoute(anchors[1], anchors[4], map)
    'centerTop' -> _generateRoute(anchors[2], anchors[5], map)
    'rightTop' -> _generateRoute(anchors[3], anchors[6], map)
    'centerLeft' -> _generateRoute(anchors[4], anchors[5], map)
    'centerRight' -> _generateRoute(anchors[5], anchors[6], map)
    'leftBottom' -> _generateRoute(anchors[4], anchors[7], map)
    'centerBottom' -> _generateRoute(anchors[5], anchors[8], map)
    'rightBottom' -> _generateRoute(anchors[6], anchors[9], map)
    'bottomLeft' -> _generateRoute(anchors[7], anchors[8], map)
    'bottomRight' -> _generateRoute(anchors[8], anchors[9], map)
  }
}

fun addMazeEntity(entity, map) {
  final tileIndex = tilePos2Index(entity.left, entity.top, map.width)
  final tile = map.terrains[tileIndex]
  tile.entityIndex = map.entities.length
  map.entities.add(entity)
}

/// 生成Roguelike副本的算法
fun createMaze ({
    id = 'unknown_maze',
    levelNumber = 1,
  }) {
  engine.info('开始生成副本: ${id}')

  game.maze = {
    levels: [],
    currentLevel: 0,
  }

  // 已经被分配了的地块
  final occupied = Set()

  fun randomPosition(width, height) {
    assert(width > 2)
    assert(height > 2)
    // if (occupied.length >= (width * height - width * 2 - (height - 2) * 2)) {
    //   throw 'all tiles have been occupied!'
    // }
    var left
    var top
    var index
    do {
      left = Math.randomInt(width - 2) + 2
      top = Math.randomInt(height - 2) + 2
      index = tilePos2Index(left, top, width)
    } while (occupied.contains(index))
    occupied.add(index)
    return { index, left, top }
  }

  for (final levelIndex in range(levelNumber)) {
    final [ width, height ] = [ _kDefaultBlockWidth * _kDefaultMazeScale, _kDefaultBlockHeight * _kDefaultMazeScale ]
    final terrainSize = width * height

    final currentLevel = TileMap(
      scene: 'maze_${id}_${levelIndex}',
      width: width,
      height: height,
    )

    engine.info('生成迷宫地块')
    final landZone = Zone(index: currentLevel.zones.length, category: kZoneContinent)
    currentLevel.zones.add(landZone)
    for (var j in range(height)) {
      for (var i in range(width)) {
        // final isVoid = (i == 0) || (i == width - 1) || (j == 0) || (j == height - 1)
        final terrain = {
          ...Tile(i + 1, j + 1),
          isVisible: false,
          isSelectable: true,
          showGrid: true,
          index: tilePos2Index(i + 1, j + 1, width),
          // spriteIndex: isVoid ? null : _kLandSprites.random,
          spriteIndex: _kLandSprites.random,
          overlaySprite: {},
        }
        currentLevel.terrains.add(terrain)
        // if (isVoid) {
        //   addTerrainToZone(terrain, voidZone.index, currentLevel)
        // } else {
          addTerrainToZone(terrain, landZone.index, currentLevel)
        // }
      }
    }

    engine.info('计算随机遭遇的位置')
    final blockSize = terrainSize / 9
    var isOnCorner = false
    // 迷宫中的主要roguelike元素的可能位置锚点，分布在横三竖三的9个区块中
    // 四个角的锚点需要避免位于可能的出入口上
    final anchors = {
      '1': 1 + Math.randomInt(blockSize - 1), // 左上角
      '9': blockSize * 8 + Math.randomInt(blockSize - 1), // 右下角
    }
    // 右上角
    var topRightAnchor
    do {
      topRightAnchor = blockSize * 2 + Math.randomInt(blockSize)
      final tilepos = index2TilePos(topRightAnchor, width)
      isOnCorner = tilepos.left == width && tilepos.top == 1
    } while (isOnCorner)
    anchors[3] = topRightAnchor
    // 左下角
    var bottomLeftAnchor
    do {
      bottomLeftAnchor = blockSize * 6 + Math.randomInt(blockSize)
      final tilepos = index2TilePos(bottomLeftAnchor, width)
      isOnCorner = tilepos.left == 1 && tilepos.top == height
    } while (isOnCorner)
    anchors[7] = bottomLeftAnchor
    // 其余锚点
    anchors[2] = blockSize + Math.randomInt(blockSize), // 正上方
    anchors[4] = blockSize * 3 + Math.randomInt(blockSize), // 左边
    anchors[5] = blockSize * 4 + Math.randomInt(blockSize), // 中间
    anchors[6]= blockSize * 5 + Math.randomInt(blockSize), // 右边
    anchors[8] = blockSize * 7 + Math.randomInt(blockSize), // 正下方
    occupied.addAll(anchors.values)
    
    engine.info('计算出入口')
    // 可能的出入口
    final possibleEntries = [
      { left: 1, top: 1, index: tilePos2Index(1, 1, width), nearestAnchor: anchors[1] },
      { left: width, top: 1, index: tilePos2Index(width, 1, width), nearestAnchor: anchors[3] },
      { left: 1, top: height, index: tilePos2Index(1, height, width), nearestAnchor: anchors[7] },
      { left: width, top: height, index: tilePos2Index(width, height, width), nearestAnchor: anchors[9] },
    ]
    possibleEntries.shuffle()
    final entry = possibleEntries.first
    occupied.add(entry.index)
    _generateRoute(entry.index, entry.nearestAnchor, currentLevel)
    currentLevel.entryX = entry.left
    currentLevel.entryY = entry.top
    final exit = possibleEntries.last
    occupied.add(exit.index)
    _generateRoute(exit.index, exit.nearestAnchor, currentLevel)
    currentLevel.exitX = exit.left
    currentLevel.exitX = exit.top
    
    engine.info('在锚点放置遭遇')
    for (final anchor of anchors) {
      final pos = index2TilePos(anchor, width)
      final encounterType = _kEncounterTypes.random
      when (encounterType) {
        'treasure' -> {
          final chest = TileMapEntity(
            terrainIndex: anchor,
            left: pos.left,
            top: pos.top,
            spriteSrc: 'maze/chest02.png',
            srcWidth: 32.0,
            srcHeight: 32.0,
          )
          addMazeEntity(chest, currentLevel)
        }
        'enemy' -> {
          final enemy = TileMapEntity(
            terrainIndex: anchor,
            left: pos.left,
            top: pos.top,
            spriteSrc: 'maze/enemy01.png',
            srcWidth: 32.0,
            srcHeight: 32.0,
          )
          addMazeEntity(enemy, currentLevel)
        }
      }
    }

    // 确保从任意一个角可以到达所有锚点的算法
    // 链接所有九个锚点的路径一共有9种（字母含义为left, right, top, bottom）：
    //
    //     1--tl--2--tr--3
    //     |      |      |
    //     lt     ct     rt
    //     |      |      |
    //     4--cl--5--cr--6
    //     |      |      |
    //     lb     cb     rb
    //     |      |      |
    //     7--bl--8--br--9
    //
    // 要想让一次可以经过所有的锚点，最少需要8个路径
    // 为了保证角落和中心必然可以到达，角落和中心会必然单独随机分配一个路径
    // 剩下的路径则随机分配
    engine.info('确保各个锚点之间的通路')
    final routes = Set() // 最终结果
    final middleAnchors = [2,4,6,8]
    middleAnchors.shuffle()
    for (final anchor in middleAnchors) {
      routes.add(_random2(_kRoutesOfAnchor[anchor]))
    }
    for (final name in routes) {
      generateRoute(name, anchors, currentLevel)
    }
    // check if there's a unconnected
    if (!routes.contains('topLeft') && !routes.contains('centerLeft') && !routes.contains('bottomLeft')) {
      final name = ['topLeft', 'centerLeft', 'bottomLeft'].random
      generateRoute(name, anchors, currentLevel)
    }
    if (!routes.contains('topRight') && !routes.contains('centerRight') && !routes.contains('bottomRight')) {
      final name = ['topRight', 'centerRight', 'bottomRight'].random
      generateRoute(name, anchors, currentLevel)
    }
    if (!routes.contains('leftTop') && !routes.contains('centerTop') && !routes.contains('rightTop')) {
      final name = ['leftTop', 'centerTop', 'rightTop'].random
      generateRoute(name, anchors, currentLevel)
    }
    if (!routes.contains('leftBottom') && !routes.contains('centerBottom') && !routes.contains('rightBottom')) {
      final name = ['leftBottom', 'centerBottom', 'rightBottom'].random
      generateRoute(name, anchors, currentLevel)
    }
    // check if there's any anchor left as unconnected
    final restAnchors = [1,3,5,7,9]
    for (final anchor in restAnchors) {
      final index = anchors[anchor]
      final tile = currentLevel.terrains[index]
      if (!tile.isRoute) {
        final name = _kRoutesOfAnchor[anchor].random
        generateRoute(name, anchors, currentLevel)
      }
    }

    // 在非路径非锚点非出入点的地块上生成装饰物
    engine.info('生成装饰物')
    for (final tile in currentLevel.terrains) {
      if (occupied.contains(tile.index)) continue
      if (tile.isRoute) continue
      final blockType = _kBlockTypes.random
      when (blockType) {
        'bush' -> {
          final bush = TileMapEntity(
            terrainIndex: tile.index,
            left: tile.left,
            top: tile.top,
            spriteSrc: 'maze/bush.png',
            srcWidth: 32.0,
            srcHeight: 48.0,
          )
          tile.isSelectable = false
          addMazeEntity(bush, currentLevel)
        }
        'rock' -> {
          final rock = TileMapEntity(
            terrainIndex: tile.index,
            left: tile.left,
            top: tile.top,
            spriteSrc: 'maze/rock.png',
            srcWidth: 32.0,
            srcHeight: 48.0,
          )
          tile.isSelectable = false
          addMazeEntity(rock, currentLevel)
        }
      }
    }

    engine.info('生成路标')
    
    game.maze.levels.add(currentLevel)
  }
  
  engine.info('副本 ${id} 生成完毕')

  return game.maze.levels
}

fun handleMazeInteraction(level, left, top) {
  final tileIndex = tilePos2Index(i + 1, j + 1, width)
  final tile = maze[level].terrains[tileIndex]
  if (tile.entityIndex) {

  }
}
