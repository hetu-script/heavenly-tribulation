import 'tile/hexagonal_tile.ht'
import 'tile/tilemap.ht'
import 'game.ht'
import 'tile/object.ht'
import 'entity/character/bandit.ht'

final _kLandSprites = [
  kSpriteLand,
  kSpriteGrassLand,
]

const _kDefaultBlockWidth = 6
const _kDefaultBlockHeight = 6
const _kDefaultMazeScale = 3
final _kDefaultBlockNumber = _kDefaultMazeScale * _kDefaultMazeScale

final _kEncounterTypes = [
  'empty',
  'treasure',
  'enemy',
]

final _kBlockTypes = [
  // 'empty',
  'bush',
  'rock',
]

// 所有路径名字
final _kRoutes = [
  'topLeft',
  'topRight',
  'leftTop',
  'centerTop',
  'rightTop',
  'centerLeft',
  'centerRight',
  'leftBottom',
  'centerBottom',
  'rightBottom',
  'bottomLeft',
  'bottomRight',
]

// 每个锚点所连接的路径
final _kRoutesOfAnchor = {
  '1': ['topLeft', 'topRight'],
  '2': ['topLeft', 'topRight', 'centerTop'],
  '3': ['topRight', 'rightTop'],
  '4': ['leftTop', 'centerLeft', 'leftBottom'],
  '5': ['centerTop', 'centerLeft', 'centerRight', 'centerBottom'],
  '6': ['rightTop', 'centerRight', 'rightBottom'],
  '7': ['leftBottom', 'bottomLeft'],
  '8': ['bottomLeft', 'bottomRight', 'centerBottom'],
  '9': ['rightBottom', 'bottomRight'],
}

fun _random2(list) {
  final l = list.toList()
  l.shuffle()
  return [l.first, l.last]
}

// 执行这个函数时地图尚未生成，因此不需要考虑zone，所以无需使用真正的terrain来计算
fun _generateRoute(index1, index2, map) {
  final tile1 = index2TilePos(index1, map.width)
  final tile2 = index2TilePos(index2, map.width)
  final route = calculateRoute(tile1, tile2, map)
  if (route) {
    for (final index in route) {
      final terrain = map.terrains[index]
      terrain.isRoute = true
    }
  }
}

fun generateRoute(name, anchors, map) {
  when (name) {
    'topLeft' -> _generateRoute(anchors[1].index, anchors[2].index, map)
    'topRight' -> _generateRoute(anchors[2].index, anchors[3].index, map)
    'leftTop' -> _generateRoute(anchors[1].index, anchors[4].index, map)
    'centerTop' -> _generateRoute(anchors[2].index, anchors[5].index, map)
    'rightTop' -> _generateRoute(anchors[3].index, anchors[6].index, map)
    'centerLeft' -> _generateRoute(anchors[4].index, anchors[5].index, map)
    'centerRight' -> _generateRoute(anchors[5].index, anchors[6].index, map)
    'leftBottom' -> _generateRoute(anchors[4].index, anchors[7].index, map)
    'centerBottom' -> _generateRoute(anchors[5].index, anchors[8].index, map)
    'rightBottom' -> _generateRoute(anchors[6].index, anchors[9].index, map)
    'bottomLeft' -> _generateRoute(anchors[7].index, anchors[8].index, map)
    'bottomRight' -> _generateRoute(anchors[8].index, anchors[9].index, map)
  }
}

// fun addMazeObject(object, map) {
//   if (object.entityId) {
//     final tileIndex = tilePos2Index(object.left, object.top, map.width)
//     final tile = map.terrains[tileIndex]
//     tile.objectIndex = map.objects.length
//   }
//   map.objects.add(object)
// }

/// 生成Roguelike副本的算法
fun createMaze ({
    id = 'unknown_maze',
    levelNumber = 1,
  }) {
  engine.info('开始生成副本: ${id}')

  game.maze = {
    levels: [], // 每一层是一个单独的 tilemap
    currentLevel: 0,
    entities: {}, // 包含所有显示在地图上的可互动对象，包括NPC、敌人、宝箱、陷阱、机关等等。
  }

  // 已经被分配了的地块
  final occupied = Set()

  fun randomPosition(width, height) {
    assert(width > 2)
    assert(height > 2)
    // if (occupied.length >= (width * height - width * 2 - (height - 2) * 2)) {
    //   throw 'all tiles have been occupied!'
    // }
    var left
    var top
    var index
    do {
      left = Math.randomInt(width - 2) + 2
      top = Math.randomInt(height - 2) + 2
      index = tilePos2Index(left, top, width)
    } while (occupied.contains(index))
    occupied.add(index)
    return { index, left, top }
  }

  for (final levelIndex in range(levelNumber)) {
    final [ width, height ] = [ _kDefaultBlockWidth * _kDefaultMazeScale, _kDefaultBlockHeight * _kDefaultMazeScale ]
    final terrainSize = width * height

    final currentLevel = TileMap(
      scene: 'maze_${id}_${levelIndex}',
      width: width,
      height: height,
    )

    engine.info('生成迷宫地块')
    final landZone = Zone(index: currentLevel.zones.length, category: kZoneContinent)
    currentLevel.zones.add(landZone)
    for (var j in range(height)) {
      for (var i in range(width)) {
        // final isVoid = (i == 0) || (i == width - 1) || (j == 0) || (j == height - 1)
        final terrain = {
          ...Tile(i + 1, j + 1, mapWidth: width),
          isVisible: false,
          isSelectable: true,
          showGrid: true,
          // spriteIndex: isVoid ? null : _kLandSprites.random,
          spriteIndex: _kLandSprites.random,
          overlaySprite: {},
        }
        currentLevel.terrains.add(terrain)
        addTerrainToZone(terrain, landZone.index, currentLevel)
      }
    }

    engine.info('计算随机遭遇的位置')
    final blockSize = terrainSize / 9
    var isOnCorner = false
    // 迷宫中的主要roguelike元素的可能位置锚点，分布在横三竖三的9个区块中
    // 四个角的锚点需要避免位于可能的出入口上
    final anchors = {}
    var left
    var top
    // 左上角
    do {
      left = Math.randomInt(_kDefaultBlockWidth) + 1
      top = Math.randomInt(_kDefaultBlockHeight) + 1
    } while (left == 1 && top == 1)
    anchors[1] = Tile(left, top, mapWidth: width)
    // 正上方
    do {
      left = Math.randomInt(_kDefaultBlockWidth) + 1 + _kDefaultBlockWidth
      top = Math.randomInt(_kDefaultBlockHeight) + 1
    } while (left == 1 && top == 1)
    anchors[2] = Tile(left, top, mapWidth: width)
    // 右上角
    do {
      left = Math.randomInt(_kDefaultBlockWidth) + 1 + _kDefaultBlockWidth * 2
      top = Math.randomInt(_kDefaultBlockHeight) + 1
    } while (left == 1 && top == 1)
    anchors[3] = Tile(left, top, mapWidth: width)
    // 左边
    do {
      left = Math.randomInt(_kDefaultBlockWidth) + 1
      top = Math.randomInt(_kDefaultBlockHeight) + 1 + _kDefaultBlockHeight
    } while (left == 1 && top == 1)
    anchors[4] = Tile(left, top, mapWidth: width)
    // 正中
    do {
      left = Math.randomInt(_kDefaultBlockWidth) + 1 + _kDefaultBlockWidth
      top = Math.randomInt(_kDefaultBlockHeight) + 1 + _kDefaultBlockHeight
    } while (left == 1 && top == 1)
    anchors[5] = Tile(left, top, mapWidth: width)
    // 右边
    do {
      left = Math.randomInt(_kDefaultBlockWidth) + 1 + _kDefaultBlockWidth * 2
      top = Math.randomInt(_kDefaultBlockHeight) + 1 + _kDefaultBlockHeight
    } while (left == 1 && top == 1)
    anchors[6] = Tile(left, top, mapWidth: width)
    // 左下角
    do {
      left = Math.randomInt(_kDefaultBlockWidth) + 1
      top = Math.randomInt(_kDefaultBlockHeight) + 1 + _kDefaultBlockHeight * 2
    } while (left == 1 && top == 1)
    anchors[7] = Tile(left, top, mapWidth: width)
    // 正下方
    do {
      left = Math.randomInt(_kDefaultBlockWidth) + 1 + _kDefaultBlockWidth
      top = Math.randomInt(_kDefaultBlockHeight) + 1 + _kDefaultBlockHeight * 2
    } while (left == 1 && top == 1)
    anchors[8] = Tile(left, top, mapWidth: width)
    // 右下角
    do {
      left = Math.randomInt(_kDefaultBlockWidth) + 1 + _kDefaultBlockWidth * 2
      top = Math.randomInt(_kDefaultBlockHeight) + 1 + _kDefaultBlockHeight * 2
    } while (left == 1 && top == 1)
    anchors[9] = Tile(left, top, mapWidth: width)
    for (final anchor of anchors) {
      occupied.add(anchor.index)
    }
    
    engine.info('计算出入口')
    // 可能的出入口
    final possibleEntries = [
      { ...Tile(1, 1, mapWidth: width), nearestAnchor: anchors[1].index },
      { ...Tile(width, 1, mapWidth: width), nearestAnchor: anchors[3].index },
      { ...Tile(1, height, mapWidth: width), nearestAnchor: anchors[7].index },
      { ...Tile(width, height, mapWidth: width), nearestAnchor: anchors[9].index },
    ]
    possibleEntries.shuffle()
    final entry = possibleEntries.first
    occupied.add(entry.index)
    currentLevel.entryX = entry.left
    currentLevel.entryY = entry.top
    final entryEntity = TileMapObject(
      terrainIndex: entry.index,
      left: entry.left,
      top: entry.top,
      spriteSrc: 'maze/roadsign01.png',
      srcWidth: 32.0,
      srcHeight: 32.0,
    )
    currentLevel.objects.add(entryEntity)
    final exit = possibleEntries.last
    occupied.add(exit.index)
    currentLevel.exitX = exit.left
    currentLevel.exitX = exit.top
    final exitEntity = TileMapObject(
      terrainIndex: exit.index,
      left: exit.left,
      top: exit.top,
      spriteSrc: 'maze/roadsign01.png',
      srcWidth: 32.0,
      srcHeight: 32.0,
    )
    currentLevel.objects.add(exitEntity)
    
    engine.info('在锚点放置遭遇')
    for (final anchor of anchors) {
      final encounterType = _kEncounterTypes.random
      when (encounterType) {
        'treasure' -> {
          final chest = TileMapObject(
            terrainIndex: anchor.index,
            left: anchor.left,
            top: anchor.top,
            spriteSrc: 'maze/chest02.png',
            srcWidth: 32.0,
            srcHeight: 32.0,
          )
          currentLevel.objects.add(chest)
        }
        'enemy' -> {
          final enemyEntity = Bandit(kind: 'minion')
          print(enemyEntity.id)
          game.maze.entities[enemyEntity.id] = enemyEntity
          final enemyObject = TileMapObject(
            terrainIndex: anchor.index,
            left: anchor.left,
            top: anchor.top,
            spriteSrc: 'maze/enemy01.png',
            srcWidth: 32.0,
            srcHeight: 32.0,
            entityId: enemyEntity.id,
          )
          currentLevel.objects.add(enemyObject)
        }
      }
    }

    // 确保从任意一个角可以到达所有锚点的算法
    // 链接所有九个锚点的路径一共有9种（字母含义为left, right, top, bottom）：
    //
    //     1--tl--2--tr--3
    //     |      |      |
    //     lt     ct     rt
    //     |      |      |
    //     4--cl--5--cr--6
    //     |      |      |
    //     lb     cb     rb
    //     |      |      |
    //     7--bl--8--br--9
    //
    // 要想让一次可以经过所有的锚点，最少需要8个路径
    // 为了保证角落和中心必然可以到达，角落和中心会必然单独随机分配一个路径
    // 剩下的路径则随机分配
    engine.info('确保各个锚点之间的通路')
    final routes = Set() // 最终结果
    final middleAnchors = [2,4,6,8]
    middleAnchors.shuffle()
    for (final point in middleAnchors) {
      routes.addAll(_random2(_kRoutesOfAnchor[point]))
    }
    for (final name in routes) {
      // print('initial routes: ${name}')
      generateRoute(name, anchors, currentLevel)
    }
    // check if there's a unconnected
    if (!routes.contains('topLeft') && !routes.contains('centerLeft') && !routes.contains('bottomLeft')) {
      final name = ['topLeft', 'centerLeft', 'bottomLeft'].random
      // print('add route to blank parallel: ${name}')
      generateRoute(name, anchors, currentLevel)
    }
    if (!routes.contains('topRight') && !routes.contains('centerRight') && !routes.contains('bottomRight')) {
      final name = ['topRight', 'centerRight', 'bottomRight'].random
      // print('add route to blank parallel: ${name}')
      generateRoute(name, anchors, currentLevel)
    }
    if (!routes.contains('leftTop') && !routes.contains('centerTop') && !routes.contains('rightTop')) {
      final name = ['leftTop', 'centerTop', 'rightTop'].random
      // print('add route to blank parallel: ${name}')
      generateRoute(name, anchors, currentLevel)
    }
    if (!routes.contains('leftBottom') && !routes.contains('centerBottom') && !routes.contains('rightBottom')) {
      final name = ['leftBottom', 'centerBottom', 'rightBottom'].random
      // print('add route to blank parallel: ${name}')
      generateRoute(name, anchors, currentLevel)
    }
    // check if there's any anchor left as unconnected
    final restAnchors = [1,3,5,7,9]
    for (final anchor in restAnchors) {
      final index = anchors[anchor].index
      final tile = currentLevel.terrains[index]
      if (!tile.isRoute) {
        final name = _kRoutesOfAnchor[anchor].random
        // print('add name to empty anchor: ${name}')
        generateRoute(name, anchors, currentLevel)
      }
    }
    // 最后再联通到入口和出口上
    _generateRoute(entry.index, entry.nearestAnchor, currentLevel)
    _generateRoute(exit.index, exit.nearestAnchor, currentLevel)

    // 在非路径非锚点非出入点的地块上生成装饰物
    engine.info('生成装饰物')
    final blockZone = Zone(index: currentLevel.zones.length, category: 'block')
    currentLevel.zones.add(blockZone)
    for (final tile in currentLevel.terrains) {
      if (occupied.contains(tile.index)) continue
      if (tile.isRoute) continue
      tile.isSelectable = false
      addTerrainToZone(tile, blockZone.index, currentLevel)
      final blockType = _kBlockTypes.random
      when (blockType) {
        'bush' -> {
          final bush = TileMapObject(
            terrainIndex: tile.index,
            left: tile.left,
            top: tile.top,
            spriteSrc: 'maze/bush.png',
            srcWidth: 32.0,
            srcHeight: 48.0,
          )
          currentLevel.objects.add(bush)
        }
        'rock' -> {
          final rock = TileMapObject(
            terrainIndex: tile.index,
            left: tile.left,
            top: tile.top,
            spriteSrc: 'maze/rock.png',
            srcWidth: 32.0,
            srcHeight: 48.0,
          )
          currentLevel.objects.add(rock)
        }
      }
    }
    engine.info('生成路标')
    game.maze.levels.add(currentLevel)
  }
  
  engine.info('副本 ${id} 生成完毕')

  return game.maze.levels
}

// 返回布尔值，如果为真，则玩家控制角色会返回上一格，否则停在这一格
fun handleMazeEntityInteraction(entityId) -> bool {
  final hero = getHero()
  final entity = game.maze?.entities[entityId]
  assert(entity != null)
  engine.info('地图对象互动事件：[${entity.id}]')
  when (entity.kind) {
    'minion' -> {
      final messages = getLocaleString('mazeBandit01').split('/n')
      showDialogByStrings(messages).then((value) {
        final selections = {
          handOver: getLocaleString('handOver'),
          fight: getLocaleString('fight'),
          escape: getLocaleString('escape'),
        } 
        showSelection(selections).then((key) {
          when (key) {
            'handOver' -> {
              characterGiveMoneyTo(hero, hero.money, entity)
            }
            'fight' -> {
              showDialogByStrings([getLocaleString('fightBandit')], character: hero)
                .then((value) {
                  showDuel(hero, entity)
                })
            }
          }
        })
      })
    }
  }
  return false
}
