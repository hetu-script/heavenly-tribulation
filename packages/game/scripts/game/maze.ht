import 'tile/hexagonal_tile.ht'
import 'tile/tilemap.ht'
import 'game.ht'
import 'tile/entity.ht'

final landSprites = [
  kSpriteLand,
  kSpriteGrassLand,
]

/// 生成Roguelike副本的算法
fun createMaze ({
    id,
    levelNumber = 1,
  }) {
  engine.info('开始生成副本: ${id}')

  game.maze = {
    levels: [],
    currentLevel: 0,
  }

  // 已经被分配了的地块
  final occupied = []

  fun randomPosition(width, height) {
    assert(width > 2)
    assert(height > 2)
    // if (occupied.length >= (width * height - width * 2 - (height - 2) * 2)) {
    //   throw 'all tiles have been occupied!'
    // }
    var left
    var top
    var index
    do {
      left = Math.randomInt(width - 2) + 2
      top = Math.randomInt(height - 2) + 2
      index = tilePos2Index(left, top, width)
    } while (occupied.contains(index))
    occupied.add(index)
    return { index, left, top }
  }

  fun addEntity(map, entity) {
    final tileIndex = tilePos2Index(entity.left, entity.top, map.width)
    final tile = map.terrains[tileIndex]
    tile.entityIndex = map.entities.length
    map.entities.add(entity)
  }

  for (final levelIndex in range(levelNumber)) {
    final [ entryX, entryY ] = [ 2, 2 ]
    final [ width, height ] = [ 8, 9 ]
    occupied.add(tilePos2Index(entryX, entryY, width))
    final currentLevel = TileMap(
      scene: 'maze_${id}_${levelIndex}',
      width: width,
      height: height,
      entryX: entryX,
      entryY: entryY,
    )
    
    final voidZone = Zone(index: currentLevel.zones.length, category: kZoneVoid)
    final landZone = Zone(index: currentLevel.zones.length, category: kZoneContinent)
    currentLevel.zones.add(landZone)

    engine.info('生成地块')
    for (var j in range(height)) {
      for (var i in range(width)) {
        // final isVoid = (i == 0) || (i == width - 1) || (j == 0) || (j == height - 1)
        final terrain = {
          ...Tile(i + 1, j + 1),
          isVisible: false,
          // isVoid,
          showGrid: true,
          index: tilePos2Index(i + 1, j + 1, width),
          // spriteIndex: isVoid ? null : landSprites.random,
          spriteIndex: landSprites.random,
          overlaySprite: {},
        }
        currentLevel.terrains.add(terrain)
        // if (isVoid) {
        //   addTerrainToZone(terrain, voidZone.index, currentLevel)
        // } else {
          addTerrainToZone(terrain, landZone.index, currentLevel)
        // }
      }
    }

    engine.info('生成敌人')
    for (final i in range(1)) {
      final pos = randomPosition(width, height)
      final enemy = TileMapEntity(
        terrainIndex: pos.index,
        left: pos.left,
        top: pos.top,
        spriteSrc: 'maze/enemy01.png',
        srcWidth: 32.0,
        srcHeight: 32.0,
      )

      addEntity(currentLevel, enemy)
    }
    
    engine.info('生成宝箱')
    for (final i in range(1)) {
      final pos = randomPosition(width, height)
      final chest = TileMapEntity(
        terrainIndex: pos.index,
        left: pos.left,
        top: pos.top,
        spriteSrc: 'maze/chest02.png',
        srcWidth: 32.0,
        srcHeight: 32.0,
      )

      addEntity(currentLevel, chest)
    }

    engine.info('生成遮挡物')
    for (final i in range(8)) {
      final pos = randomPosition(width, height)
      final bush = TileMapEntity(
        terrainIndex: pos.index,
        left: pos.left,
        top: pos.top,
        spriteSrc: 'maze/bush.png',
        srcWidth: 32.0,
        srcHeight: 48.0,
      )

      addEntity(currentLevel, bush)
    }

    for (final i in range(8)) {
      final pos = randomPosition(width, height)
      final rock = TileMapEntity(
        terrainIndex: pos.index,
        left: pos.left,
        top: pos.top,
        spriteSrc: 'maze/rock.png',
        srcWidth: 32.0,
        srcHeight: 48.0,
      )

      addEntity(currentLevel, rock)
    }

    engine.info('生成路标')
    
    game.maze.levels.add(currentLevel)
  }
  
  engine.info('副本 ${id} 生成完毕')

  return game.maze.levels
}

fun handleMazeInteraction(level, left, top) {
  final tileIndex = tilePos2Index(i + 1, j + 1, width)
  final tile = maze[level].terrains[tileIndex]
  if (tile.entityIndex) {

  }
}
