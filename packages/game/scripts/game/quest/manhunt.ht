import 'common.ht'
import '../l10n.ht'
import { random } from '../game.ht'

final kQuestManhuntKinds = [
  'killBanditBoss', // 消灭头目
  // 'wipeBandits', // 扫荡窝点
  // 'returnHostage', // 解救人质
  // 'returnTreasure', // 寻回宝物
]

// 消灭盗贼
// 盗贼的具体位置是隐藏的，但一定在该据点四周
struct QuestManhunt {
  construct ({
    kind,
    difficulty,
    locationId,
    publishingMonth = 1,
    expirationMonth = 1,
    reward,

    bossName,
  }) {
    assert(locationId != null)
    this.category = kQuestCategoryManhunt
    this.kind = kind ?? random.nextIterable(kQuestManhuntKinds)
    when (this.kind) {
      'boss' -> {
        this.description = getLocaleString('${this.kind}Description')
      }
      'wipe' -> {
        this.description = getLocaleString('${this.kind}Description')
      }
      'hostage' -> {
        this.description = getLocaleString('${this.kind}Description')
      }
      'treasure' -> {
        this.description = getLocaleString('${this.kind}Description')
      }
    }

    this.id = 'quest_${Hash.uid4(2)}_${locationId}_${this.category}_${this.kind}'
    this.difficulty = difficulty
    // 任务领取有效时间
    this.publishingMonth = publishingMonth
    // 任务完成有效时间
    this.expirationMonth = expirationMonth
    // 生成地点
    final location = game.locations[locationId]
    assert(location.nationId)
    // 悬赏会随机在本国境内
    final nation = game.nations[location.nationId]
    for (final index in nation.territoryIndexes) {
      final tile = game.world.terrains[index]
      if (tile.locationId) continue
      if (tile.mazeId) continue
      
    }

    this.stages = createStages({
      started: {
      // 任务开始，尚未找到副本入口

      },
      foundMaze: {
      // 找到了副本入口，但尚未通关
        
      },
      returning: {
      // 等待交还物品、随从等，交换后立即会获得奖励

      },
      finished: {
      // 完成了目标，可以在原本的据点领取奖励

      },
    })
    this.currentStageId = 'started'
    
    // 赏金类似一个物品栏，但可能包含银两、物品、资源这三种不同的对象
    this.reward = reward
    if (!this.reward) {
      this.reward = generateQuestReward(difficulty)
    }
    

    // 是否完成了任务
    this.isFinished = false
  }
}

struct QuestFightBanditStage {
  construct started () {
    this.id = 'started'
    this.next = 'found'
    this.failed = 'foundFailed'
  }

  construct foundFailed() {

  }

}
