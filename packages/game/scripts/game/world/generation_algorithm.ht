import '../tile/tilemap.ht'
import '../tile/hexagonal_tile.ht'
import '../game.ht'
import '../tile/common.ht'

/// 以一个种子地块出发，逐渐生长出一块大陆的算法
fun generateContinent1({width, height, landProportion, landZone}) {
  // 当前地域的边缘格子坐标
  final shelf = Set()

  // 刷新当前地域的边缘格子坐标
  fun updateShelf(left, top) {
    shelf.remove(tilePos2Index(left, top, width))
    final neighbors = getMapTileNeighbors(left, top, universe.currentWorld)
    for (final tile in neighbors) {
      if (tile.spriteIndex == kSpriteWater) {
        shelf.add(tile.index)
      }
    }
  }

  final landArea = (width * height * landProportion).floor()

  final minLeft = width ~/ 3
  final minTop = height ~/ 3
  final maxLeft = width ~/ 3 * 2
  final maxTop = height ~/ 3 * 2

  final startLeft = random.nextInt(maxLeft - minLeft) + minLeft
  final startTop = random.nextInt(maxTop - minTop) + minTop
  // engine.info('start: ${startLeft},${startTop}')
  final startIndex = tilePos2Index(startLeft, startTop, width)
  final firstTile = universe.currentWorld.terrains[startIndex]
  firstTile.spriteIndex = kSpriteLand
  addTerrainToZone(firstTile, landZone.index, universe.currentWorld)
  updateShelf(startLeft, startTop)

  var currentLandSize = 1
  while (currentLandSize < landArea) {
    // engine.info('expanding land')
    ++currentLandSize
    final tile = universe.currentWorld.terrains[random.nextIterable(shelf)]
    updateShelf(tile.left, tile.top)
    tile.spriteIndex = kSpriteLand
    addTerrainToZone(tile, landZone.index, universe.currentWorld)
  }

  // 根据相邻的格子的地域，分配地域索引
  fun updateZone(tile, [spriteIndex, unzonedNeighbors]) {
    assert(tile.zoneIndex == null)
    var willCreateZone = true
    if (spriteIndex != null) {
      willCreateZone = false
    } else {
      spriteIndex = tile.spriteIndex
    }
    unzonedNeighbors ??= {}
    // engine.info('processing: ${tile.left},${tile.top}, spriteIndex: ${tile.spriteIndex}')
    tile.zoneIndex = -1 // mark this tile is being processed, will skip it when process others
    final neighbors = getMapTileNeighbors(tile.left, tile.top, universe.currentWorld)
    var foundAdjacentZone = false
    for (final neighbor in neighbors) {
      // skip tiles that has diffrent spriteIndex and those still being processed
      if (neighbor.spriteIndex != spriteIndex) continue
      if (neighbor.zoneIndex == null) {
        updateZone(neighbor, spriteIndex, unzonedNeighbors)
      }
      if (neighbor.zoneIndex == -1) {
        unzonedNeighbors[neighbor.index] = neighbor
        continue
      }
      addTerrainToZone(tile, neighbor.zoneIndex, universe.currentWorld)
      foundAdjacentZone = true
      // engine.info('Found neighbor: ${neighbor.left},${neighbor.top}, zoneIndex: ${neighbor.zoneIndex}')
      break
    }
    if (!foundAdjacentZone && willCreateZone) {
      var category = tile.spriteIndex == kSpriteLand ? kZoneLand : kZoneWater
      final zone = Zone(index: universe.currentWorld.zones.length, category: category)
      universe.currentWorld.zones.add(zone)
      // engine.info('Created zone! left: ${tile.left}, top: ${tile.top} spriteIndex: ${tile.spriteIndex}, zoneIndex: ${zone.index}')
      addTerrainToZone(tile, zone.index, universe.currentWorld)
      // engine.info('processing previoused stored unzoned tiles: ${unzonedNeighbors}')
      for (final unzonedTile of unzonedNeighbors) {
        if (unzonedTile.zoneIndex == -1) {
          addTerrainToZone(unzonedTile, zone.index, universe.currentWorld)
        }
      }
    }
  }

  var unzonedTile
  engine.info('开始生成地域')
  while (
    unzonedTile = universe.currentWorld.terrains.firstWhere((tile) => tile.zoneIndex == null)
  ) {
    // engine.info('updating unzoned tile')
    updateZone(unzonedTile)
  }
  
  // 将大陆和海洋接触的地方填充为大陆架
  engine.info('将大陆和海洋接触的地方填充为大陆架')
  for (final index in shelf) {
    final tile = universe.currentWorld.terrains[index]
    tile.spriteIndex = kSpriteShelf
  }
}

final kMapStyles = Set(
  'islands',
  'coast',
  'inland',
)

/// 利用 noise 函数生成大陆和海洋的算法
fun generateContinent({seed, size, style}) {
  final noiseData
  final threshold
  assert(style in kMapStyles)
  when (style) {
    'islands' -> {
      threshold = 0.55
      noiseData = Math.noise2d(
        size,
        seed: seed,
        noiseType: 'perlinFractal',
        frequency: 6 / size,
      )
    }
    'coast' -> {
      threshold = 0.48
      noiseData = Math.noise2d(
        size,
        seed: seed,
        noiseType: 'cubicFractal',
        frequency: 3.5 / size,
      )
    }
    'inland' -> {
      threshold = 0.35
      noiseData = Math.noise2d(
        size,
        seed: seed,
        noiseType: 'cubicFractal',
        frequency: 6 / size,
      )
    }
  }
  for (final x in range(size)) {
    for (final y in range(size)) {
      final index = tilePos2Index(x + 1, y + 1, size)
      final noise = noiseData[x][y]
      final normalize = (noise + 1) / 2;
      if (normalize > threshold) {
        final tile = universe.currentWorld.terrains[index]
        tile.spriteIndex = kSpriteLand
      }
    }
  }
}
