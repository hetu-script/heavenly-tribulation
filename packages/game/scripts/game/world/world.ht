import '../name/zone.ht'
import '../game.ht'
import '../entity/location/site.ht'
import '../entity/location/location.ht'
import '../entity/character/character.ht'
import '../entity/organization/organization.ht'
import '../l10n.ht'
import '../tile/hexagonal_tile.ht'
import '../tile/zone.ht'
import '../tile/tilemap.ht'
import '../entity/common.ht'
import '../datetime.ht' as datetime
import '../logic.ht'
import 'generation_algorithm.ht'
import '../tile/common.ht'
import '../dialog.ht'
import '../entity/item/item.ht'

/// 生成世界地图的算法
///
/// spritesheet上不同地形对应的编号：
/// 0：虚空
/// 1：浅海
/// 2：深海
/// 3：陆地（草原）
///
/// 算法思路：
///
/// 用海面填满整个地图空间
///
/// 找到一个出发点，通常在地图中间部分
///
/// 找到出发点周围的方块，将其加入一个数组，作为当前陆地的边界
///
/// 将当前方块变成陆地，检查陆地比例，如果不够，就从当前陆地边界中随机挑选一个方块，将其变成陆地，同时重新计算边界。
///
/// 循环上述步骤，直到陆地和海水的比例达到预设值
///
/// 为陆地所属的整个大地块命名，然后找到尚未命名的地块，将所有相连的地块作为一个整体命名，直到所有的地块都有名字，根据地块大小有不同命名方式
///
/// 根据城市密度，生成城市，并根据城市位于陆地、海边还是海中，对其进行特殊命名
///
/// 对于每个城市，链接最近的另外两个城市，使用 A* 寻路算法，标记经过的地块
///
/// 对于没有道路经过的地块，随机填充山脉和树林

const _kDefaultWorldScale = 1
final _kWorldSizePerWorldScale = {
  '1': 12,
  '2': 18,
  '3': 27,
  '4': 40,
}
const _kDefaultNationNumber = 4
const _kDefaultLocationNumber = 6
const _kDefaultCharacterNumber = 20
const _kDefaultCultivationOrganizationNumber = 4
const _kDefaultTradingHouseOrganizationNumber = 2

const _kMinZoneSizeForSea = 8
const _kMinZoneSizeForIsland = 8
const _kForestThreshold = 0.5
const _kMountainThreshold = 0.2

const _kCharacterMarriageAgeMin = 15
const _kCharacterMarriageAgeMax = 40
const _kPregnancyAgeMax = 40

const _kLocationInitialDevelopmentMax = 4

const _kLocationInitialMoney = 2000
const _kNPCStoreInitialMoney = 2000
const _kSiteTradinghouseProbability = 0.6
const _kSiteTradinghouseMoney = 0.6
const _kSiteWorkshopProbability = 0.6
const _kSiteHospitalProbability = 0.6
const _kSiteRestaurantProbability = 0.6

final _cultivationKinds = [
  'location',
  'mountain',
  'island',
]

fun createWorldMap({
    id,
    seedString,
    style = 'coast',
    terrainSpriteSheet: str,
    worldScale = _kDefaultWorldScale,
    nationNumber = _kDefaultNationNumber,
    locationNumber = _kDefaultLocationNumber,
    cultivationOrganizationNumber = _kDefaultCultivationOrganizationNumber,
    // tradinghouseOrganizationNumber = _kDefaultTradingHouseOrganizationNumber,
    characterNumber = _kDefaultCharacterNumber,
    // landProportion = 0.55,
    scale = 2.0,
  }) {
  assert(id != null)
  assert(seedString is str && seedString.isNotEmpty)
  assert(cultivationOrganizationNumber < locationNumber)
  assert(cultivationOrganizationNumber < characterNumber)
  // assert(tradinghouseOrganizationNumber < locationNumber)
  // assert(tradinghouseOrganizationNumber < characterNumber)

  final seed = Hash.crcInt(seedString)
  engine.info('开始生成世界，设置随机数种子为：${seedString}(${seed})')
  setRandomSeed(seed)

  final width
  final height

  width = height = _kWorldSizePerWorldScale[worldScale.toString()]

  // 生成过程中，引入了一些别的文件中的函数
  // 他们可能会通过game.world访问, 因此这里直接使用全局变量
  game.world = TileMap(
    id: id,
    width: width,
    height: height,
    scale: scale,
  )

  // 地图上的可互动对象，因为世界地图目前只有一层，所以这个表直接放在map上。
  game.world.entities = {}

  game.world.isNewGame = true

  engine.info('生成地块')
  for (var j in range(height)) {
    for (var i in range(width)) {
      game.world.terrains.add(
        {
          ...Tile(i + 1, j + 1),
          index: tilePos2Index(i + 1, j + 1, width),
          spriteIndex: kSpriteWater,
          overlaySprite: {},
          isSelectable: true,
          // 该地块的每月刷新野外事件的时间
          monthlyUpdateTime: random.nextInt(kTicksPerMonth)
        }
      )
    }
  }

  // 没有区域，也是一个区域
  final voidZone = Zone(index: game.world.zones.length, name: null, category: kZoneVoid)
  game.world.zones.add(voidZone)

  // 生成地域
  engine.info('准备生成地域')
  final landZone = Zone(index: game.world.zones.length, category: kZoneLand)
  game.world.zones.add(landZone)
  generateContinent(
    seed: seed,
    size: width,
    style: style,
  )

  // 根据相邻的格子的地域，分配地域索引
  fun updateZone(tile, [spriteIndex, unzonedNeighbors]) {
    assert(tile.zoneIndex == null)
    var willCreateZone = true
    if (spriteIndex != null) {
      willCreateZone = false
    } else {
      spriteIndex = tile.spriteIndex
    }
    unzonedNeighbors ??= {}
    // engine.info('processing: ${tile.left},${tile.top}, spriteIndex: ${tile.spriteIndex}')
    tile.zoneIndex = -1 // mark this tile is being processed, will skip it when process others
    final neighbors = getMapTileNeighbors(tile.left, tile.top, game.world)
    var foundAdjacentZone = false
    for (final neighbor in neighbors) {
      // skip tiles that has diffrent spriteIndex and those still being processed
      if (neighbor.spriteIndex != spriteIndex) continue
      if (neighbor.zoneIndex == null) {
        updateZone(neighbor, spriteIndex, unzonedNeighbors)
      }
      if (neighbor.zoneIndex == -1) {
        unzonedNeighbors[neighbor.index] = neighbor
        continue
      }
      addTerrainToZone(tile, neighbor.zoneIndex, game.world)
      foundAdjacentZone = true
      // engine.info('Found neighbor: ${neighbor.left},${neighbor.top}, zoneIndex: ${neighbor.zoneIndex}')
      break
    }
    if (!foundAdjacentZone && willCreateZone) {
      var category = tile.spriteIndex == kSpriteLand ? kZoneLand : kZoneWater
      final zone = Zone(index: game.world.zones.length, category: category)
      game.world.zones.add(zone)
      // engine.info('Created zone! left: ${tile.left}, top: ${tile.top} spriteIndex: ${tile.spriteIndex}, zoneIndex: ${zone.index}')
      addTerrainToZone(tile, zone.index, game.world)
      // engine.info('processing previoused stored unzoned tiles: ${unzonedNeighbors}')
      for (final unzonedTile of unzonedNeighbors) {
        if (unzonedTile.zoneIndex == -1) {
          addTerrainToZone(unzonedTile, zone.index, game.world)
        }
      }
    }
  }

  var unzonedTile
  engine.info('开始生成地域')
  while (
    unzonedTile = game.world.terrains.firstWhere((tile) => tile.zoneIndex == null)
  ) {
    // engine.info('updating unzoned tile')
    updateZone(unzonedTile)
  }

  fun find2NearestLocation(origin, {restricted2Zone: bool = true}) {
    assert(game.locations.length > 0)
    var nearest
    var nearestDistance
    var secondNearest
    var secondNearestDistance
    for (final location of game.locations) {
      if (location.index == origin.index) {
        continue
      } else {
        final start = game.world.terrains[origin.terrainIndex]
        final end = game.world.terrains[location.terrainIndex]
        final distance = getTileDistance(start, end)
        if (!restricted2Zone || location.zoneIndex == origin.zoneIndex) {
          if (nearestDistance == null || distance < nearestDistance) {
            nearestDistance = distance
            nearest = location
          } else if (secondNearestDistance == null || distance < secondNearestDistance) {
            secondNearestDistance = distance
            secondNearest = location
          } else {
            continue
          }
        }
      }
    }
    return { nearest, secondNearest }
  }

  // 生成据点
  engine.info('生成大陆上的据点')
  final locationIndexes = Set()
  while (game.locations.length < locationNumber) {
    var index
    var tile
    do {
      // engine.info('generating location index')
      index = random.nextInt(game.world.terrains.length)
      tile = game.world.terrains[index]
    } while (locationIndexes.contains(index) || tile.spriteIndex != kSpriteLand)
    // location category 有三种：城市、岛屿和山峰，后两者为隐藏据点
    final location = Location(
      terrainIndex: index,
      left: tile.left,
      top: tile.top,
      category: kLocationCategoryCity,
    )
    tile.locationId = location.id
    // tile.caption = location.name
    // 城市的贴图重叠于地形贴图之上
    tile.overlaySprite.index = kSpriteCity
    locationIndexes.add(index)
    
    // 随机生成的据点，初始发展度是0-3之间随机。
    location.development = random.nextInt(_kLocationInitialDevelopmentMax)
    // 据点所拥有的金钱，和发展度有关
    for (final i in range(location.development)) {
      location.money +=  random.nextInt((i + 1) * _kLocationInitialMoney)
    }

    // 随机为据点添加一些初始建筑和对应的物品
    // 初始时、根据发展度，可能会有商号（1）、工坊（2）、医馆和酒楼（3）
    if (location.development > 0 && random.nextDouble() < _kSiteTradinghouseProbability) {
      final site = Site(category: kSiteTradinghouse, locationId: location.id)
      site.money += _kNPCStoreInitialMoney + random.nextInt(_kNPCStoreInitialMoney)
      // 商号可能有：谷物、水果、鱼、蔬菜、药材、木料、矿石
      entityAcquireItem(site, Material.grain(), count: 20)
      entityAcquireItem(site, Material.fruit(), count: 20)
      entityAcquireItem(site, Material.fish(), count: 20)
      entityAcquireItem(site, Material.vegetable(), count: 20)
      entityAcquireItem(site, Material.herb(), count: 20)
      entityAcquireItem(site, Material.wood(), count: 20)
      entityAcquireItem(site, Material.ore(), count: 20)
    }
    if (location.development > 1 && random.nextDouble() < _kSiteWorkshopProbability) {
      final site = Site(category: kSiteWorkshop, locationId: location.id)
      site.money += _kNPCStoreInitialMoney + random.nextInt(_kNPCStoreInitialMoney)
      // 工坊可能有：武器、盾牌
      entityAcquireItem(site, Weapon())
      entityAcquireItem(site, Weapon())
      entityAcquireItem(site, Weapon())
      entityAcquireItem(site, Shield())
      entityAcquireItem(site, Shield())
    }
    if (location.development > 2 && random.nextDouble() < _kSiteRestaurantProbability) {
      final site = Site(category: kSiteRestaurant, locationId: location.id)
      site.money += _kNPCStoreInitialMoney + random.nextInt(_kNPCStoreInitialMoney)
      site.money = 
      // 酒楼可能有：饮料、食物
      entityAcquireItem(site, Consumable.beverage(), count: 20)
    }
    if (location.development > 2 && random.nextDouble() < _kSiteHospitalProbability) {
      final site = Site(category: kSiteHospital, locationId: location.id)
      site.money += _kNPCStoreInitialMoney + random.nextInt(_kNPCStoreInitialMoney)
      // 医馆可能有：方剂
      entityAcquireItem(site, Consumable.medicine(), count: 20)
      entityAcquireItem(site, Material.herb(), count: 10)
    }
  }

  engine.info('确保陆地上的每个城市至少可以链接到另外两个城市')
  for (final location of game.locations) {
    final start = game.world.terrains[location.terrainIndex]
    // 确保陆地上的每个城市至少可以链接到另外两个城市
    if (start.zoneCategory == kZoneLand) {
      final searchResult = find2NearestLocation(location, restricted2Zone: true)
      if (searchResult.nearest) {
        final end = game.world.terrains[searchResult.nearest.terrainIndex]
        final route = calculateRoute(start, end, game.world)
        if (route) {
          // routes.add(route)
          for (final index in route) {
            final terrain = game.world.terrains[index]
            terrain.isRoute = true
          }
        }
      }
      if (searchResult.secondNearest) {
        final end = game.world.terrains[searchResult.secondNearest.terrainIndex]
        final route = calculateRoute(start, end, game.world)
        if (route) {
          // routes.add(route)
          for (final index in route) {
            final terrain = game.world.terrains[index]
            terrain.isRoute = true
          }
        }
      }
    }
  }
  
  final mountains = Set()
  final seas = Set()

  // 地形装饰贴图
  // 将大陆和海洋接触的地方填充为大陆架，将大陆上没有道路的方格，随机填充为平原、森林、山地
  // 这些修改不影响该地块的 category 和 kind
  engine.info('填充地形装饰贴图：大陆架、平原、森林、山地')
  for (final tile in game.world.terrains) {
    if (tile.spriteIndex == kSpriteLand) {
      if (!tile.isRoute) {
        final r = random.nextDouble()
        if (r < _kMountainThreshold) {
          tile.spriteIndex = kSpriteMountain
          mountains.add(tile.index)
        } else if (r < _kForestThreshold) {
          tile.spriteIndex = kSpriteForest
        }
      }
    } else if (tile.spriteIndex == kSpriteWater) {
      final neighbors = getMapTileNeighbors(tile.left, tile.top, game.world)
      var isSea = true
      for (final neighbor in neighbors) {
        if (neighbor.spriteIndex == kSpriteLand) {
          tile.spriteIndex = kSpriteShelf
          isSea = false
          break
        }
      }
      if (isSea) {
        seas.add(tile.index)
      }
    }
  }

  // 因为 zone 的名字和其大小有关，因此在最后在才命名和赋值 category/kind
  engine.info('为地域命名')
  for (final zone in game.world.zones) {
    if (zone.name) {
      continue
    }
    // kZoneWater & kZoneLand 只是临时类型，现在替换为具体的类型
    if (zone.category == kZoneWater) {
      zone.category = zone.terrainIndexes.length < _kMinZoneSizeForSea ? kZoneCategoryLake : kZoneCategorySea
      
      // 为该地域中所有地块赋值 kind
      for (final terrainIndex in zone.terrainIndexes) {
        final tile = game.world.terrains[terrainIndex]
        tile.isWater = true
        tile.zoneCategory = zone.category
        tile.kind = zone.category
      }
    } else {
      zone.category = zone.terrainIndexes.length < _kMinZoneSizeForIsland ? kZoneCategoryIsland : kZoneCategoryContinent
      
      // 为该地域中所有地块赋值 kind
      for (final terrainIndex in zone.terrainIndexes) {
        final tile = game.world.terrains[terrainIndex]
        tile.zoneCategory = zone.category
        
        if (tile.locationId) {
          tile.kind = kTerrainKindLocation
        }
        // else if (tile.isRoute) {
        //   tile.kind = kTerrainKindRoad
        // }
        else if (tile.spriteIndex == kSpriteMountain) {
          tile.kind = kTerrainKindMountain
        } else if (tile.spriteIndex == kSpriteForest) {
          tile.kind = kTerrainKindForest
        } else {
          tile.kind = kTerrainKindPlain
        }
        // TODO: river类型和道路类型单独的贴图
      }
    }

    final randomName = generateZoneName(category: zone.category)
    zone.name = randomName.name

  }

  final nations = []
  // 随机挑选几个城市，作为各个国家的都城，生成地图上的不同国家
  engine.info('随机挑选几个城市，作为各个国家的都城，生成地图上的不同国家')
  while (nations.length < nationNumber) {
    var location
    do {
      // 因为struct不能按照固定顺序排序，因此这里按照keys来随机。
      final locationId = random.nextIterable(game.locations.keys)
      location = game.locations[locationId]
    } while (location.nationId != null)
    // engine.info('picking location for new nation capital: ${location}')
    final emperor = Character(
      birthTimestamp: createRandomBirthTimestamp(40), // 年龄至少是20岁
    )
    final nation = Organization.nation(
      capitalId: location.id,
      emperorId: emperor.id,
    )
    // Site(category: kSitePalace, locationId: location.id, organizationId: nation.id)
    final terrain = game.world.terrains[location.terrainIndex]
    addTerrainToNation(terrain, nation)
    nations.add(nation)
  }
  
  // 一个国家将其疆域扩展到周边的一个格子
  // 返回值表示是否扩展成功
  fun expandNation(nation) {
    // engine.info('processing nation: ${nation}')
    assert(nation.borderIndexes != null && nation.borderIndexes.isNotEmpty)
    // avoid editing iterable while iterating
    for (final index in random.shuffle(nation.borderIndexes)) {
      final terrain = game.world.terrains[index]
      if (terrain.nationId == null && !terrain.isWater) {
        addTerrainToNation(terrain, nation)
        return true
      }
    }
    return false
  }

  // 随机生成每个组织的创建时间，分布在20年的范围内，时间固定为某月1号

  fun findLeader {
    var leader
    if (game.characters.length == 0) {
      // 人物列表是空的，此时要创造第一个角色
      leader = Character(
        birthTimestamp: createRandomBirthTimestamp(20) // 年龄至少是20岁
      )
    } else {
      var found = false
      for (final id in random.shuffle(game.characters.keys)) {
        final character = game.characters[id]
        final age = datetime.toYear(game.timestamp - character.birthTimestamp)
        // 年龄至少是20岁，并且不能担任其他组织职务
        if (character.organizationRank < 0 && age >= 20) {
          found = true
          leader = character
          break
        }
      }
      if (!found) {
        // 没有找到合适的人，则立刻创建一个
        leader = Character(
          birthTimestamp: createRandomBirthTimestamp(20), // 年龄至少是20岁
        )
      }
    }
    return leader
  }

  // 修真门派
  var createdCultivationOrganizationCount = 0
  var cultivationOrganizationCreatedDate = []
  for (final i in range(cultivationOrganizationNumber)) {
    cultivationOrganizationCreatedDate.add(random.nextInt(20 * kMonthsPerYear) * kTicksPerMonth)
  }
  cultivationOrganizationCreatedDate.sort()
  cultivationOrganizationCreatedDate = cultivationOrganizationCreatedDate.reversed.toList()
  
  // 商号
  // var createdTradinghouseOrganizationCount = 0
  // var tradinghouseOrganizationCreatedDate = []
  // for (final i in range(tradinghouseOrganizationNumber)) {
  //   tradinghouseOrganizationCreatedDate.add(random.nextInt(20 * kMonthsPerYear) * kTicksPerMonth)
  // }
  // tradinghouseOrganizationCreatedDate.sort()
  // tradinghouseOrganizationCreatedDate = tradinghouseOrganizationCreatedDate.reversed.toList()

  // 模拟世界演化，按照时间推进并生成人物、组织，并且为期分配人物关系
  // 在此种演化算法中，人物不会死亡，组织不会被消灭，因此只判断人数是否达到要求
  // 因为是模拟运行，每个tick接跳过一个月
  engine.info('快速模拟一段时间的演化，生成人物、组织、国家等信息')
  final islands = Set() // 用来保存在这一步骤才生成的隐居岛屿的门派据点
  do {
    if (createdCultivationOrganizationCount < cultivationOrganizationNumber) {
      if (game.timestamp >= cultivationOrganizationCreatedDate.last) {
        // 组织数量不够，在来到下一个组织创建时间时，创建组织
        cultivationOrganizationCreatedDate.removeLast()

        // 修真门派分成三种：入世、洞天、福地。入世是公开的据点。
        // 洞天是大陆上山峰所在地，福地是大海中的岛屿。
        // 洞天福地在未被探索之前，对玩家不可见。只是显示为平常的地形。
        // 如果据点生成在海洋之中，就将该地块设定为岛屿
        // 洞天福地的据点都直接以“xx山”, "xx岛"命名。

        // 在生成世界时，两个修真组织不会在同一个据点
        var headquarters

        final cultivationKind = random.nextIterable(_cultivationKinds)
        when (cultivationKind) {
          'location' -> {
            do {
              // 因为struct不能按照固定顺序排序，因此这里按照keys来随机。
              final headquartersId = random.nextIterable(game.locations.keys)
              headquarters = game.locations[headquartersId]
            } while (headquarters.hasCultivation)
          }
          'mountain' -> {
            // 临时生成一个新的隐藏据点
            final mountainTile
            do {
              final mountainTileIndex = random.nextIterable(mountains)
              mountainTile = game.world.terrains[mountainTileIndex]
            } while (mountainTile.locationId != null)

            headquarters = Location(
              terrainIndex: mountainTile.index,
              left: mountainTile.left,
              top: mountainTile.top,
              category: kLocationCategoryMountain,
            )
            mountainTile.locationId = headquarters.id
            // 隐居门派据点，名字在地图上一开始不可见
            // mountainTile.caption = headquarters.name
          }
          'island' -> {
            // 临时生成一个新的隐藏据点
            final islandTile
            do {
              final islandTileIndex = random.nextIterable(seas)
              islandTile = game.world.terrains[islandTileIndex]
            } while (islandTile.locationId != null)

            final islandZone = Zone(index: game.world.zones.length, category: kZoneCategoryIsland)
            game.world.zones.add(islandZone)
            addTerrainToZone(islandTile, islandZone.index, game.world)
            
            final neighbors = getMapTileNeighbors(islandTile.left, islandTile.top, game.world)
            for (final neighbor in neighbors) {
              seas.remove(neighbor.index)
              neighbor.spriteIndex == kSpriteShelf
            }

            headquarters = Location(
              terrainIndex: islandTile.index,
              left: islandTile.left,
              top: islandTile.top,
              category: kLocationCategoryIsland,
            )
            islandTile.locationId = headquarters.id
            // 隐居门派据点，名字在地图上一开始不可见
            // islandTile.caption = headquarters.name
          }
        }

        final leader = findLeader()
        // 创建组织
        Organization(
          category: kOrganizationCategoryCultivation,
          nationId: headquarters.nationId,
          headquartersId: headquarters.id,
          leaderId: leader.id,
        )

        ++createdCultivationOrganizationCount
      }
    }

    // 婴儿出生
    handleBabies()

    // 每年一次
    if (game.timestamp % kTicksPerYear == 0) {
      // 国家扩张
      for (final nation in nations) {
        expandNation(nation)
      }
      
      // 产生新的在野角色
      if (game.characters.length < characterNumber) {
        // 因为struct不能按照固定顺序排序，因此这里按照keys来随机。
        final locationId = random.nextIterable(game.locations.keys)
        final location = game.locations[locationId]
        final character = Character(
          locationId: location.id,
          birthTimestamp: createRandomBirthTimestamp(15, 50),
        )
      }

      // 为组织招募新的角色
      // engine.info('为组织招募新的角色')
      for (final id in random.shuffle(game.organizations.keys)) {
        final organization = game.organizations[id]
        // 暂时不为国家组织添加成员
        if (organization.category == kOrganizationCategoryNation) continue

        if (organizationMemberReachMax(organization) && organization.development < kOrganizationDevelopmentMax) {
          // engine.info('提升组织发展度')
          increaseOrganizationDevelopment(organization)
        } else {
          // 从最低等级开始，尝试提升成员等级
          for (final rank in range(kOrganizationRankMax, 0, -1)) {
            final membersOfThisRank = getOrganizationMemberIdOfRank(organization, rank)
            final membersOfHigherRank = getOrganizationMemberIdOfRank(organization, rank - 1)
            if (membersOfThisRank.length >= maxMemberOfRank(rank)) {
              if (membersOfHigherRank.length < maxMemberOfRank(rank - 1)) {
                final memberId = random.nextIterable(membersOfThisRank)
                final member = game.characters[memberId]
                setCharacterRank(member, organization, rank - 1)
                break
              }
            }
          }
        }
        
        var location = game.locations[organization.headquartersId]
        if (location.residingCharacterIds.isEmpty) {
          // 组织据点本身没有可用的人才（一般是因为是隐士据点）
          if (random.nextDouble() < kOrganizationRecruitOtherLocationProbability) {
            for (final otherLocation of game.locations) {
              if (otherLocation.id == location.id) continue

              if (otherLocation.residingCharacterIds.isNotEmpty) {
                location = otherLocation
                break
              }
            }
          }
        }

        if (location.residingCharacterIds.isNotEmpty) {
          if (random.nextDouble() < kOrganizationRecruitSuccessProbability) {
            final characterId = random.nextIterable(location.residingCharacterIds)
            final character = game.characters[characterId]
            if (character.organizationId != null) {
              engine.error(character.name, character.organizationId, organization.id)
            }
            addCharacterToOrganization(character, organization)
          }
        }
      }
      
      // 为角色添加家庭关系
      // engine.info('为角色添加家庭关系')
      for (final id in random.shuffle(game.characters.keys)) {
        final char = game.characters[id]
        final age = getCharacterAge(char)
        if (char.relationships.spouseId) {
          if (char.isFemale && !char.isPregnant && age < _kPregnancyAgeMax) {
            if (char.thinkings.contains('dink')) continue
            if (char.thinkings.contains('clumsy')) continue
            if (char.relationships.childrenIds.isNotEmpty) {
              if (char.personality.social < 10) continue
              if (char.personality.prudence > 10) continue
              if (char.personality.frugal > 10) continue
              if (char.relationships.childrenIds.length > 2) {
                continue
              }
            }
            final spouse = game.characters[char.relationships.spouseId]
            if (spouse.thinkings.contains('dink')) continue
            if (spouse.thinkings.contains('clumsy')) continue
            Baby(
              father: spouse,
              mother: char,
              conceptionTimestamp: game.timestamp,
            )
          }
        } else {
          if (age > _kCharacterMarriageAgeMin && age < _kCharacterMarriageAgeMax) {
            for (final otherId in random.shuffle(game.characters.keys)) {
              if (id == otherId) continue
              final otherChar = game.characters[otherId]
              // TODO: 这里暂时没有允许同性婚姻
              if (otherChar.isFemale == char.isFemale) continue
              final otherCharAge = getCharacterAge(otherChar)
              if (otherCharAge > _kCharacterMarriageAgeMin
                  && otherCharAge < _kCharacterMarriageAgeMax
                  && otherChar.relationships.spouseId == null) {
                char.relationships.spouseId = otherId
                otherChar.relationships.spouseId = id
                var home
                if (char.organizationRank < otherChar.organizationRank) {
                  home = game.locations[char.homeId]
                } else if (char.organizationRank > otherChar.organizationRank) {
                  home = game.locations[otherChar.homeId]
                } else {
                  if (otherChar.isFemale) {
                    home = game.locations[char.homeId]
                  } else {
                    home = game.locations[otherChar.homeId]
                  }
                }
                characterFirstMet(char, otherChar)
                final incidentContent = getLocaleString('incidentMarriage', [
                    char.name,
                    otherChar.name,
                    home.name,
                  ])
                Incident(
                  content: incidentContent,
                  subjectIds: [char.id, otherChar.id],
                  locationId: home.id,
                  order: 20,
                )
                char.marriageTimestamp = game.timestamp
                otherChar.marriageTimestamp = game.timestamp
                break
              }
            }
          }
        }
      }
    }

    // 因为是模拟运行，时间直接以月为单位流逝
    game.timestamp += kTicksPerMonth
  } while (
    game.characters.length < characterNumber ||
    createdCultivationOrganizationCount < cultivationOrganizationNumber
  )

  // 为生成的世界填充一些必要信息

  // 为角色添加次要动机
  for (final id in random.shuffle(game.characters.keys)) {
    final char = game.characters[id]
    if (char.organizationId == null) {
      char.motivations.add('recruitment')
    }
    if (char.relationships.spouseId == null) {
      final age = getCharacterAge(char)
      if (age > _kCharacterMarriageAgeMin && age < _kCharacterMarriageAgeMax) {
        char.motivations.add('marriage')
      }
    } else {
      if (char.relationships.childrenIds.isEmpty) {
        char.motivations.add('child')
      }
    }
  }

  // 在不改变时间的情况下刷新一下世界事件
  updateGame(timeflow: false, playerEvent: false)

  // 将地域的上色信息复制到引擎侧
  engine.info('刷新世界地图上色信息')
  loadColors()

  engine.info('世界生成完毕。重置随机数生成器。')
  setRandomSeed()

  return game.world
}

fun loadWorldMap(jsonData) {
  engine.info('载入世界地图数据')
  final data = prototype.fromJson(jsonData)
  game.world = data
}

fun getWorld() {
  return game.world
}

fun getZoneByIndex(index: int) {
  return game.world.zones[index]
}

/// 刷新地图上色信息
fun loadColors {
  final colors = []
  final zoneColors = Map()
  final nationColors = Map()
  for (final tile in game.world.terrains) {
    if (tile.zoneIndex) {
      final zone = game.world.zones[tile.zoneIndex]
      zoneColors[tile.index] = zone.color
    }
    if (tile.nationId) {
      final nation = game.organizations[tile.nationId]
      nationColors[tile.index] = nation.color
    }
  }
  colors.add(zoneColors)
  colors.add(nationColors)
  engine.loadColors(colors)
}
