import '../name/name.ht' as nameGenerator
import '../game.ht'
import '../entity/location/site.ht'
import '../entity/location/location.ht'
import '../entity/character/character.ht'
import '../entity/organization.ht'
import '../entity/nation.ht'
import '../l10n.ht'
import '../tile/hexagonal_tile.ht'
import '../tile/tilemap.ht'
import '../entity/common.ht'
import '../datetime.ht' as datetime
import '../logic.ht'
import 'generation_algorithm.ht'
import '../tile/common.ht'
import '../dialog.ht'

/// 生成世界地图的算法
///
/// spritesheet上不同地形对应的编号：
/// 0：虚空
/// 1：浅海
/// 2：深海
/// 3：陆地（草原）
///
/// 算法思路：
///
/// 用海面填满整个地图空间
///
/// 找到一个出发点，通常在地图中间部分
///
/// 找到出发点周围的方块，将其加入一个数组，作为当前陆地的边界
///
/// 将当前方块变成陆地，检查陆地比例，如果不够，就从当前陆地边界中随机挑选一个方块，将其变成陆地，同时重新计算边界。
///
/// 循环上述步骤，直到陆地和海水的比例达到预设值
///
/// 为陆地所属的整个大地块命名，然后找到尚未命名的地块，将所有相连的地块作为一个整体命名，直到所有的地块都有名字，根据地块大小有不同命名方式
///
/// 根据城市密度，生成城市，并根据城市位于陆地、海边还是海中，对其进行特殊命名
///
/// 对于每个城市，链接最近的另外两个城市，使用 A* 寻路算法，标记经过的地块
///
/// 对于没有道路经过的地块，随机填充山脉和树林

const _kDefaultWorldScale = 1
final _kWorldSizePerWorldScale = {
  '1': 12,
  '2': 18,
  '3': 27,
  '4': 40,
}
const _kDefaultNationNumber = 4
const _kDefaultLocationNumber = 6
const _kDefaultOrganizationNumber = 4
const _kDefaultCharacterNumber = 20

const _kMinZoneSizeForSea = 8
const _kMinZoneSizeForIsland = 8
const _kForestThreshold = 0.5
const _kMountainThreshold = 0.2

const _kCharacterMarriageAgeMin = 15
const _kCharacterMarriageAgeMax = 40
const _kPregnancyAgeMax = 40

const _kLocationInitialDevelopmentMax = 3

fun createWorldMap({
    id,
    seedString,
    style = 'coast',
    terrainSpriteSheet: str,
    worldScale = _kDefaultWorldScale,
    nationNumber = _kDefaultNationNumber,
    locationNumber = _kDefaultLocationNumber,
    organizationNumber = _kDefaultOrganizationNumber,
    characterNumber = _kDefaultCharacterNumber,
    // landProportion = 0.55,
    scale = 2.0,
  }) {
  assert(id != null)
  assert(seedString is str && seedString.isNotEmpty)
  assert(organizationNumber < locationNumber)
  assert(organizationNumber < characterNumber)

  final seed = Hash.crcInt(seedString)
  engine.info('开始生成世界，设置随机数种子为：${seedString}(${seed})')
  setRandomSeed(seed)
  
  delete game.savePath
  game.nations = {}
  game.characters = {}
  game.locations = {}
  game.organizations = {}
  game.mazes = {}
  
  history = []

  final width
  final height

  width = height = _kWorldSizePerWorldScale[worldScale.toString()]

  // 生成过程中，引入了一些别的文件中的函数
  // 他们可能会通过game.world访问, 因此这里直接使用全局变量
  game.world = TileMap(
    id: id,
    width: width,
    height: height,
    scale: scale,
  )

  // 地图上的可互动对象，因为世界地图目前只有一层，所以这个表直接放在map上。
  game.world.entities = {}

  game.world.isNewGame = true

  engine.info('生成地块')
  for (var j in range(height)) {
    for (var i in range(width)) {
      game.world.terrains.add(
        {
          ...Tile(i + 1, j + 1),
          index: tilePos2Index(i + 1, j + 1, width),
          spriteIndex: kSpriteWater,
          overlaySprite: {},
          showGrid: true,
          isSelectable: true,
        }
      )
    }
  }

  // 没有区域，也是一个区域
  final voidZone = Zone(index: game.world.zones.length, name: null, category: kZoneVoid)
  game.world.zones.add(voidZone)


  // 生成地域
  engine.info('准备生成地域')
  final landZone = Zone(index: game.world.zones.length, category: kZoneLand)
  game.world.zones.add(landZone)
  generateContinent(
    seed: seed,
    size: width,
    style: style,
  )

  // 根据相邻的格子的地域，分配地域索引
  fun updateZone(tile, [spriteIndex, unzonedNeighbors]) {
    assert(tile.zoneIndex == null)
    var willCreateZone = true
    if (spriteIndex != null) {
      willCreateZone = false
    } else {
      spriteIndex = tile.spriteIndex
    }
    unzonedNeighbors ??= {}
    // engine.info('processing: ${tile.left},${tile.top}, spriteIndex: ${tile.spriteIndex}')
    tile.zoneIndex = -1 // mark this tile is being processed, will skip it when process others
    final neighbors = getMapTileNeighbors(tile.left, tile.top, game.world)
    var foundAdjacentZone = false
    for (final neighbor in neighbors) {
      // skip tiles that has diffrent spriteIndex and those still being processed
      if (neighbor.spriteIndex != spriteIndex) continue
      if (neighbor.zoneIndex == null) {
        updateZone(neighbor, spriteIndex, unzonedNeighbors)
      }
      if (neighbor.zoneIndex == -1) {
        unzonedNeighbors[neighbor.index] = neighbor
        continue
      }
      addTerrainToZone(tile, neighbor.zoneIndex, game.world)
      foundAdjacentZone = true
      // engine.info('Found neighbor: ${neighbor.left},${neighbor.top}, zoneIndex: ${neighbor.zoneIndex}')
      break
    }
    if (!foundAdjacentZone && willCreateZone) {
      var category = tile.spriteIndex == kSpriteLand ? kZoneLand : kZoneWater
      final zone = Zone(index: game.world.zones.length, category: category)
      game.world.zones.add(zone)
      // engine.info('Created zone! left: ${tile.left}, top: ${tile.top} spriteIndex: ${tile.spriteIndex}, zoneIndex: ${zone.index}')
      addTerrainToZone(tile, zone.index, game.world)
      // engine.info('processing previoused stored unzoned tiles: ${unzonedNeighbors}')
      for (final unzonedTile of unzonedNeighbors) {
        if (unzonedTile.zoneIndex == -1) {
          addTerrainToZone(unzonedTile, zone.index, game.world)
        }
      }
    }
  }

  var unzonedTile
  engine.info('开始生成地域')
  while (
    unzonedTile = game.world.terrains.firstWhere((tile) => tile.zoneIndex == null)
  ) {
    // engine.info('updating unzoned tile')
    updateZone(unzonedTile)
  }
  
  // 将大陆和海洋接触的地方填充为大陆架
  // 大陆架只影响贴图，不影响该地块的 category 和 kind
  engine.info('将大陆和海洋接触的地方填充为大陆架')
  for (final tile in game.world.terrains) {
    if (tile.spriteIndex != kSpriteWater) continue
    final neighbors = getMapTileNeighbors(tile.left, tile.top, game.world)
    for (final neighbor in neighbors) {
      if (neighbor.spriteIndex == kSpriteLand) {
        tile.spriteIndex = kSpriteShelf
        break
      }
    }
  }

  fun find2NearestLocation(origin, {restricted2Zone: bool = true}) {
    assert(game.locations.length > 0)
    var nearest
    var nearestDistance
    var secondNearest
    var secondNearestDistance
    for (final location of game.locations) {
      if (location.index == origin.index) {
        continue
      } else {
        final start = game.world.terrains[origin.terrainIndex]
        final end = game.world.terrains[location.terrainIndex]
        final distance = getTileDistance(start, end)
        if (!restricted2Zone || location.zoneIndex == origin.zoneIndex) {
          if (nearestDistance == null || distance < nearestDistance) {
            nearestDistance = distance
            nearest = location
          } else if (secondNearestDistance == null || distance < secondNearestDistance) {
            secondNearestDistance = distance
            secondNearest = location
          } else {
            continue
          }
        }
      }
    }
    return { nearest, secondNearest }
  }

  // 生成据点
  engine.info('生成大陆上的据点')
  final locationIndexes = Set()
  while (game.locations.length < locationNumber) {
    var index
    var tile
    do {
      // engine.info('generating location index')
      index = random.nextInt(game.world.terrains.length)
      tile = game.world.terrains[index]
    } while (locationIndexes.contains(index) || tile.spriteIndex != kSpriteLand)
    // location category只有两种：城市和秘境
    final location = Location(terrainIndex: index, category: kLocationCategoryCity)
    // 随机生成的据点，初始发展度是0-2之间随机。
    location.development = random.nextInt(_kLocationInitialDevelopmentMax)
    locationIndexes.add(index)
    tile.locationId = location.id
    // 城市的贴图重叠于地形贴图之上
    tile.overlaySprite.index = kSpriteCity
  }

  engine.info('确保陆地上的每个城市至少可以链接到另外两个城市')
  for (final location of game.locations) {
    final start = game.world.terrains[location.terrainIndex]
    // 确保陆地上的每个城市至少可以链接到另外两个城市
    if (start.zoneCategory == kZoneLand) {
      final searchResult = find2NearestLocation(location, restricted2Zone: true)
      if (searchResult.nearest) {
        final end = game.world.terrains[searchResult.nearest.terrainIndex]
        final route = calculateRoute(start, end, game.world)
        if (route) {
          // routes.add(route)
          for (final index in route) {
            final terrain = game.world.terrains[index]
            terrain.isRoute = true
          }
        }
      }
      if (searchResult.secondNearest) {
        final end = game.world.terrains[searchResult.secondNearest.terrainIndex]
        final route = calculateRoute(start, end, game.world)
        if (route) {
          // routes.add(route)
          for (final index in route) {
            final terrain = game.world.terrains[index]
            terrain.isRoute = true
          }
        }
      }
    }
  }

  // 将大陆上没有道路的方格，随机填充为平原、森林、山地
  engine.info('将大陆上没有道路的方格，随机填充为平原、森林、山地')
  for (final tile in game.world.terrains) {
    if (tile.spriteIndex != kSpriteLand) continue
    if (!tile.isRoute) {
      final r = random.nextDouble()
      if (r < _kMountainThreshold) {
        tile.spriteIndex = kSpriteMountain
      } else if (r < _kForestThreshold) {
        tile.spriteIndex = kSpriteForest
      }
    }
  }

  // 因为 zone 的名字和其大小有关，因此在最后在才命名和赋值 category/kind
  engine.info('为地域命名')
  for (final zone in game.world.zones) {
    if (zone.name) {
      continue
    }
    // kZoneWater & kZoneLand 只是临时类型，现在替换为具体的类型
    if (zone.category == kZoneWater) {
      zone.category = zone.terrainIndexes.length < _kMinZoneSizeForSea ? kZoneCategoryLake : kZoneCategorySea
      
      // 为该地域中所有地块赋值 kind
      for (final terrainIndex in zone.terrainIndexes) {
        final tile = game.world.terrains[terrainIndex]
        tile.isWater = true
        tile.zoneCategory = zone.category
        tile.kind = zone.category
      }
    } else {
      zone.category = zone.terrainIndexes.length < _kMinZoneSizeForIsland ? kZoneCategoryIsland : kZoneCategoryContinent
      
      // 为该地域中所有地块赋值 kind
      for (final terrainIndex in zone.terrainIndexes) {
        final tile = game.world.terrains[terrainIndex]
        tile.zoneCategory = zone.category
        
        if (tile.locationId) {
          tile.kind = kTerrainKindLocation
        }
        // else if (tile.isRoute) {
        //   tile.kind = kTerrainKindRoad
        // }
        else if (tile.spriteIndex == kSpriteMountain) {
          tile.kind = kTerrainKindMountain
        } else if (tile.spriteIndex == kSpriteForest) {
          tile.kind = kTerrainKindForest
        } else {
          tile.kind = kTerrainKindPlain
        }
        // TODO: river类型和道路类型单独的贴图
      }
    }

    final r = nameGenerator.getZone(1, category: zone.category)
    zone.name = r.first.name

  }

  // TODO: 生成洞天福地，洞天是大陆上山峰所在地，福地是大海中的岛屿
  // 洞天福地在未被探索之前，对玩家不可见。只是显示为平常的地形。
  // 如果据点生成在海洋之中，就将该地块设定为岛屿
  // checkPerimeterOfLocation(tile)
  // 洞天福地都直接以“xx山”, "xx岛"命名，并且没有特别装备的话，一开始无法进入。

  // 每个岛屿是独立的 zone
  // engine.info('处理据点所在岛屿')
  // for (final island in islands) {
  //   final islandZone = Zone(index: game.world.zones.length, category: kZoneIsland)
  //   game.world.zones.add(islandZone)
  //   addTerrainToZone(island, islandZone.index, game.world)
  // }

  // 随机挑选几个城市，作为各个国家的都城，生成地图上的不同国家
  engine.info('随机挑选几个城市，作为各个国家的都城，生成地图上的不同国家')
  while (game.nations.length < nationNumber) {
    var location
    do {
      // 因为struct不能按照固定顺序排序，因此这里按照keys来随机。
      final locationId = random.nextIterable(game.locations.keys)
      location = game.locations[locationId]
    } while (location.nationId != null)
    // engine.info('picking location for new nation capital: ${location}')
    final nation = Nation(capitalId: location.id)
    Site(category: kSitePalace, location: location)
    final terrain = game.world.terrains[location.terrainIndex]
    addTerrainToNation(nation, terrain)
  }
  
  // 一个国家将其疆域扩展到周边的一个格子
  // 返回值表示是否扩展成功
  fun expandNation(nation) {
    // engine.info('processing nation: ${nation}')
    assert(nation.borderIndexes != null && nation.borderIndexes.isNotEmpty)
    // avoid editing iterable while iterating
    for (final index in random.shuffle(nation.borderIndexes)) {
      final terrain = game.world.terrains[index]
      if (terrain.nationId == null && !terrain.isWater) {
        addTerrainToNation(nation, terrain)
        return true
      }
    }
    return false
  }

  // 随机生成每个修真门派的创建时间，分布在20年的范围内，时间固定为某月1号
  var cultivationOrganizationCreatedDate = []
  for (final i in range(organizationNumber)) {
    cultivationOrganizationCreatedDate.add(random.nextInt(20 * kMonthsPerYear) * kTicksPerMonth)
  }
  cultivationOrganizationCreatedDate.sort()
  cultivationOrganizationCreatedDate = cultivationOrganizationCreatedDate.reversed.toList()

  fun findLeader {
    var leader
    if (game.characters.length == 0) {
      // 人物列表是空的，此时要创造第一个角色
      leader = Character(
        birthTimestamp: createRandomBirthTimestamp(20) // 年龄至少是20岁
      )
    } else {
      var found = false
      for (final id in random.shuffle(game.characters.keys)) {
        final character = game.characters[id]
        final age = datetime.toYear(game.timestamp - character.birthTimestamp)
        // 年龄至少是20岁，并且不能担任其他组织职务
        if (character.organizationRank == 0 && age >= 20) {
          found = true
          leader = character
          break
        }
      }
      if (!found) {
        // 没有找到合适的人，则立刻创建一个
        leader = Character(
          birthTimestamp: createRandomBirthTimestamp(20), // 年龄至少是20岁
        )
      }
    }
    return leader
  }

  // 模拟世界演化，按照时间推进并生成人物、组织，并且为期分配人物关系
  // 在此种演化算法中，人物不会死亡，组织不会被消灭，因此只判断人数是否达到要求
  // 因为是模拟运行，每个tick接跳过一个月
  engine.info('快速模拟一段时间的演化，生成人物、组织、国家等信息')
  do {
    if (game.organizations.length < organizationNumber) {
      if (game.timestamp >= cultivationOrganizationCreatedDate.last) {
        // 组织数量不够，在来到下一个组织创建时间时，创建组织
        cultivationOrganizationCreatedDate.removeLast()

        // 组织总舵不允许和其他组织的总舵在同一个据点
        final headquarters
        do {
          // 因为struct不能按照固定顺序排序，因此这里按照keys来随机。
          final headquartersId = random.nextIterable(game.locations.keys)
          headquarters = game.locations[headquartersId]
        } while (headquarters.organizaitons.isNotEmpty)

        final leader = findLeader()
        setLeader()
        
        // 创建组织
        Organization(
          category: kOrganizationCategoryCaltivation,
          nationId: headquarters.nationId,
          headquartersId: headquarters.id,
          leaderId: leader.id,
        )
      }


    }

    // 婴儿出生
    handleBabies()
    
    // 产生新的在野角色
    if (game.characters.length < characterNumber) {
      // 因为struct不能按照固定顺序排序，因此这里按照keys来随机。
      final locationId = random.nextIterable(game.locations.keys)
      final location = game.locations[locationId]
      final character = Character(
        locationId: location.id,
        birthTimestamp: createRandomBirthTimestamp(15, 50),
      )
    }
    
    // 为组织招募新的角色
    for (final id in random.shuffle(game.organizations.keys)) {
      final organization = game.organizations[id]
      final location = game.locations[organization.headquartersId]
      if (location.residingCharacterIds.isNotEmpty) {
        final characterId = random.nextIterable(location.residingCharacterIds)
        final character = game.characters[characterId]
        assert(character.organizationId == null)
        addCharacterToOrganization(character, organization)
      }
    }
    
    // 为角色添加家庭关系
    for (final id in random.shuffle(game.characters.keys)) {
      final char = game.characters[id]
      final age = getCharacterAge(char)
      if (char.relationships.spouseId) {
        if (char.isFemale && !char.isPregnant && age < _kPregnancyAgeMax) {
          if (char.thinkings.contains('dink')) continue
          if (char.thinkings.contains('clumsy')) continue
          if (char.relationships.childrenIds.isNotEmpty) {
            if (char.personality.social < 10) continue
            if (char.personality.prudence > 10) continue
            if (char.personality.frugal > 10) continue
            if (char.relationships.childrenIds.length > 2) {
              continue
            }
          }
          final spouse = game.characters[char.relationships.spouseId]
          if (spouse.thinkings.contains('dink')) continue
          if (spouse.thinkings.contains('clumsy')) continue
          Baby(
            father: spouse,
            mother: char,
            conceptionTimestamp: game.timestamp,
          )
        }
      } else {
        if (age > _kCharacterMarriageAgeMin && age < _kCharacterMarriageAgeMax) {
          for (final otherId in random.shuffle(game.characters.keys)) {
            if (id == otherId) continue
            final otherChar = game.characters[otherId]
            // TODO: 这里暂时没有允许同性婚姻
            if (otherChar.isFemale == char.isFemale) continue
            final otherCharAge = getCharacterAge(otherChar)
            if (otherCharAge > _kCharacterMarriageAgeMin
                && otherCharAge < _kCharacterMarriageAgeMax
                && otherChar.relationships.spouseId == null) {
              char.relationships.spouseId = otherId
              otherChar.relationships.spouseId = id
              var home
              if (char.organizationRank > otherChar.organizationRank) {
                home = game.locations[char.homeId]
              } else if (char.organizationRank < otherChar.organizationRank) {
                home = game.locations[otherChar.homeId]
              } else {
                if (otherChar.isFemale) {
                  home = game.locations[char.homeId]
                } else {
                  home = game.locations[otherChar.homeId]
                }
              }
              characterFirstMet(char, otherChar)
              final incidentContent = getLocaleString('incidentMarriage', [
                  char.name,
                  otherChar.name,
                  home.name,
                ])
              Incident(
                content: incidentContent,
                subjectIds: [char.id, otherChar.id],
                locationId: home.id,
                order: 20,
              )
              char.marriageTimestamp = game.timestamp
              otherChar.marriageTimestamp = game.timestamp
              break
            }
          }
        }
      }
    }

    // 每半年一次
    if (game.timestamp % (kTicksPerMonth * 6) == 0) {
      for (final nation of game.nations) {
        expandNation(nation)
      }
    }

    // 因为是模拟运行，时间直接以月为单位流逝
    game.timestamp += kTicksPerMonth
  } while (game.characters.length < characterNumber || game.organizations.length < organizationNumber)

  // 为生成的世界填充一些必要信息

  // 为角色添加次要动机
  for (final id in random.shuffle(game.characters.keys)) {
    final char = game.characters[id]
    if (char.organizationId == null) {
      char.motivations.add('recruitment')
    }
    if (char.relationships.spouseId == null) {
      final age = getCharacterAge(char)
      if (age > _kCharacterMarriageAgeMin && age < _kCharacterMarriageAgeMax) {
        char.motivations.add('marriage')
      }
    } else {
      if (char.relationships.childrenIds.isEmpty) {
        char.motivations.add('child')
      }
    }
  }

  // 在不改变时间的情况下刷新一下世界事件
  updateGame(timeflow: false)

  // 将地域的上色信息复制到引擎侧
  engine.info('刷新世界地图上色信息')
  updateWorldMapZoneColors()
  updateWorldMapNationColors()

  engine.info('世界生成完毕。重置随机数生成器。')
  setRandomSeed()

  return game.world
}

fun loadWorldMap(jsonData) {
  engine.info('载入世界地图数据')
  final data = prototype.fromJson(jsonData)
  game.world = data
}

fun getWorld() {
  return game.world
}

fun getZoneByIndex(index: int) {
  return game.world.zones[index]
}

/// 刷新地图地域上色信息
fun updateWorldMapZoneColors {
  final zoneColors = Map()
  for (final zone in game.world.zones) {
    zoneColors[zone.index] = zone.color
  }
  engine.updateZoneColors(zoneColors)
}
  
/// 刷新地图疆域上色信息
fun updateWorldMapNationColors {
  final nationColors = Map()
  for (final nation of game.nations) {
    nationColors[nation.id] = nation.color
  }
  engine.updateNationColors(nationColors)
}
