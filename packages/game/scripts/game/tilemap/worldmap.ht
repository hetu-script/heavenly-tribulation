import '../name/name.ht' as nameGenerator
import '../../game.ht'
import '../../location.ht'
import '../../character.ht'
import '../../nation.ht'
import '../../incident.ht'
import '../../l10n.ht'
import 'hexagonal_tile.ht'
import 'component.ht'
import '../../map.ht'
import '../util.ht'
import '../arcane.ht'
import '../martial.ht'
import '../attributes.ht'

/// 生成世界地图的算法
///
/// spritesheet上不同地形对应的编号：
/// 0：虚空
/// 1：浅海
/// 2：深海
/// 3：陆地（草原）
///
/// 算法思路：
///
/// 用海面填满整个地图空间
///
/// 找到一个出发点，通常在地图中间部分
///
/// 找到出发点周围的方块，将其加入一个数组，作为当前陆地的边界
///
/// 将当前方块变成陆地，检查陆地比例，如果不够，就从当前陆地边界中随机挑选一个方块，将其变成陆地，同时重新计算边界。
///
/// 循环上述步骤，直到陆地和海水的比例达到预设值
///
/// 为陆地所属的整个大地块命名，然后找到尚未命名的地块，将所有相连的地块作为一个整体命名，直到所有的地块都有名字，根据地块大小有不同命名方式
///
/// 根据城市密度，生成城市，并根据城市位于陆地、海边还是海中，对其进行特殊命名
///
/// 对于每个城市，链接最近的另外两个城市，使用 A* 寻路算法，标记经过的地块
///
/// 对于没有道路经过的地块，随机填充山脉和树林

const _defaultWorldWidth = 12
const _defaultWorldHeight = 12
const _defaultNationNumber = 5
const _kSpriteWater = 1
const _kSpriteShelf = 2
const _kSpriteLand = 3
const _kSpriteCity = 4
const _kSpriteForest = 5
const _kSpriteMountain = 6
const _kLocationCategoryCity = 'city'
const _kLocationCategoryUnchartedLand = 'unchartedLand'
const _kLocationCategoryUnchartedIsland = 'unchartedIsland'
const _kZoneVoid = 'empty'
const _kZoneWater = 'water'
const _kZoneContinent = 'continent'
const _kZoneIsland = 'island'
const _kZoneLake = 'lake'
const _kOrganizationCategoryCultivation = 'caltivation'
const _kTileSizeForLocation = 24 // 据点密度
const _kMinZoneSizeForSea = 8
const _kZoneSizeForHarbor = 18
const _kForestThreshold = 0.5
const _kMountainThreshold = 0.2
const _kMinLocationNumberForOrganization = 0.5 // 最大组织密度
const _kMinNpcNumberForOrganization = 3
const _kMaxNpcNumberForOrganization = 9

struct SpiritOrigin {
  construct {
    final roots = [
      'water',
      'fire',
      'metal',
      'wood',
      'earth',
    ]

    var n = 10
    var max = 0
    for (var root in roots) {
      final current = n - hyperbola(n)
      if (current > max) {
        max = current
      }
      this[root] = current
      n -= current
    }
    
    if (max > 9) {
      this.rarity = 'exotic'
    } else if (max > 8) {
      this.rarity = 'mythic'
    } else if (max > 7) {
      this.rarity = 'legendary'
    } else if (max > 6) {
      this.rarity = 'epic'
    } else if (max > 5) {
      this.rarity = 'rare'
    } else if (max > 4) {
      this.rarity = 'uncommon'
    } else if (max > 3) {
      this.rarity = 'common'
    }
  }
}

struct Zone {
  var index: int
  var name: str
  var category: str
  var count = 0
  final terrainIndexes = Set()

  construct ({name, category}) {
    this.index = game.world.zones.length
    this.name = name
    this.category = category
    this.color = Math.randomBrightColorHex()
    game.world.zones.add(this)
  }
}

fun addTerrain2Zone(zoneIndex, terrain) {
  assert(0 <= zoneIndex && zoneIndex < game.world.zones.length)
  if (terrain.zoneIndex != null && terrain.zoneIndex >= 0) {
    final oldZone = game.world.zones[terrain.zoneIndex]
    oldZone.terrainIndexes.remove(terrain.index)
  }
  final zone = game.world.zones[zoneIndex]
  terrain.zoneIndex = zoneIndex
  terrain.zoneCategory = zone.category
  zone.terrainIndexes.add(terrain.index)
}

fun createWorldMap({
    terrainSpriteSheet: str,
    tileShape = 'hexagonalVertical',
    width = _defaultWorldWidth,
    height = _defaultWorldHeight,
    style = 'island',
    nationNumber = _defaultNationNumber,
    landProportion = 0.55,
    gridWidth = 32.0,
    gridHeight = 28.0,
    tileSpriteSrcWidth = 32.0,
    tileSpriteSrcHeight = 48.0,
    tileOffsetX = 0.0,
    tileOffsetY = 2.0,
  }) {
  engine.info('开始生成世界')

  game.savePath = null
  game.nations = {}
  game.characters = {}
  game.locations = {}
  game.organizations = {}
  game.mazes = {}
  game.incidents = []

  game.world = {
    terrainSpriteSheet,
    tapSelect: true,
    tileShape,
    width,
    height,
    gridWidth,
    gridHeight,
    tileSpriteSrcWidth,
    tileSpriteSrcHeight,
    tileOffsetX,
    tileOffsetY,
    zones: [],
    terrains: [],
  }

  for (var j in range(height)) {
    for (var i in range(width)) {
      game.world.terrains.add(
        {
          ...Tile(i + 1, j + 1),
          index: tilePos2Index(i + 1, j + 1),
          spriteIndex: _kSpriteWater,
          overlaySprite: {},
          ...SpiritOrigin(),
        }
      )
    }
  }

  engine.info('生成地块')

  // 没有区域，也是一个区域
  final voidZone = Zone(name: '无', category: _kZoneVoid)

  // 当前地域的边缘格子坐标
  final shelf = Set()

  // 刷新当前地域的边缘格子坐标
  fun updateShelf(left, top) {
    shelf.remove(tilePos2Index(left, top))
    final neighbors = getMapTileNeighbors(left, top, restricted2Zone: false)
    for (final tile in neighbors) {
      if (tile.spriteIndex == _kSpriteWater) {
        shelf.add(tile.index)
      }
    }
  }

  engine.info('生成地块边缘坐标')

  // 生成地域
  final landArea = (width * height * landProportion).floor()

  final minLeft = width ~/ 3
  final minTop = height ~/ 3
  final maxLeft = width ~/ 3 * 2
  final maxTop = height ~/ 3 * 2

  final startLeft = Math.randomInt(maxLeft - minLeft) + minLeft
  final startTop = Math.randomInt(maxTop - minTop) + minTop
  game.world.heroX = startLeft
  game.world.heroY = startTop
  // print('start: ${startLeft},${startTop}')
  final startIndex = tilePos2Index(startLeft, startTop)
  final firstTile = game.world.terrains[startIndex]
  firstTile.spriteIndex = _kSpriteLand
  final landZone = Zone(category: _kZoneContinent)
  addTerrain2Zone(landZone.index, firstTile)
  updateShelf(startLeft, startTop)

  var currentLandSize = 1
  while (currentLandSize < landArea) {
    // print('expanding land')
    ++currentLandSize
    final tile = game.world.terrains[shelf.random]
    updateShelf(tile.left, tile.top)
    tile.spriteIndex = _kSpriteLand
    addTerrain2Zone(landZone.index, tile)
  }

  // 生成地图上的不同地域
  // 根据相邻的格子的地域，分配地域索引
  fun updateZone(tile, [spriteIndex, unzonedNeighbors]) {
    assert(tile.zoneIndex == null)
    var willCreateZone = true
    if (spriteIndex != null) {
      willCreateZone = false
    } else {
      spriteIndex = tile.spriteIndex
    }
    unzonedNeighbors ??= {}
    // print('processing: ${tile.left},${tile.top}, spriteIndex: ${tile.spriteIndex}')
    tile.zoneIndex = -1 // mark this tile is being processed, will skip it when process others
    final neighbors = getMapTileNeighbors(tile.left, tile.top)
    var foundAdjacentZone = false
    for (final neighbor in neighbors) {
      // skip tiles that has diffrent spriteIndex and those still being processed
      if (neighbor.spriteIndex != spriteIndex) continue
      if (neighbor.zoneIndex == null) {
        updateZone(neighbor, spriteIndex, unzonedNeighbors)
      }
      if (neighbor.zoneIndex == -1) {
        unzonedNeighbors[neighbor.index] = neighbor
        continue
      }
      addTerrain2Zone(neighbor.zoneIndex, tile)
      foundAdjacentZone = true
      // print('Found neighbor: ${neighbor.left},${neighbor.top}, zoneIndex: ${neighbor.zoneIndex}')
      break
    }
    if (!foundAdjacentZone && willCreateZone) {
      var category = tile.spriteIndex == _kSpriteLand ? _kZoneContinent : _kZoneWater
      final zone = Zone(category: category)
      // print('Created zone! left: ${tile.left}, top: ${tile.top} spriteIndex: ${tile.spriteIndex}, zoneIndex: ${zone.index}')
      addTerrain2Zone(zone.index, tile)
      // print('processing previoused stored unzoned tiles: ${unzonedNeighbors}')
      for (final unzonedTile of unzonedNeighbors) {
        if (unzonedTile.zoneIndex == -1) {
          addTerrain2Zone(zone.index, unzonedTile)
        }
      }
    }
  }

  engine.info('生成地域')

  var unzonedTile

  while (
    unzonedTile = game.world.terrains.firstWhere((tile) => tile.zoneIndex == null)
  ) {
    // print('updating unzoned tile')
    updateZone(unzonedTile)
  }

  fun find2NearestLocation(origin, {restricted2Zone: bool = true}) {
    assert(game.locations.length > 0)
    var nearest
    var nearestDistance
    var secondNearest
    var secondNearestDistance
    for (final location of game.locations) {
      if (location.index == origin.index) {
        continue
      } else {
        final start = game.world.terrains[origin.terrainIndex]
        final end = game.world.terrains[location.terrainIndex]
        final distance = getTileDistance(start, end)
        if (!restricted2Zone || location.zoneIndex == origin.zoneIndex) {
          if (nearestDistance == null || distance < nearestDistance) {
            nearestDistance = distance
            nearest = location
          } else if (secondNearestDistance == null || distance < secondNearestDistance) {
            secondNearestDistance = distance
            secondNearest = location
          } else {
            continue
          }
        }
      }
    }
    return { nearest, secondNearest }
  }

  final islands = []
  // 根据 tile 的所在位置的类型，添加属性
  fun checkPerimeterOfLocation(tile) {
    if (tile.spriteIndex == _kSpriteLand) return
    final neighbors = getMapTileNeighbors(tile.left, tile.top)
    for (final neighbor in neighbors) {
      if (neighbor.spriteIndex == _kSpriteLand) {
        tile.isHarbor = true
        tile.harborOfZoneIndex = tile.zoneIndex
        addTerrain2Zone(neighbor.zoneIndex, tile)
        return
      }
    }
    islands.add(tile)
  }

  engine.info('根据 tile 的所在位置的类型，添加属性')

  // 生成据点
  final locationIndexes = Set()
  final locationNumber = game.world.terrains.length ~/ _kTileSizeForLocation
  while (game.locations.length < locationNumber) {
    var index
    do {
      // print('generating location index')
      index = Math.randomInt(game.world.terrains.length)
    } while (locationIndexes.contains(index))
    final tile = game.world.terrains[index]
    // location category只有两种：城市和秘境
    final location = Location(terrainIndex: index, category: _kLocationCategoryCity)
    locationIndexes.add(index)
    checkPerimeterOfLocation(tile)
    tile.locationId = location.id
    tile.overlaySprite.index = _kSpriteCity
  }
  engine.info('生成据点')

  // 每个岛屿是独立的 zone
  for (final island in islands) {
    final islandZone = Zone(category: _kZoneIsland)
    addTerrain2Zone(islandZone.index, island)
  }
  engine.info('处理岛屿')

  // 因为 zone 的命名和其大小有关，因此在最后单独处理
  for (final zone in game.world.zones) {
    if (zone.name) {
      continue
    }
    late category
    if (zone.category == _kZoneWater) {
      category = zone.terrainIndexes.length < _kMinZoneSizeForSea ? _kZoneLake : _kZoneWater
    } else {
      category = zone.category
    }
    final r = nameGenerator.getZone(1, category: category)
    zone.name = r.first.name
  }
  
  // 将大陆和海洋接触的地方填充为大陆架
  for (final index in shelf) {
    final tile = game.world.terrains[index]
    tile.spriteIndex = _kSpriteShelf
  }
  print('将大陆和海洋接触的地方填充为大陆架')

  for (final location of game.locations) {
    final start = game.world.terrains[location.terrainIndex]
    // 确保陆地上的每个城市至少可以链接到另外两个城市
    if (start.zoneCategory == _kZoneContinent) {
      final searchResult = find2NearestLocation(location, restricted2Zone: true)
      if (searchResult.nearest) {
        final end = game.world.terrains[searchResult.nearest.terrainIndex]
        final route = calculateRoute(start, end)
        if (route) {
          // routes.add(route)
          for (final index in route) {
            final terrain = game.world.terrains[index]
            terrain.isRoute = true
          }
        }
      }
      if (searchResult.secondNearest) {
        final end = game.world.terrains[searchResult.secondNearest.terrainIndex]
        final route = calculateRoute(start, end)
        if (route) {
          // routes.add(route)
          for (final index in route) {
            final terrain = game.world.terrains[index]
            terrain.isRoute = true
          }
        }
      }
    }
  }
  print('确保陆地上的每个城市至少可以链接到另外两个城市')

  // 将大陆上没有道路的方格，随机填充为平原、森林、山地
  for (final index in landZone.terrainIndexes) {
    final terrain = game.world.terrains[index]
    if (!terrain.isRoute) {
      final r = Math.random()
      if (r < _kMountainThreshold) {
        terrain.spriteIndex = _kSpriteMountain
      } else if (r < _kForestThreshold) {
        terrain.spriteIndex = _kSpriteForest
      }
    }
  }
  
  print('将大陆上没有道路的方格，随机填充为平原、森林、山地')

  // 随机挑选几个城市，作为各个国家的都城
  while (game.nations.length < nationNumber) {
    var location
    do {
      location = game.locations.values.random
    } while (location.nationId != null)
    // print('picking location for new nation capital: ${location}')
    final nation = Nation(capitalId: location.id)
    final terrain = game.world.terrains[location.terrainIndex]
    addTerrain2Nation(nation, terrain)
  }
  
  print('随机挑选几个城市，作为各个国家的都城')

  // 生成地图上的不同国家
  // 根据相邻的格子的 nationId 进行分配
  fun expandNation(nation) {
    // print('processing nation: ${nation}')
    assert(nation.borderIndexes != null && nation.borderIndexes.length > 0)
    var expanded = false
    // avoid editing iterable while iterating
    final currentBorder = nation.borderIndexes.toList()
    for (final index in currentBorder) {
      final terrain = game.world.terrains[index]
      if (terrain.nationId == null && terrain.zoneCategory == _kZoneContinent) {
        addTerrain2Nation(nation, terrain)
        expanded = true
      }
    }
    return expanded
  }
  engine.info('生成地图上的不同国家')

  // 随机选择各个国家的都城，然后各自扩散都城直到没有没有分配国家的区块
  var unoccupiedTile
  while (
    unoccupiedTile = game.world.terrains.firstWhere((tile) => tile.nationId == null && tile.zoneCategory == _kZoneContinent)
  ) {
    final nation = game.nations.values.random
    expandNation(nation)
    // print('expanded nation ${nation.name}')
  }
  engine.info('随机选择各个国家的都城，然后决定国家疆域')

  // 刷新上色信息
  updateWorldMapZoneColors()
  updateWorldMapNationColors()
  engine.info('刷新上色信息')

  final leaders = []
  final headquarters = []

  // 向世界中填充门派, 每个国家有且只有一个门派
  // 初始门派全部为修真门派，且只有一个据点，位置在该国首都
  for (final nation of game.nations) {
    var location = game.locations[nation.capitalId]
    final leader = Character(
      spiritRank: 1,
      birthPlaceId: location.id,
      nationId: nation.id,
    )
    setCharacterLocationId(leader, location.id)

    // 为每个角色设置初始玄功
    // final arcanePower = getArcanePower('common')
    // levelUpAttributes(arcanePower)
    // final martialArts = getMartialArts('common')
    // levelUpAttributes(martialArts)

    // leader.skills.knowledges[arcanePower.id] = arcanePower
    // leader.skills.knowledges[martialArts.id] = martialArts
    // leader.skills.equipments.arcanePowerId = arcanePower.id
    // leader.skills.equipments.martialArtsId = martialArts.id

    // recalculateAttributesOfCharacter(leader)
    
    // 为每个角色生成初始物品
    final kEquipmentCategory = ['weapon', 'armor', 'boot', 'talisman']
    final kEquipmentCategoryWithoutBoot = ['weapon', 'armor', 'talisman']

    final org = Organization(
      category: _kOrganizationCategoryCultivation,
      nationId: nation.id,
      headquartersId: location.id,
      leaderId: leader.id
    )

    leaders.add(leader)
    headquarters.add(location)
  }
  engine.info('向世界中填充门派')

  // 在总堂所在据点生成初始建筑
  // 向门派中填充角色
  // for (final location in headquarters) {
  //   final npcCount = Math.randomInt(_kMaxNpcNumberForOrganization - _kMinNpcNumberForOrganization) + _kMinNpcNumberForOrganization


  // }

  // 让一开始的几个掌门先互相认识
  final subject = leaders.first
  for (var i in range(1, leaders.length)) {
    final target = leaders[i]
    firstImpressionOfOtherCharacter(subject, target)
    for (var j in range(i + 1, leaders.length)) {
      final target2 = leaders[j]
      firstImpressionOfOtherCharacter(target, target2)
    }
  }
  engine.info('让一开始的几个掌门先互相认识')

  // 触发创派事件
  for (final leader in leaders) {
    final nation = game.nations[leader.nationId]
    final location = game.locations[leader.currentLocationId]
    final org = game.organizations[leader.organizationId]
    final incidentContent = getLocaleString('createOrganizationEvent', [
      leader.name,
      nation.name,
      location.name,
      org.name,
    ])
    Incident(
      content: incidentContent,
      order: 30,
      subjectId: leader.id,
      isGlobal: true,
    )
  }
  engine.info('触发创派事件')
  
  // final playerCharacter001 = {
  
  //   currentLocation: 'baiheguan',
  //   currentScene: null,

  //   master: {
  //     characterId,
  //     bond,
  //   }

  //   talisman: [
  //     {
  //       index: 1,
  //       name: 'talisman.tier0.steelSword',
  //       attack: 25,
  //       speed: 15,

  //       skill: {
  //         name: 'talisman.steelSword.skill',
  //         attack: 100,
  //         speed: 25,
  //       }
  //     },
  //   ],
  // }
  setHero(game.characters.keys.random)

  engine.info('世界生成完毕。')

  return MapComponent.fromJson(data: game.world.toJson(), engine: engine)
}
