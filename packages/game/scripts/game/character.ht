import 'common.ht'
import 'game.ht'
import 'l10n.ht'
import 'datetime.ht'
import 'incident.ht'
import 'generator/entity/entity.ht' as randomEntity

// number of the male avatar images
const kMaleAvatarCount = 37
 // number of the female avatar images
const kFemaleAvatarCount = 75
const kCharacterInitialMinAge = 10
const kCharacterInitialMaxAge = 25

const kCharacterAverageLooks = 75.0
/// 容貌最大值: 100.0
const kCharacterLooksMax = 100.0
const kCharacterImpressionCheckpoint = 10.0

const kSpiritRankTitle = 'spiritRankTitle'
const kOrganizationLeaderTitle = 'organizationLeaderTitle'

// 羁绊, 人物对其他的某个事物的印象和评价
struct Bond {
  var id
  var name
  var score

  construct ({
    id,
    name,
    score = 0
  }) {
    this.id = id
    this.name = name
    this.score = score
    this.incidentScores = {}
  }
}

struct Character {
  construct ({
    familyName,
    shortName,
    isFemale: bool,
    birthTimestamp,
    spiritRank,
    birthPlaceId,
    nationId,
  }) {
    assert(birthPlaceId != null)
    assert(nationId != null)

    this.index = game.characters.length
    if (isFemale != null) {
      this.isFemale = isFemale
    } else {
      this.isFemale = Math.randomInt(2) == 0
    }
    if (isFemale) {
      final index = Math.randomInt(kFemaleAvatarCount)
      this.avatar = 'avatar/male/${index}.jpg';
    } else {
      final index = Math.randomInt(kMaleAvatarCount)
      this.avatar = 'avatar/male/${index}.jpg';
    }
    if (familyName != null && shorname != null) {
      this.familyName = familyName
      this.shortName = shortName
      this.name = familyName + shortName
    } else {
      final randomName = randomEntity.getCharacter(1, isFemale: this.isFemale).first
      this.familyName = randomName.familyName
      this.shortName = randomName.shortName
      this.name = randomName.name
    }
    this.id = 'character_${this.index}_${this.name}'
    // age 的格式是 timestamp, 精确到 tick. 
    if (birthTimestamp != null) {
      this.birthTimestamp = birthTimestamp
    } else {
      this.birthTimestamp = _createRandomBirthTimestamp()
    }
    this.looks = _createRandomLooks(kCharacterAverageLooks)
    this.favoredLooks = _createRandomLooks()

    this.birthPlaceId = birthPlaceId
    this.nationId = nationId

    this.spiritRank = spiritRank ?? 0

    // 该角色的称号
    this.titles = {
      kSpiritRankTitle: getSpiritRankTitle(this.spiritRank)
    }
    this.currentTitleId = kSpiritRankTitle

    // 该角色对世界上的其他事物的关系
    this.bonds = {
      characters: {},
      organizations: {},
      talismans: {},
      locations: {},
      nations: {},
    }

    // 该角色的人格纬度
    this.personality = {
      // 三观，最小 -50 最大 +50
      ideal: Math.random() * 100.0 - 50.0,
      order: Math.random() * 100.0 - 50.0,
      good: Math.random() *100.0 - 50.0,

      // 行为逻辑，最小 -50 最大 +50
      social: Math.random() * 100.0 - 50.0,
      intuition: Math.random() * 100.0 - 50.0,
      reason: Math.random() * 100.0 - 50.0.0,
      controlment: Math.random() * 100.0 - 50.0,
    }
 
    // 名声，指有多少人知道此人的名字
    this.fame = 0

    // // 恶名，知道名字中，对此人差评的人的数量
    // this.infamy = 0

    this.incidentIndexes = []

    game.characters[this.id] = this
  }
}

fun getCharAgeString(character) {
  return toAgeString(game.timestamp - character.birthTimestamp)
}

fun _createRandomBirthTimestamp() {
  final age = Math.randomInt(kCharacterInitialMaxAge - kCharacterInitialMinAge) + kCharacterInitialMinAge
  final randomDateInAYear = Math.randomInt(kTicksPerYear)
  return game.timestamp - (age * kTicksPerYear + randomDateInAYear)
}

// 第一印象分
fun firstImpressionOfOtherCharacter(subject, target) {
  var bond
  var hasBond = false
  if (subject.bonds.characters[target.id] != null) {
    hasBond = true
    bond = subject.bonds.characters[target.id]
    assert(bond.scoreOfLooks == null)
  } else {
    bond = Bond(id: target.id, name: target.name)
  }
  var score = 0
  score += _calculateLooksScore(looks: target.looks, favor: subject.favoredLooks) / 10
  if (target.organizationId != null) {
    // TODO: 敌对门派要减分
    score += target.organizationId == subject.organizationId ? 10 : 0
  }
  // TODO: 敌对国家要减分
  // TODO: 这两个挪到聊天互动之后再计算
  // bond.scoreOfSameNation = target.nationId == subject.nationId ? 5 : 0
  // bond.scoreOfSameBirthPlace = target.birthPlaceId == subject.birthPlaceId ? 10 : 0
  score += target.familyName == subject.familyName ? 10: 0
  // TODO: 同名之谊?

  var incidentContent
  if (bond.score < -kCharacterImpressionCheckpoint) {
    incidentContent = getLocaleString('characterFirstImpressionHateEvent', [
      subject.name,
      target.name,
    ])
  } else if (bond.score > kCharacterImpressionCheckpoint) {
    incidentContent = getLocaleString('characterFirstImpressionLikeEvent', [
      subject.name,
      target.name,
    ])
  } else {
    incidentContent = getLocaleString('characterFirstImpressionNormalEvent', [
      subject.name,
      target.name,
    ])
  }

  final incident = Incident(
    content: incidentContent,
    subjectId: subject.id,
    isPublic: false,
  )

  bond.incidentScores[incident.index] = score
  bond.score += score

  if (!hasBond) {
    ++target.fame
    subject.bonds.characters[target.id] = bond
  }
}

fun characterHeardOfIncident(character, incident) {
  final subject = game.characters[incident.subjectId]
  final score = ((character.personality.ideal * incident.ideal +
                 character.personality.order * incident.order +
                 character.personality.good * incident.good) / 100)
  if (character.bonds.characters.containsKey(incident.subjectId)) {
    final bond = character.bonds.characters[incident.subjectId]
    bond.incidentScores[incident.index] = score
    bond.score += score
    // 评价发生了改变
    // if (oldScore < 0 && bond.score >= 0) {
    //   --subject.infamy
    // } else if (oldScore >= 0 && bond.score < 0) {
    //   ++subject.infamy
    // }
  } else {
    // 名声增加
    ++subject.fame
    final bond = Bond(id: subject.id, name: subject.name)
    bond.incidentScores[incident.index] = score
    bond.score += score
    character.bonds.characters[incident.subjectId] = bond
    // if (score < 0) {
    //   ++subject.infamy
    // }
  }
}

fun characterWitnessedIncident(character, incident) {
  
}

fun characterSufferedIncident(character, incident) {

}

fun getSpiritRankTitle(spiritRank) {
  return getLocaleString('spiritRank${spiritRank}') + getLocaleString('sorcerer')
}

fun getOrganizationLeaderTitle(organization) {
  return organization.name + getLocaleString('leader')
}

fun removeCharacterHome(character) {
  if (!character.homeId) return

  final loc = game.locations[character.homeId]
  delete loc.wildCharacterIds[character.id]
  delete loc.organizedCharacterIds[character.id]
  character.homeId = null
}

fun setCharacterHome(location, character, {isOrganized: bool = true}) {
  if (character.homeId != null) {
    assert(character.homeId != location.id)
    removeCharacterHome(character)
  }
  if (isOrganized) {
    location.organizedCharacterIds[character.id] = character.name
  } else {
    location.wildCharacterIds[character.id] = character.name
  }
  character.homeId = location.id
}

fun setHero(id: str) {
  if (game.debug) {
    print('河图: 设置当前玩家人物为 [${id}] ...')
  }
  assert(game.characters.containsKey(id))
  game.heroId = id;
}

fun getHero() {
  return game.characters[game.heroId]
}

fun addCharacter(char) {
  if (char.nameId) {
    char.name = getLocaleString(char.nameId)
  }
  if (char.artNameId) {
    char.artName = getLocaleString(char.artNameId)
  }
  game.characters[char.id] = char
}

fun addCharacters(chars: List) {
  if (game.debug) {
    print('河图: 载入人物数据 ...')
  }
  for (final char in chars) {
    addCharacter(char)
  }
}

fun getCharacterById(id: str) {
  return game.characters[id]
}

fun getCharacters() {
  return game.characters
}

fun handleCharacterInteraction(characterId) {
  final character = game.characters[characterId]
  print('interaction:', character.name)
}

/// 获得随机容貌或者偏好
/// 大多数人都会接近于标准的100
/// 取值离100越远，随机出的可能性越低
/// 公式: y=\frac{6x-6}{5x-6}
fun _createRandomLooks([mean = kCharacterLooksMax]) {
  final x = Math.random()
  return ((x * 6 - 6) / (5 * x - 6)) * mean
}

/// 容貌评价的计算公式
/// 每个角色自身有一个容貌值，这个数值代表大众眼中的评价
/// 每个角色都会有一个对特定容貌值的偏好
/// 本公式会利用这两个数值，计算某个角色对另一个角色的容貌的评价
/// looks 是对方的容貌，0 <= looks <= 100
/// favor 是该角色的偏好，0 <= taste <= 100
fun _calculateLooksScore({looks: float, favor: float}) -> float {
  assert(0.0 <= looks && looks <= kCharacterLooksMax)
  if (favor != null) {
    assert(0.0 <= favor && favor <= kCharacterLooksMax)
  }
  if (looks < ((favor + kCharacterLooksMax) / 2)) {
    return (-(looks - favor) * (looks - favor)) / 20 + kCharacterLooksMax
  } else {
    return (-(looks - kCharacterLooksMax) * (looks - kCharacterLooksMax)) / 20 + kCharacterLooksMax
  }
}