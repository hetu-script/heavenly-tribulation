import 'common.ht'
import 'game.ht'
import 'l10n.ht'
import 'generator/random_names/random_names.ht' as randomNames

// number of the male avatar images
const kMaleAvatarCount = 37
 // number of the female avatar images
const kFemaleAvatarCount = 75
const kCharacterInitialMinAge = 10
const kCharacterInitialMaxAge = 100

const kCharacterAverageLooks = 75.0
/// 容貌最大值: 100.0
const kCharacterLooksMax = 100.0

const kSpiritRankTitle = 'spiritRankTitle'
const kOrganizationLeaderTitle = 'organizationLeaderTitle'

struct Character {
  construct ({
    name,
    isFemale: bool,
    age, spiritRank,
    birthPlaceId,
    nationId,
  }) {
    assert(birthPlaceId != null)
    assert(nationId != null)

    this.index = game.characters.length
    if (isFemale != null) {
      this.isFemale = isFemale
    } else {
      this.isFemale = Math.randomInt(2) == 0
    }
    if (isFemale) {
      final index = Math.randomInt(kFemaleAvatarCount)
      this.avatar = 'avatar/male/${index}.jpg';
    } else {
      final index = Math.randomInt(kMaleAvatarCount)
      this.avatar = 'avatar/male/${index}.jpg';
    }
    if (name) {
      this.name = name
    } else {
      final names = randomNames.getName(1, isFemale: this.isFemale)
      this.name = names.first.name
    }
    this.id = 'character_${this.index}_${this.name}'
    this.age = age ?? Math.randomInt(kCharacterInitialMaxAge - kCharacterInitialMinAge) + kCharacterInitialMinAge
    this.looks = createRandomLooks(kCharacterAverageLooks)
    this.favoredLooks = createRandomLooks()

    this.birthPlaceId = birthPlaceId
    this.nationId = nationId

    this.spiritRank = spiritRank ?? 0

    // 该角色的称号
    this.titles = {
      kSpiritRankTitle: getSpiritRankTitle(this.spiritRank)
    }
    this.currentTitleId = kSpiritRankTitle

    // 该角色对世界上的其他事物的关系
    this.bonds = {
      nations: {
        // id(str): favor(int) 无上下限，可以一直累加
      },
      locations: {},
      organizations: {},
      characters: {},
    }

    // 该角色的人格纬度
    this.personality = {
      // 三观，最小 -50 最大 +50
      ideal: Math.randomInt(100) - 50,
      order: Math.randomInt(100) - 50,
      good: Math.randomInt(100) - 50,

      // 行为逻辑，最小 -50 最大 +50
      social: Math.randomInt(100) - 50,
      intuition: Math.randomInt(100) - 50,
      reason: Math.randomInt(100) - 50,
      controlment: Math.randomInt(100) - 50,
    }
 
    // 名声，指有多少人知道此人的名字
    this.fame = 0

    // // 恶名，知道名字中，对此人差评的人的数量
    // this.infamy = 0

    this.incidentIndexes = []

    game.characters[this.id] = this
  }
}

fun characterHeardOfIncident(character, incident) {
  final subject = game.characters[incident.subjectId]
  final favor = (character.personality.ideal * incident.ideal +
                 character.personality.order * incident.order +
                 character.personality.good * incident.good) / 100
  if (character.bonds.characters.containsKey(incident.subjectId)) {
    final bond = character.bonds.characters[incident.subjectId]
    final oldFavor = bond.favor
    bond.favor += favor
    bond.incidentIndexes.add(incident.index)
    // 评价发生了改变
    // if (oldFavor < 0 && bond.favor >= 0) {
    //   --subject.infamy
    // } else if (oldFavor >= 0 && bond.favor < 0) {
    //   ++subject.infamy
    // }
  } else {
    // 名声增加
    ++subject.fame
    character.bonds.characters[incident.subjectId] = {
      favor,
      incidentIndexes: [incident.index],
    }
    // if (favor < 0) {
    //   ++subject.infamy
    // }
  }
}

fun getSpiritRankTitle(spiritRank) {
  return getLocaleString('spiritRank${spiritRank}') + getLocaleString('sorcerer')
}

fun getOrganizationLeaderTitle(organization) {
  return organization.name + getLocaleString('leader')
}

fun removeCharacterHome(character) {
  if (!character.homeId) return

  final loc = game.locations[character.homeId]
  loc.wildCharacterIds.remove(character.id)
  loc.organizedCharacterIds.remove(character.id)
  character.homeId = null
}

fun setCharacterHome(location, character, {isOrganized: bool = true}) {
  if (character.homeId != null) {
    assert(character.homeId != location.id)
    removeCharacterHome(character)
  }
  if (isOrganized) {
    location.organizedCharacterIds.add(character.id)
  } else {
    location.wildCharacterIds.add(character.id)
  }
  character.homeId = location.id
}

fun setHero(id: str) {
  if (game.debug) {
    print('河图: 设置当前玩家人物为 [${id}] ...')
  }
  assert(game.characters.containsKey(id))
  game.heroId = id;
}

fun getHero() {
  return game.characters[game.heroId]
}

fun addCharacter(char) {
  if (char.nameId) {
    char.name = getLocaleString(char.nameId)
  }
  if (char.artNameId) {
    char.artName = getLocaleString(char.artNameId)
  }
  game.characters[char.id] = char
}

fun addCharacters(chars: List) {
  if (game.debug) {
    print('河图: 载入人物数据 ...')
  }
  for (final char in chars) {
    addCharacter(char)
  }
}

fun getCharacterById(id: str) {
  return game.characters[id]
}

fun getCharacters() {
  return game.characters
}

fun handleCharacterInteraction(char, {isAtHome: bool}) {
  final entity = getEntityById(char.id)
  showGameDialogById('event01')
}

/// 获得随机容貌或者偏好
/// 大多数人都会接近于标准的100
/// 取值离100越远，随机出的可能性越低
/// 公式: y=\frac{6x-6}{5x-6}
fun createRandomLooks([mean = kCharacterLooksMax]) {
  final x = Math.random()
  return ((x * 6 - 6) / (5 * x - 6)) * mean
}

/// 容貌评价的计算公式
/// 每个角色自身有一个容貌值，这个数值代表大众眼中的评价
/// 每个角色都会有一个对特定容貌值的偏好
/// 本公式会利用这两个数值，计算某个角色对另一个角色的容貌的评价
/// looks 是对方的容貌，0 <= looks <= 100
/// favors 是该角色的偏好，0 <= favors <= 100
fun calculateLooksScore(looks: float, {favors: float}) -> float {
  assert(0.0 <= looks && looks <= kCharacterLooksMax)
  if (favors != null) {
    assert(0.0 <= favors && favors <= kCharacterLooksMax)
  }
  if (looks < ((favors + kCharacterLooksMax) / 2)) {
    return (-(looks - favors) * (looks - favors)) / 20 + kCharacterLooksMax
  } else {
    return (-(looks - kCharacterLooksMax) * (looks - kCharacterLooksMax)) / 20 + kCharacterLooksMax
  }
}
